<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RuiChen</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-27T18:58:06.870Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>RuiChen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maya绑定</title>
    <link href="http://example.com/2024/07/21/DCC%E8%BD%AF%E4%BB%B6-Maya%E7%BB%91%E5%AE%9A/"/>
    <id>http://example.com/2024/07/21/DCC%E8%BD%AF%E4%BB%B6-Maya%E7%BB%91%E5%AE%9A/</id>
    <published>2024-07-21T05:40:00.000Z</published>
    <updated>2024-07-27T18:58:06.870Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a name="Tn5Qr"></a></p><h1 id="transform节点"><a href="#transform节点" class="headerlink" title="transform节点"></a>transform节点</h1><p>使用ctrl+g打一个空组，这个空组就是最简单的transform节点，transform节点拥有移动旋转缩放这些属性。<br>一个模型是由transform节点和shape节点共同组成的，shape决定模型的形状，transform决定模型的移动旋转缩放，transform节点为shape节点的父级。<br><a name="LVCHR"></a></p><h1 id="父子层级关系"><a href="#父子层级关系" class="headerlink" title="父子层级关系"></a>父子层级关系</h1><p>移动旋转缩放的数值都是在相对位置下的数值，父物体进行的任何的移动旋转缩放都不会影响到子物体的数值。<br>当父物体进行旋转的同时子物体的坐标系也会相应的发生变化，因此有时候会出现，在世界坐标系下朝一个轴移动子物体，但是显示的是子物体有两个坐标轴数值发生变化（因为子物体使用的是相对坐标系）。<br><a name="Q5jw4"></a></p><h1 id="移动旋转缩放之间的关系"><a href="#移动旋转缩放之间的关系" class="headerlink" title="移动旋转缩放之间的关系"></a>移动旋转缩放之间的关系</h1><p>移动是旋转的父物体，旋转是缩放的父物体。<br><a name="NnxOl"></a></p><h1 id="使用功能时选择的物体的先后顺序以及功能介绍"><a href="#使用功能时选择的物体的先后顺序以及功能介绍" class="headerlink" title="使用功能时选择的物体的先后顺序以及功能介绍"></a>使用功能时选择的物体的先后顺序以及功能介绍</h1><p><a name="SBu5u"></a></p><h2 id="p键决定层级关系"><a href="#p键决定层级关系" class="headerlink" title="p键决定层级关系"></a>p键决定层级关系</h2><p>使用p键时会以最后选择的物体当父级，其余的选择物体都作为最后选择的物体的子级<br><a name="Pkc4n"></a></p><h2 id="blendshape"><a href="#blendshape" class="headerlink" title="blendshape"></a>blendshape</h2><p>最后选择的物体是需要进行变形的物体，前面选择的是变形的目标。前面如果选择了多个物体，那么会分开创建多个变形目标。<br><a name="m3YgD"></a></p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>最后选择的是被约束的物体（子），被约束的物体会带有约束节点，在约束节点中可以控制约束物体对被约束物体的影响权重<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1670217536060-ad82bcd7-0f17-4473-98c9-ee0fb165009a.png#averageHue=%23484241&amp;clientId=uf4d82161-efcf-4&amp;from=paste&amp;height=176&amp;id=u69a48566&amp;originHeight=158&amp;originWidth=296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7358&amp;status=done&amp;style=none&amp;taskId=ua68c44b7-9cb2-4d52-9f1d-8e9377af5d9&amp;title=&amp;width=328.8888976014693" alt="image.png">，权重的计算：平均，例如这里数值都为一，那么各占二分之一，也就是50%<br><a name="gYChr"></a></p><h2 id="表达式（不推荐，了解即可）"><a href="#表达式（不推荐，了解即可）" class="headerlink" title="表达式（不推荐，了解即可）"></a>表达式（不推荐，了解即可）</h2><p>表达式是不需要在乎选择顺序的<br>表达式使用方法：首先选中要进行表达式计算的物体，然后选一个属性，然后在edit栏中找到expression editor<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1670217729877-0b481305-a4c4-438e-a12e-e8f67fab7796.png#averageHue=%234e514f&amp;clientId=uf4d82161-efcf-4&amp;from=paste&amp;height=137&amp;id=ubdc3c003&amp;originHeight=123&amp;originWidth=426&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23707&amp;status=done&amp;style=none&amp;taskId=ue69569e8-fd3a-446a-9faa-a3620971bb8&amp;title=&amp;width=473.3333458723849" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1670217938545-81a94081-a3fb-42f8-a228-2538f5749ea4.png#averageHue=%234d504d&amp;clientId=uf4d82161-efcf-4&amp;from=paste&amp;height=827&amp;id=ud6311239&amp;originHeight=744&amp;originWidth=803&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=125261&amp;status=done&amp;style=none&amp;taskId=uc335e098-db46-476c-b261-b1e5801a1c8&amp;title=&amp;width=892.22224585804" alt="image.png"></p><p><a name="Mn4S5"></a></p><h1 id="约束，父子层级关系，属性连接，驱动关键帧，表达式之间的区别"><a href="#约束，父子层级关系，属性连接，驱动关键帧，表达式之间的区别" class="headerlink" title="约束，父子层级关系，属性连接，驱动关键帧，表达式之间的区别"></a>约束，父子层级关系，属性连接，驱动关键帧，表达式之间的区别</h1><p><a name="QNPDu"></a></p><h2 id="父子约束与父子层级关系之间的区别"><a href="#父子约束与父子层级关系之间的区别" class="headerlink" title="父子约束与父子层级关系之间的区别"></a>父子约束与父子层级关系之间的区别</h2><p>1.父子约束不对缩放进行控制<br>2.父子约束中被约束的物体的位置旋转信息都记录在约束节点上，因此针对被约束物体进行的移动旋转不会记录。而拥有父子层级关系的物体的情况是：子物体的移动旋转缩放都是自由的，只是父物体进行移动旋转缩放时子物体也会随着变化。<br>3.约束的优先级比父子层级关系高，当父子层级关系与约束同时存在时，优先使用约束的计算情况<br><a name="BcfgH"></a></p><h2 id="数值的计算区别"><a href="#数值的计算区别" class="headerlink" title="数值的计算区别"></a>数值的计算区别</h2><p>约束看的是世界位置<br>属性连接，驱动关键帧，表达式只针对数值<br>父子关系看的是相对位置<br><a name="X6jLR"></a></p><h1 id="约束的删除过程"><a href="#约束的删除过程" class="headerlink" title="约束的删除过程"></a>约束的删除过程</h1><p>直接delete掉约束节点<br><a name="NedpU"></a></p><h1 id="控制器创建过程"><a href="#控制器创建过程" class="headerlink" title="控制器创建过程"></a>控制器创建过程</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1670212442477-4d720069-5b65-4bfb-8eb7-7830c2ccee9b.png#averageHue=%238191a3&amp;clientId=uf4d82161-efcf-4&amp;from=paste&amp;height=433&amp;id=ud2b9ead6&amp;originHeight=390&amp;originWidth=806&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=154852&amp;status=done&amp;style=none&amp;taskId=u0e0c3759-2efc-4cb9-9b17-8c67e4171ab&amp;title=&amp;width=895.5555792796765" alt="image.png"><br><a name="FVJGm"></a></p><h1 id="匹配transformations功能介绍"><a href="#匹配transformations功能介绍" class="headerlink" title="匹配transformations功能介绍"></a>匹配transformations功能介绍</h1><p>将所有选择的物体的位移旋转缩放都设置为最后一个选择的物体的数值。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673598402928-4e8ff13b-38be-4e7a-9736-b85acad81b1e.png#averageHue=%2353504f&amp;clientId=u28c346ee-8da3-4&amp;from=paste&amp;height=246&amp;id=u367193f4&amp;originHeight=246&amp;originWidth=461&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25041&amp;status=done&amp;style=none&amp;taskId=u67ce78a4-019d-4119-a6e7-3d97eca7bde&amp;title=&amp;width=461" alt="image.png"><br><a name="NDP91"></a></p><h1 id="修改物体的线框颜色步骤"><a href="#修改物体的线框颜色步骤" class="headerlink" title="修改物体的线框颜色步骤"></a>修改物体的线框颜色步骤</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673598543851-c9dd3f11-8aa6-4dcf-8657-b9d2a2c84ace.png#averageHue=%234f4d4d&amp;clientId=u28c346ee-8da3-4&amp;from=paste&amp;height=772&amp;id=ucc431bc9&amp;originHeight=772&amp;originWidth=542&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=42538&amp;status=done&amp;style=none&amp;taskId=u408876cb-77b3-4383-ba7e-2904b757868&amp;title=&amp;width=542" alt="image.png"><br><a name="yVlg0"></a></p><h1 id="关节"><a href="#关节" class="headerlink" title="关节"></a>关节</h1><p><a name="N6Nbi"></a></p><h2 id="关节的介绍"><a href="#关节的介绍" class="headerlink" title="关节的介绍"></a>关节的介绍</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673258410606-e095c674-40b4-47d3-807c-d7d15313378f.png#averageHue=%2316110f&amp;clientId=u66a221f8-cbf0-4&amp;from=paste&amp;height=556&amp;id=yYqD3&amp;originHeight=445&amp;originWidth=872&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=123017&amp;status=done&amp;style=none&amp;taskId=udbcfee9a-000f-45fd-97fb-11e660ce8fc&amp;title=&amp;width=1089.9999837577345" alt="image.png"><br>关节的位移在冻结坐标系的时候，不会归零，旋转缩放能够归零，新增加的这个joint orient 的作用就是为了让旋转数值能为0，然后关节自带一个属性InverseScale目的是抵消冻结坐标系<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673258437041-3dbb1f61-28e4-4e27-af4b-52cae5726d35.png#averageHue=%2321130f&amp;clientId=u66a221f8-cbf0-4&amp;from=paste&amp;height=295&amp;id=Ot2uf&amp;originHeight=236&amp;originWidth=822&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=73071&amp;status=done&amp;style=none&amp;taskId=uf3578f4e-7491-4569-8f9e-6a02ff49986&amp;title=&amp;width=1027.499984689057" alt="image.png"><br>透过网格体显示关节：<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673258917333-2634fa7c-d218-4aad-aa42-2155e50f11ec.png#averageHue=%23545353&amp;clientId=u9ad9c0e9-3d00-4&amp;from=paste&amp;height=269&amp;id=MHNtz&amp;originHeight=215&amp;originWidth=447&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7018&amp;status=done&amp;style=none&amp;taskId=u5dda31eb-6cda-497a-9951-10ee80288ac&amp;title=&amp;width=558.7499916739763" alt="image.png"><br><a name="zTdFD"></a></p><h2 id="关节定向"><a href="#关节定向" class="headerlink" title="关节定向"></a>关节定向</h2><p>关节定向调整的是关节的坐标轴的方向<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673576217910-8fe1f174-accd-46ad-9174-ef2dd9d6e62c.png#averageHue=%235c5c5a&amp;clientId=ue3611319-9eae-4&amp;from=paste&amp;height=273&amp;id=WbcID&amp;originHeight=273&amp;originWidth=358&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=70991&amp;status=done&amp;style=none&amp;taskId=ufe86abbd-d60d-4432-8576-4390f8f673f&amp;title=&amp;width=358" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673577878554-0ce4507d-b69c-4a93-b0e6-9ac834b64729.png#averageHue=%23555454&amp;clientId=ue3611319-9eae-4&amp;from=paste&amp;height=515&amp;id=dZLIu&amp;originHeight=515&amp;originWidth=739&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=111005&amp;status=done&amp;style=none&amp;taskId=u17e5cec2-67ac-498d-9b68-993295717b8&amp;title=&amp;width=739" alt="image.png"><br><a name="l09B1"></a></p><h2 id="关节镜像"><a href="#关节镜像" class="headerlink" title="关节镜像"></a>关节镜像</h2><p>如果选择有父物体的子关节进行镜像的话，新创建出来的镜像关节也会以那个关节为父关节。<br>关节镜像不能批量镜像，镜像后再选择其他的按G重复上一次操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673578129859-6a12ebe9-1b6f-4e78-ba5c-29d422c5eb26.png#averageHue=%23676663&amp;clientId=ue3611319-9eae-4&amp;from=paste&amp;height=421&amp;id=fHkX1&amp;originHeight=421&amp;originWidth=767&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84032&amp;status=done&amp;style=none&amp;taskId=u6149bc9e-ca9b-404c-be28-2e7c2703bc5&amp;title=&amp;width=767" alt="image.png"><br><a name="mecrK"></a></p><h1 id="IK手柄"><a href="#IK手柄" class="headerlink" title="IK手柄"></a>IK手柄</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1671516712022-aa897777-850d-4232-b26f-cc6ddb6743c3.png#averageHue=%235a5857&amp;clientId=u5317e7fd-928b-4&amp;from=paste&amp;height=326&amp;id=udcf2be53&amp;originHeight=293&amp;originWidth=469&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13065&amp;status=done&amp;style=none&amp;taskId=ua06790f4-c5e6-4921-9f91-bff4286295d&amp;title=&amp;width=521.1111249158415" alt="image.png"><br>创建时先选择根关节后选择子关节<br><a name="uGZ5z"></a></p><h2 id="Single-Chain-Solver"><a href="#Single-Chain-Solver" class="headerlink" title="Single-Chain Solver"></a>Single-Chain Solver</h2><p>单一旋转平面，IK手柄的首端和尾端组成一个平面，反求关节位置时依靠平面计算。平面的改变通过更改手柄的旋转来实现。<br>一般使用在两个关节组成的骨骼<br><a name="FNOwK"></a></p><h2 id="Rotate-Plane-Solver"><a href="#Rotate-Plane-Solver" class="headerlink" title="Rotate-Plane Solver"></a>Rotate-Plane Solver</h2><p>多一个极向量，IK手柄的首端和尾端和极向量三者组成一个平面，反求关节位置时依靠平面计算。平面的改变通过更改极向量的位置来改变<br>一般使用在多个关节组成的骨骼<br>白色指向的就是极向量的方向<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1671517435221-dcb6ae72-643a-41a2-878b-8aba83293d12.png#averageHue=%235e5b5b&amp;clientId=u5317e7fd-928b-4&amp;from=paste&amp;height=417&amp;id=ufb9efb7d&amp;originHeight=375&amp;originWidth=608&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15936&amp;status=done&amp;style=none&amp;taskId=u579a9763-5522-4c8b-b8c8-bf3037d8d06&amp;title=&amp;width=675.5555734516666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1671517753572-6fe72f30-2825-44e2-86d0-c10183003ca0.png#averageHue=%2344403f&amp;clientId=u5317e7fd-928b-4&amp;from=paste&amp;height=370&amp;id=uf5bdb171&amp;originHeight=333&amp;originWidth=310&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12604&amp;status=done&amp;style=none&amp;taskId=u34c641e1-fd12-4db6-9116-d2f82db5b94&amp;title=&amp;width=344.4444535691064" alt="image.png"><br>可以通过创建定位器与IK手柄进行极向量约束（先选择定位器后选择ik手柄）<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1671517896461-b54e9a46-449d-4d26-9ec5-44d845a3ce67.png#averageHue=%235c5c5c&amp;clientId=u5317e7fd-928b-4&amp;from=paste&amp;height=681&amp;id=u6c824887&amp;originHeight=613&amp;originWidth=562&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7795&amp;status=done&amp;style=none&amp;taskId=uf02be324-ea0f-4a3d-9499-432f02a01b8&amp;title=&amp;width=624.4444609865734" alt="image.png"><br><a name="ry1kB"></a></p><h2 id="IK-Spline-Handle"><a href="#IK-Spline-Handle" class="headerlink" title="IK Spline Handle"></a>IK Spline Handle</h2><p>SplineIK一般用于多个关节组合的关节链（人的脊椎，蛇，龙等）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1671518819593-c1c03815-b05c-4c03-bb85-9f84aaffda5e.png#averageHue=%23565251&amp;clientId=u5317e7fd-928b-4&amp;from=paste&amp;height=487&amp;id=uba8bd816&amp;originHeight=438&amp;originWidth=242&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14652&amp;status=done&amp;style=none&amp;taskId=u37b02980-92eb-43b3-98d8-90c69d5bb1e&amp;title=&amp;width=268.8888960120121" alt="image.png"><br>使用的选择顺序： 先选择根关节后选择子关节，最后选择曲线(如果不使用自动创建曲线选项的话)（不是直接点是ctrl+鼠标点击加选）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1671518978840-21644317-cb3e-4e8f-a276-072a5de24296.png#averageHue=%235d5b5a&amp;clientId=u5317e7fd-928b-4&amp;from=paste&amp;height=330&amp;id=u4b89bd63&amp;originHeight=297&amp;originWidth=511&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22987&amp;status=done&amp;style=none&amp;taskId=u8e29af4f-7e61-48b6-a1dc-f3d7e627dc8&amp;title=&amp;width=567.7777928187527" alt="image.png"><br><a name="oy9n8"></a></p><h1 id="IKFK融合"><a href="#IKFK融合" class="headerlink" title="IKFK融合"></a>IKFK融合</h1><p>IKFK融合有两种方式，一种是通过约束，另一种是通过blend color<br><a name="Xy32X"></a></p><h2 id="约束方式"><a href="#约束方式" class="headerlink" title="约束方式"></a>约束方式</h2><p>首先需要考虑的是，需不需要关节的位移，如果需要关节的位移就使用父子约束或者点约束。但是使用父子约束或者点约束会产生一个问题。当IKFKBlend的数值为0~1的中间值时，maya会自动计算位置,这个计算的位置是最短路径位置（会导致关节的长度发生改变）。<br>1.先进行约束，分别对无IKFK手柄的整体，手肘，手腕进行旋转约束（最后选择）,然后更改插值方式为shortest<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673850121885-71c26598-b038-4a50-a2f4-a16c62a89260.png#averageHue=%23505653&amp;clientId=ucf2e48f1-0923-4&amp;from=paste&amp;height=733&amp;id=uca8b94eb&amp;originHeight=733&amp;originWidth=2234&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=590586&amp;status=done&amp;style=none&amp;taskId=ub8f1826f-ee92-43c1-a7ba-02101b0d46f&amp;title=&amp;width=2234" alt="image.png"><br>2.进行属性的连接<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673850817702-a5a9fd10-6815-4cd5-8133-175f956b46a5.png#averageHue=%23373030&amp;clientId=ucf2e48f1-0923-4&amp;from=paste&amp;height=1093&amp;id=u918e99e0&amp;originHeight=1093&amp;originWidth=1831&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=666339&amp;status=done&amp;style=none&amp;taskId=ue04c019f-5b4d-4239-8fb8-07f735f0948&amp;title=&amp;width=1831" alt="image.png"><br><a name="tM5E3"></a></p><h1 id="skinCluster"><a href="#skinCluster" class="headerlink" title="skinCluster"></a>skinCluster</h1><p>选择骨骼和模型（顺序无所谓）然后使用bind skin功能进行蒙皮，功能选项设置推荐如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673946303980-cffc4ca2-0722-44fe-b693-e69070530ede.png#averageHue=%23555554&amp;clientId=u729b1e5f-1fd5-4&amp;from=paste&amp;height=382&amp;id=u0484bcd7&amp;originHeight=382&amp;originWidth=548&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18710&amp;status=done&amp;style=none&amp;taskId=u0a6a0514-fb5c-465e-8bca-b48935d3ed8&amp;title=&amp;width=548" alt="image.png"><br>蒙皮后会生成skinCluster节点<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673946593477-dc346536-3cbd-42a2-8536-6f4dd3cd78de.png#averageHue=%2358473b&amp;clientId=u729b1e5f-1fd5-4&amp;from=paste&amp;height=1048&amp;id=u1f9f35df&amp;originHeight=1048&amp;originWidth=2088&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=662250&amp;status=done&amp;style=none&amp;taskId=ua7155168-e8e2-4c35-90cc-6c64a7cfd0c&amp;title=&amp;width=2088" alt="image.png"><br><a name="q17KV"></a></p><h1 id="addInfluence"><a href="#addInfluence" class="headerlink" title="addInfluence"></a>addInfluence</h1><p>这个是蒙皮完以后如果需要新添加关节就使用这个功能，推荐选项设置如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1673949125394-0b0e6326-7091-4ed6-8ea5-fd3da464da13.png#averageHue=%23515151&amp;clientId=u729b1e5f-1fd5-4&amp;from=paste&amp;height=466&amp;id=u389c67fc&amp;originHeight=466&amp;originWidth=667&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=63575&amp;status=done&amp;style=none&amp;taskId=u748f487f-5e95-418e-91e9-12035db399e&amp;title=&amp;width=667" alt="image.png"><br><a name="IUOjg"></a></p><h1 id="刷权重"><a href="#刷权重" class="headerlink" title="刷权重"></a>刷权重</h1><p>选中已经蒙皮的皮肤，然后右键找到Paint Skin Weights Tool<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674008708447-3780340e-fa6d-47c6-ad37-556ce56d6658.png#averageHue=%236c8092&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=322&amp;id=u43673dc3&amp;originHeight=322&amp;originWidth=711&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=128265&amp;status=done&amp;style=none&amp;taskId=u1444a44b-2812-4a6c-bab9-2786769efcf&amp;title=&amp;width=711" alt="image.png"><br><a name="XdKgG"></a></p><h1 id="变形器"><a href="#变形器" class="headerlink" title="变形器"></a>变形器</h1><p><a name="cXJX7"></a></p><h2 id="BlendShape"><a href="#BlendShape" class="headerlink" title="BlendShape"></a>BlendShape</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674021502267-8b64365c-ed79-474d-8ccc-f44b1d000af6.png#averageHue=%23514f4f&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=430&amp;id=u0cd4fae4&amp;originHeight=430&amp;originWidth=702&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75715&amp;status=done&amp;style=none&amp;taskId=u4db66afb-71ce-4228-b8b1-2149214b465&amp;title=&amp;width=702" alt="image.png"><br><a name="SAgWM"></a></p><h2 id="cluster簇"><a href="#cluster簇" class="headerlink" title="cluster簇"></a>cluster簇</h2><p>跟关节差不多，一般不用簇，簇跟关节一样都是影响对应的顶点。<br><a name="qFU0f"></a></p><h2 id="deltaMush"><a href="#deltaMush" class="headerlink" title="deltaMush"></a>deltaMush</h2><p>deltaMush的作用： 一个模型应用deltaMush后，移动模型的顶点时，变形器会自动平滑模型来使模型布线均匀。<br>注意：是应用deltaMush后再移动顶点。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674099425473-7e3080cb-8a93-47e5-93c9-b319f0a8dede.png#averageHue=%236f80a1&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=669&amp;id=u4df0011f&amp;originHeight=669&amp;originWidth=844&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=380832&amp;status=done&amp;style=none&amp;taskId=ud8d73674-d894-4249-b036-321e80efbe5&amp;title=&amp;width=844" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674099145812-75f8fe76-7175-45de-a154-2d3b1787fb00.png#averageHue=%2353524f&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=284&amp;id=uba80905e&amp;originHeight=284&amp;originWidth=400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=64997&amp;status=done&amp;style=none&amp;taskId=ud3c03d7b-54a3-4e3d-a7c0-9fcbbd59d32&amp;title=&amp;width=400" alt="image.png"><br>参数介绍： <br>envelope是总的影响程度设置<br>distance weight 为0时不会考虑模型的布线，会平滑所有模型曲线。如果值为1时，那么会自动判断模型的布线，平滑时不会影响模型中离得很近的线(那些用来卡线的线)。<br>displacement 为1时平滑时会考虑模型的细节，为0时不会考虑模型的细节。<br><a name="QOEjE"></a></p><h2 id="lattice晶格变形器"><a href="#lattice晶格变形器" class="headerlink" title="lattice晶格变形器"></a>lattice晶格变形器</h2><p>选择一个物体创建晶格变形器，会生成两个新节点：ffd1Lattice与ffd1Base。然后物体会根据ffd1Lattice与ffd1Base进行插值来产生形变<br><a name="Pqx7x"></a></p><h2 id="Wrap包裹变形器"><a href="#Wrap包裹变形器" class="headerlink" title="Wrap包裹变形器"></a>Wrap包裹变形器</h2><p>先选择被驱动物体，再选择驱动物体。<br>然后就像晶格变形器一样在驱动物体会产生一个base物体，然后被驱动物体会根据驱动物体与base物体之间进行插值来产生形变。<br>包裹变形器运行很慢，尽量不用。<br><a name="R12ZK"></a></p><h2 id="shrinkWrap"><a href="#shrinkWrap" class="headerlink" title="shrinkWrap"></a>shrinkWrap</h2><p>先选择被驱动物体，再选择驱动物体<br>应用这个变形器后，被驱动物体的顶点会根据不同的映射方式依附到驱动物体的顶点上面去。<br>映射方式介绍：<br>面片为被驱动物体，球为驱动物体<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674105821630-561e5323-d8df-4b85-b4fd-ee0cb7b07ee2.png#averageHue=%23434342&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=241&amp;id=u01fbd000&amp;originHeight=241&amp;originWidth=524&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=58598&amp;status=done&amp;style=none&amp;taskId=u749ca5fe-7de2-4c7e-934a-0014043ff7f&amp;title=&amp;width=524" alt="image.png"><br> Toward lnner object：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674105844158-564af453-1fe6-46ea-9079-459bffa2e810.png#averageHue=%23647381&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=180&amp;id=ub8f35d77&amp;originHeight=952&amp;originWidth=1586&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1054024&amp;status=done&amp;style=none&amp;taskId=u42f8420a-842c-48f7-8040-7e3a364133b&amp;title=&amp;width=300" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674105856727-601b6ee7-e2f8-4af0-b003-3c682ce607dd.png#averageHue=%23648183&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=178&amp;id=u81ae0845&amp;originHeight=490&amp;originWidth=692&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=302332&amp;status=done&amp;style=none&amp;taskId=u52459b8e-55e4-44f2-afea-69d11429554&amp;title=&amp;width=251" alt="image.png"><br>Vertex normals:<br>被驱动物体与驱动物体的接触的顶点会产生依附效果<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674106015351-e34399f0-ed98-4d22-bece-fa38520bed28.png#averageHue=%236a817f&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=214&amp;id=u2a8f8a2f&amp;originHeight=891&amp;originWidth=1421&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1194143&amp;status=done&amp;style=none&amp;taskId=u538817d5-47e4-40aa-a270-644f1986ff7&amp;title=&amp;width=341" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674106104759-3eb44e86-c529-4ac9-b7f0-a716a7b70dd0.png#averageHue=%237f8d81&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=172&amp;id=uf48d2b49&amp;originHeight=727&amp;originWidth=1291&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=660663&amp;status=done&amp;style=none&amp;taskId=u93078f12-c454-4d55-b216-4c4787ba59e&amp;title=&amp;width=306" alt="image.png"><br><a name="yD86A"></a></p><h2 id="Wire线变形器"><a href="#Wire线变形器" class="headerlink" title="Wire线变形器"></a>Wire线变形器</h2><p>使用步骤：<br>选择模型按回车，再选择曲线按回车<br>然后就可以通过曲线来驱动模型使模型产生形变<br>一些属性的介绍:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674106695740-58de65e6-8aa5-4be0-b37f-67673d251c50.png#averageHue=%23414141&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=242&amp;id=u90b0566c&amp;originHeight=242&amp;originWidth=582&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=53040&amp;status=done&amp;style=none&amp;taskId=u3655e9cf-cc07-4bf7-aa65-4cb8c123cab&amp;title=&amp;width=582" alt="image.png"><br>Rotation: 产生形变时对模型旋转属性影响的权重<br>Dropoff distance： 曲线点寻找最近的顶点的距离范围<br>变形器是可以刷权重的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674107272387-47291f7f-a956-4cdf-bc4b-2b923336abc2.png#averageHue=%235e605a&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=1148&amp;id=ub2d6705d&amp;originHeight=1148&amp;originWidth=417&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=263266&amp;status=done&amp;style=none&amp;taskId=ubefac0cd-ae31-4c5e-9f50-fcb5b6eb6f8&amp;title=&amp;width=417" alt="image.png"><br><a name="v54zy"></a></p><h2 id="Nonlinear非线性变形器"><a href="#Nonlinear非线性变形器" class="headerlink" title="Nonlinear非线性变形器"></a>Nonlinear非线性变形器</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674107436732-c044c177-673f-4a4f-82a3-aedae7925efd.png#averageHue=%23585956&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=213&amp;id=u55dcd8b8&amp;originHeight=213&amp;originWidth=529&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65312&amp;status=done&amp;style=none&amp;taskId=u5693f4ad-851f-4577-b92a-72cf3b5cfd0&amp;title=&amp;width=529" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674107864601-3ebdd4ef-ca5e-447b-ae35-4fc6ecbbde2d.png#averageHue=%235e6d80&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=629&amp;id=u25284a14&amp;originHeight=629&amp;originWidth=1093&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=191598&amp;status=done&amp;style=none&amp;taskId=u69a9992e-f21b-432e-a5c3-318be7e3542&amp;title=&amp;width=1093" alt="image.png"><br><a name="MymSj"></a></p><h2 id="sculpt雕刻变形器"><a href="#sculpt雕刻变形器" class="headerlink" title="sculpt雕刻变形器"></a>sculpt雕刻变形器</h2><p>选择一个模型就可以使用这个雕刻变形器了。没啥用这个变形器，他能做的shrinkWrap也能做并且更方便。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674108375883-b4128dd2-7ebf-4636-86ca-8bc5f10c41ba.png#averageHue=%23596987&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=563&amp;id=u70f38e32&amp;originHeight=563&amp;originWidth=712&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=450905&amp;status=done&amp;style=none&amp;taskId=u019d6c5e-8db2-496b-8b70-78d08a9f3bf&amp;title=&amp;width=712" alt="image.png"><br><a name="FDn1j"></a></p><h1 id="deformation-order"><a href="#deformation-order" class="headerlink" title="deformation_order"></a>deformation_order</h1><p>如果一个模型只受一个变形器控制都很好理解，但是如果受到多个变形器控制的话就会根据变形器的顺序不同而导致不同的结果，因此要理清变形器的顺序是很重要的。<br>这里介绍两个更改变形器执行的顺序的方法：<br>第一种：<br>选择好模型然后查看其所有的输入属性，然后通过鼠标中键拖拽即可改变变形器执行的顺序<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674112832754-5fb47a6d-38f3-4525-929c-f8bb19314217.png#averageHue=%23535451&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=264&amp;id=u72763447&amp;originHeight=264&amp;originWidth=382&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66502&amp;status=done&amp;style=none&amp;taskId=uaa04c244-170b-403a-88b2-495c2f134db&amp;title=&amp;width=382" alt="image.png"><br>第二种：deformation order<br>更改对应变形器的deformation order<br>automatic是让maya自己判断设置变形器的执行顺序，pre-deformation是将变形器设置成最先执行，post-deformation是将变形器设置成最后执行。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1674112912258-bb05c6fb-40cb-4529-acf5-4e5b5d8bacbc.png#averageHue=%23535353&amp;clientId=u0af6a990-500b-4&amp;from=paste&amp;height=453&amp;id=uf6af1e1e&amp;originHeight=453&amp;originWidth=711&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72269&amp;status=done&amp;style=none&amp;taskId=u181af5f8-b802-4a8d-a600-42d6fd9f519&amp;title=&amp;width=711" alt="image.png"><br><a name="jEW6m"></a></p><h1 id="快速转化低模"><a href="#快速转化低模" class="headerlink" title="快速转化低模"></a>快速转化低模</h1><p>首先通过自带的reduce功能减面，删除历史，使用deltaMush变形器并调整参数使布线变得均匀，删除历史，选择低模后选择高模使用shrinkWrap变形器并调整参数来保留高模的模型细节，删除历史。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1675221119348-35b72450-d2fc-4b8d-87f9-d0fe64a1195b.png#averageHue=%235b5a59&amp;clientId=u7fb7aa6f-4485-4&amp;from=paste&amp;height=603&amp;id=u41f81f5a&amp;originHeight=603&amp;originWidth=470&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=42211&amp;status=done&amp;style=none&amp;taskId=u0ebf8a5c-d834-4d3d-bea8-e192be2b143&amp;title=&amp;width=470" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1675221693200-dc2aedc3-c7d3-481c-a7f6-3328c41870a9.png#averageHue=%23464745&amp;clientId=u7fb7aa6f-4485-4&amp;from=paste&amp;height=273&amp;id=u1a530abf&amp;originHeight=273&amp;originWidth=389&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=62102&amp;status=done&amp;style=none&amp;taskId=u4536fd8b-bc76-4175-8110-346cad89b24&amp;title=&amp;width=389" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1675221640088-83ebb73b-f320-48e8-a014-4adfe704c730.png#averageHue=%23595855&amp;clientId=u7fb7aa6f-4485-4&amp;from=paste&amp;height=404&amp;id=u1d6c89c9&amp;originHeight=404&amp;originWidth=360&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=102413&amp;status=done&amp;style=none&amp;taskId=u0be85a61-a4df-4af9-8d7b-2bf4ec41c85&amp;title=&amp;width=360" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;a name=&quot;Tn5Qr&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;transform节点&quot;&gt;&lt;a href=&quot;#transform节点&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="DCC软件" scheme="http://example.com/categories/DCC%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Maya" scheme="http://example.com/tags/Maya/"/>
    
  </entry>
  
  <entry>
    <title>houdini</title>
    <link href="http://example.com/2024/07/21/DCC%E8%BD%AF%E4%BB%B6-houdini/"/>
    <id>http://example.com/2024/07/21/DCC%E8%BD%AF%E4%BB%B6-houdini/</id>
    <published>2024-07-21T05:40:00.000Z</published>
    <updated>2024-07-27T18:58:06.872Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a name="biomu"></a></p><h1 id="Houdini的一些专业术语"><a href="#Houdini的一些专业术语" class="headerlink" title="Houdini的一些专业术语"></a>Houdini的一些专业术语</h1><p><a name="yo3oF"></a></p><h2 id="不同网络的介绍"><a href="#不同网络的介绍" class="headerlink" title="不同网络的介绍"></a>不同网络的介绍</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689061156266-f97ffd6f-8523-4e9b-9881-5bc30905ad3e.png#averageHue=%23222222&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=1001&amp;id=ltCBL&amp;originHeight=1001&amp;originWidth=2049&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1345247&amp;status=done&amp;style=none&amp;taskId=u2413d157-4645-4ed0-a78c-4b5a5572c61&amp;title=&amp;width=2049" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689061605663-26354c46-c219-4ee1-832e-a075f297d2dd.png#averageHue=%23444241&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=232&amp;id=pkx9H&amp;originHeight=232&amp;originWidth=116&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14937&amp;status=done&amp;style=none&amp;taskId=u82469f77-6c15-4f0f-9397-9c69db01e7f&amp;title=&amp;width=116" alt="image.png"> <br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689061625011-6b95d11b-b34b-479b-aa72-7ab412e7e8f6.png#averageHue=%23424242&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=31&amp;id=DGN3z&amp;originHeight=31&amp;originWidth=75&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1885&amp;status=done&amp;style=none&amp;taskId=uc51dc965-3e6c-4697-b8f9-f1b34094ad5&amp;title=&amp;width=75" alt="image.png"> ch是控制动态和声音的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689061761639-7c3deb25-2fa2-4b1e-89fc-5b17fe6155d5.png#averageHue=%23494040&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=30&amp;id=rBWBv&amp;originHeight=30&amp;originWidth=78&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1866&amp;status=done&amp;style=none&amp;taskId=u099bfccf-c732-442a-a5a6-1d6022a2753&amp;title=&amp;width=78" alt="image.png">shop是旧的管理材质的，现在已经被mat代替了<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689062628883-6ae3c575-96bd-4b43-a1ac-d4473bdb749b.png#averageHue=%234c4640&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=30&amp;id=bCOfh&amp;originHeight=30&amp;originWidth=86&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2081&amp;status=done&amp;style=none&amp;taskId=u67346da3-5258-4085-a745-9a29c9a997d&amp;title=&amp;width=86" alt="image.png">stage(solaris):适用于lookdev，布局和照明，以USD为核心，可以使用专门的节点定位对象，实例化几何体和管理镜头布局。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689062633114-c4c47694-9015-4be7-9e31-eb357d3c610a.png#averageHue=%233e3d3b&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=30&amp;id=wK1fy&amp;originHeight=30&amp;originWidth=88&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1654&amp;status=done&amp;style=none&amp;taskId=u317279d8-e9c9-42ab-8bb2-b5cdd007082&amp;title=&amp;width=88" alt="image.png">tasks: 用于处理多线程任务和作业。它用于执行复杂的计算、模拟和渲染任务，并对其进行分析和管理<br><a name="Yltcj"></a></p><h2 id="particle与grains的区别"><a href="#particle与grains的区别" class="headerlink" title="particle与grains的区别"></a>particle与grains的区别</h2><p>grains是颗粒，particles是粒子<br>grains模拟的是颗粒材料，如沙子、粉末等。它们具有质量、速度、位置等物理属性，并受到力的作用。grains的模拟通常涉及颗粒之间的聚集、流动、堆积和碰撞等行为。<br>particles一般用于模拟离散的小元素，例如火花、烟雾、爆炸碎片等。粒子可以表示各种物理属性，如速度、位置、颜色等。particle的模拟通常设计粒子之间的移动、发射、生命周期和相互作用等。<br><a name="SGyGQ"></a></p><h2 id="HDA（OTL）"><a href="#HDA（OTL）" class="headerlink" title="HDA（OTL）"></a>HDA（OTL）</h2><p>HDA在旧版本中叫OTL，意思是Houdini Digital Asset 数字资产，当制作完一个程序化的模型或者动画或者效果等以后，可以将这些节点打包成一个HDA以便在不同的项目中进行共享和重复使用。<br>HDA不仅可以在Houdini中重复使用并且可以编辑，HDA也可以导出为独立的文件提供给其他DCC软件或者引擎来使用。<br>在houdini中这些带锁的节点都是HDA<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689320716023-6921b55b-1837-4d2a-bbd7-a2a00e41db9e.png#averageHue=%23383736&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=437&amp;id=uab7062e4&amp;originHeight=437&amp;originWidth=864&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=45822&amp;status=done&amp;style=none&amp;taskId=u7d7a7ce8-187a-4dcd-a2c4-f58c029d1be&amp;title=&amp;width=864" alt="image.png"><br><a name="ur7FM"></a></p><h3 id="制作HDA"><a href="#制作HDA" class="headerlink" title="制作HDA"></a>制作HDA</h3><p>首先将节点进行打包，并在打包节点中通过参数编辑器绑定对应的参数。<br>打包快捷键（shift+c）：选中节点后点击右上角图标<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689321623116-8160f13a-4721-4bd5-82f6-a1b21ec8c25f.png#averageHue=%233b3a39&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=267&amp;id=u80b0cf0e&amp;originHeight=267&amp;originWidth=477&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20582&amp;status=done&amp;style=none&amp;taskId=u64d57096-1f2d-4037-8357-f1ccf7f63b1&amp;title=&amp;width=477" alt="image.png">，<br>然后在打包的节点上右键选择创建HDA（这是18.5上面截的图，19.5上面没有，19.5版本需要在显示器左上角创建HDA）<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689322027591-a25ba17c-fff8-4d8f-ad81-58d2025ebf32.png#averageHue=%233e3c39&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=345&amp;id=u33ec8d17&amp;originHeight=345&amp;originWidth=387&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25085&amp;status=done&amp;style=none&amp;taskId=u61800548-abb0-4a76-bd45-e424522524b&amp;title=&amp;width=387" alt="image.png">，<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689322101513-49ea9641-6e85-4063-b809-5592b3d2a38a.png#averageHue=%234c4a48&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=109&amp;id=ue9c47823&amp;originHeight=109&amp;originWidth=531&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=24530&amp;status=done&amp;style=none&amp;taskId=u4c360d63-6875-4f33-995c-c9391713f1e&amp;title=&amp;width=531" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689322276022-e99e4260-c070-492d-a865-764081ff20de.png#averageHue=%2350504f&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=212&amp;id=u1c83773b&amp;originHeight=212&amp;originWidth=566&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23866&amp;status=done&amp;style=none&amp;taskId=u60db91a9-b047-46a7-9434-1ec7113138f&amp;title=&amp;width=566" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689322499588-4f49b052-e74d-498b-85cf-98e959991620.png#averageHue=%233f3e3e&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=855&amp;id=u3ab13769&amp;originHeight=855&amp;originWidth=1224&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84192&amp;status=done&amp;style=none&amp;taskId=ub9a83e84-0be0-4443-9219-80461d43e5f&amp;title=&amp;width=1224" alt="image.png"><br>保存以后在houdini的网络编辑器中输入HDA的名字来调用了，并且可以在houdini中再次调整HDA的默认参数。<br>并且在电脑里的houdini文档里面可以找到对应HDA文件：Documents\houdini19.5\otls<br><a name="ikxeV"></a></p><h3 id="修改HDA默认参数"><a href="#修改HDA默认参数" class="headerlink" title="修改HDA默认参数"></a>修改HDA默认参数</h3><p>方法一：先解锁节点的锁定。右键点击 Type Properties… 即可再次修改默认参数<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689322626633-d7217860-126d-44f9-b3d1-aae687e0abc9.png#averageHue=%23484540&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=487&amp;id=qIoJb&amp;originHeight=487&amp;originWidth=357&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43289&amp;status=done&amp;style=none&amp;taskId=u6224e910-98cf-485c-8da7-1bb2bee44fa&amp;title=&amp;width=357" alt="image.png"><br>方法二：在节点本身的参数面板中修改参数然后右键节点选择Save Node Type然后选择Match Current Definition<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689326490636-afa265a3-794d-4024-b092-45ed221420e4.png#averageHue=%234d463f&amp;clientId=u85a49878-3118-4&amp;from=paste&amp;height=418&amp;id=u8886ac0e&amp;originHeight=418&amp;originWidth=222&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27589&amp;status=done&amp;style=none&amp;taskId=u4b2d5c1d-ef71-4d78-9409-83c5abb320e&amp;title=&amp;width=222" alt="image.png"></p><p><a name="IBSWy"></a></p><h1 id="界面设置"><a href="#界面设置" class="headerlink" title="界面设置"></a>界面设置</h1><p><a name="brUG7"></a></p><h2 id="UI设置"><a href="#UI设置" class="headerlink" title="UI设置"></a>UI设置</h2><p>使用Ctrl + ,  进入界面设置<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689052670029-436cbe6e-4999-478d-8a63-3342240b5c54.png#averageHue=%234d473f&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=272&amp;id=u9559eddf&amp;originHeight=272&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54858&amp;status=done&amp;style=none&amp;taskId=ue5a25b2d-b0c2-4ac0-a5e5-6a4f447a20a&amp;title=&amp;width=620" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689052678655-525899c5-c1bc-4e65-aa1f-cbcbfcaa3243.png#averageHue=%233b3a3a&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=820&amp;id=u40ad350e&amp;originHeight=820&amp;originWidth=655&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=63975&amp;status=done&amp;style=none&amp;taskId=u46c7ad6f-8a15-4036-8868-37e693eca7c&amp;title=&amp;width=655" alt="image.png"><br><a name="kDDD4"></a></p><h2 id="视图还原"><a href="#视图还原" class="headerlink" title="视图还原"></a>视图还原</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689060593298-9d2ecce5-3592-4de9-b112-ee5403a555e9.png#averageHue=%23ac7624&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=549&amp;id=uf0f9253f&amp;originHeight=549&amp;originWidth=588&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183785&amp;status=done&amp;style=none&amp;taskId=ub1631d02-cfd1-4564-b52f-14e6e2d99c1&amp;title=&amp;width=588" alt="image.png"><br><a name="aYSVn"></a></p><h2 id="扩展界面布局"><a href="#扩展界面布局" class="headerlink" title="扩展界面布局"></a>扩展界面布局</h2><p>在基础视窗的下面创建一个新的视窗alt+]<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689151251229-fda78af2-3c3d-4c38-bfcf-4b915c3e8ead.png#averageHue=%23b87c2f&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=498&amp;id=u7af9267e&amp;originHeight=498&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=277488&amp;status=done&amp;style=none&amp;taskId=u1cfd423c-107c-4f26-8d15-acc5a3358a1&amp;title=&amp;width=1028" alt="image.png"><br>然后更改下面新创建的视窗的类型，这样就能够上面显示视窗，下面显示geometry的数据表格。<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689151406446-57d1695a-253a-4d4b-8fee-a7bcaa4dd4eb.png#averageHue=%236b6762&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=398&amp;id=ue83c3884&amp;originHeight=398&amp;originWidth=663&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=149134&amp;status=done&amp;style=none&amp;taskId=u871c11dd-13ae-41c3-be17-5a30bf3ee8d&amp;title=&amp;width=663" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689151463706-695c1046-d36a-4dcd-b0ae-c27945f0598b.png#averageHue=%23979982&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=1283&amp;id=uc948b111&amp;originHeight=1283&amp;originWidth=2344&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1385059&amp;status=done&amp;style=none&amp;taskId=u37308915-c697-49d0-9189-ccae57d8193&amp;title=&amp;width=2344" alt="image.png"></p><p><a name="fmM1d"></a></p><h1 id="工具架介绍"><a href="#工具架介绍" class="headerlink" title="工具架介绍"></a>工具架介绍</h1><p><a name="yam6V"></a></p><h2 id="Lights-and-Cameras灯光和摄像机"><a href="#Lights-and-Cameras灯光和摄像机" class="headerlink" title="Lights and Cameras灯光和摄像机"></a>Lights and Cameras灯光和摄像机</h2><p>这些工具用于在场景中创建和设置灯光和相机。灯光工具可以帮助您调整光源的属性和光照效果，而相机工具则用于设置场景的视角和渲染参数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048140387-e5ea0011-c3f5-47a1-b3fa-d694e655c195.png#averageHue=%23474541&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=44&amp;id=u7e327302&amp;originHeight=44&amp;originWidth=496&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13828&amp;status=done&amp;style=none&amp;taskId=udedd4f14-6057-4e81-b91e-94015c0a00c&amp;title=&amp;width=496" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048146922-fa49bac9-e955-4d88-ae43-257a5c3b6f34.png#averageHue=%233f3f3f&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=55&amp;id=u1d781436&amp;originHeight=55&amp;originWidth=468&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13691&amp;status=done&amp;style=none&amp;taskId=u9cd29529-a9c9-43d4-8edc-ff4d132f683&amp;title=&amp;width=468" alt="image.png"><br><a name="pkNfH"></a></p><h2 id="Collisions碰撞"><a href="#Collisions碰撞" class="headerlink" title="Collisions碰撞"></a>Collisions碰撞</h2><p>这个工具集用于处理物体之间的碰撞效果。它可以模拟物体之间的碰撞和反应，并生成逼真的物理效果。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047487367-4f683cc9-a0f8-409a-b66e-d668864be23c.png#averageHue=%23403f3e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=46&amp;id=u1d10c55a&amp;originHeight=46&amp;originWidth=383&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9320&amp;status=done&amp;style=none&amp;taskId=ua7540e2a-471e-4458-9044-22fac9a6a1e&amp;title=&amp;width=383" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689055021610-368a8881-109a-4fc2-97e6-353f0801322f.png#averageHue=%2343433f&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=65&amp;id=u81009f92&amp;originHeight=65&amp;originWidth=73&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3311&amp;status=done&amp;style=none&amp;taskId=u36acc161-a258-49ab-a290-a913237b121&amp;title=&amp;width=73" alt="image.png"> Deforming Object：令一个geo变成有形变的物体。也就是说这个物体能够影响其他带动力学的物体<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689052258133-5e2db26d-1ae8-4684-a625-28dcdd35c10b.png#averageHue=%233e3e3d&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=56&amp;id=ub0e13744&amp;originHeight=56&amp;originWidth=85&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2715&amp;status=done&amp;style=none&amp;taskId=uc004a5dd-a9bb-457b-ba96-f3adde51c4c&amp;title=&amp;width=85" alt="image.png">GroundPlane：添加地面碰撞。</p><p><a name="KELLH"></a></p><h2 id="Particles粒子"><a href="#Particles粒子" class="headerlink" title="Particles粒子"></a>Particles粒子</h2><p>粒子工具用于创建和模拟粒子效果。通过设置粒子的属性和行为，您可以模拟烟雾、火焰、爆炸等效果。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047879218-6a53f94a-13bb-4121-97ce-bea6c0c9eb0d.png#averageHue=%23424141&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=53&amp;id=uc4df9c78&amp;originHeight=53&amp;originWidth=656&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18063&amp;status=done&amp;style=none&amp;taskId=u05216ddd-3f25-440c-9845-1b063ddef41&amp;title=&amp;width=656" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047886198-ab8edb21-ce80-4608-92d5-8c342e76efa2.png#averageHue=%23454342&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=44&amp;id=ucec7dff4&amp;originHeight=44&amp;originWidth=682&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15797&amp;status=done&amp;style=none&amp;taskId=uf49cffd6-4ca3-4d71-9352-f33d839bc62&amp;title=&amp;width=682" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689056776565-2f42881e-6873-4f57-bdc3-51dcbc55cb46.png#averageHue=%233e3e3e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=77&amp;id=u531f0a6a&amp;originHeight=77&amp;originWidth=75&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3291&amp;status=done&amp;style=none&amp;taskId=u626295c8-e989-4538-bd60-92c31884c77&amp;title=&amp;width=75" alt="image.png"><br>SourceParticleEmitter：将所选择的物体变成粒子发射器。</p><p><a name="SGYfR"></a></p><h2 id="Grains颗粒"><a href="#Grains颗粒" class="headerlink" title="Grains颗粒"></a>Grains颗粒</h2><p>颗粒工具是一种更高级的粒子系统，用于模拟具有更多物理特性的颗粒，消耗资源更高，相比粒子，它会模拟颗粒与颗粒之间的物理效果，例如沙子、泥浆。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047527124-8ac8ff40-9f0e-41fe-bfa9-389c25357dd9.png#averageHue=%2342413e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=48&amp;id=u2242df1b&amp;originHeight=48&amp;originWidth=784&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20197&amp;status=done&amp;style=none&amp;taskId=ua2bb4ad8-7f94-40cd-a9f2-935a294853e&amp;title=&amp;width=784" alt="image.png"><br><a name="eXxuU"></a></p><h2 id="Vellum布料"><a href="#Vellum布料" class="headerlink" title="Vellum布料"></a>Vellum布料</h2><p>Vellum是一个用于模拟布料、软体和其他变形物体的工具集。它可以模拟布料的折叠、撕裂和变形，以及其他物体的动态行为。毛发，沙子，黏体也可以通过vellum来做<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047548326-79f19b27-8f6c-4a8d-a44e-de1592204d0f.png#averageHue=%23404040&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=46&amp;id=uca4a8baf&amp;originHeight=46&amp;originWidth=493&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12531&amp;status=done&amp;style=none&amp;taskId=u22872689-85f1-4e54-819c-12351164f5a&amp;title=&amp;width=493" alt="image.png"><br><a name="UQd1X"></a></p><h2 id="Rigid-Bodies刚体"><a href="#Rigid-Bodies刚体" class="headerlink" title="Rigid Bodies刚体"></a>Rigid Bodies刚体</h2><p>刚体工具用于模拟刚体物体的物理行为，如碰撞、重力和动力学。您可以创建刚体对象，并模拟它们在场景中的运动和互动。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047900689-a56852dd-b649-439c-9f85-e4afbfdcab37.png#averageHue=%23434240&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=55&amp;id=u49a12f79&amp;originHeight=55&amp;originWidth=643&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19656&amp;status=done&amp;style=none&amp;taskId=u3d641c3c-d4f9-436d-8334-e5decfb609c&amp;title=&amp;width=643" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047907390-25ac370c-e527-457d-a737-367c9d80abf8.png#averageHue=%2340403f&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=55&amp;id=uabd33aa0&amp;originHeight=55&amp;originWidth=711&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15676&amp;status=done&amp;style=none&amp;taskId=u0df05b36-0ed9-4a2d-ada3-27d5369ef8c&amp;title=&amp;width=711" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689058013341-4b023cc6-573c-45d9-9d05-2a170be35594.png#averageHue=%23424242&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=51&amp;id=ud84e1db5&amp;originHeight=51&amp;originWidth=71&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2647&amp;status=done&amp;style=none&amp;taskId=ufda6611e-daf6-4432-8ad0-a1a4936934d&amp;title=&amp;width=71" alt="image.png"> MakeBreakable：为选择的刚体物体添加破碎<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689052205976-c8008265-ef72-4d82-9b4f-d23f97f9f434.png#averageHue=%233f3e3e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=64&amp;id=u820c4b47&amp;originHeight=64&amp;originWidth=81&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3329&amp;status=done&amp;style=none&amp;taskId=u29c883f0-7f30-4deb-837b-1945db3798d&amp;title=&amp;width=81" alt="image.png">RBD Instanced Objects： 先选择一个物体A，然后点击此工具，然后选择物体B再按回车，按完回车以后物体A的所有顶点都会被替换成物体B。</p><p><a name="wzsal"></a></p><h2 id="Particle-Fluids-粒子流体"><a href="#Particle-Fluids-粒子流体" class="headerlink" title="Particle Fluids 粒子流体"></a>Particle Fluids 粒子流体</h2><p>这个工具用于模拟流体的行为，通过将粒子和网格结合起来，可以生成逼真的流体效果，如水、烟雾或液体金属。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048115292-48d50b41-7189-4ea2-b4b4-77685b619667.png#averageHue=%23404040&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=60&amp;id=u78a5b5db&amp;originHeight=60&amp;originWidth=453&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14643&amp;status=done&amp;style=none&amp;taskId=ud49459b3-ebf0-47f2-9596-dd1c16b0365&amp;title=&amp;width=453" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048120527-2815f1ae-2b0d-4a25-b634-349a5fd27022.png#averageHue=%23403f3f&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=49&amp;id=u5ccf93af&amp;originHeight=49&amp;originWidth=451&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13357&amp;status=done&amp;style=none&amp;taskId=uacff56cd-92c0-4bce-b729-b5d148935af&amp;title=&amp;width=451" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689054951139-88cfcde0-da30-4684-948e-f28bcdd07aa6.png#averageHue=%233e3e3e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=60&amp;id=u6216d798&amp;originHeight=60&amp;originWidth=71&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2906&amp;status=done&amp;style=none&amp;taskId=u75ef010d-6031-4416-a987-f76b45fe2d3&amp;title=&amp;width=71" alt="image.png">FLIPTank 创建一个水缸<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689054977847-95c939ec-3808-4632-9bb5-d1618366c095.png#averageHue=%238f9bb2&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=208&amp;id=ubdc2bc78&amp;originHeight=550&amp;originWidth=627&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=385350&amp;status=done&amp;style=none&amp;taskId=u0759904d-00cd-47de-9f49-17edeb8622a&amp;title=&amp;width=237" alt="image.png"></p><p><a name="V9o6z"></a></p><h2 id="Viscous-Fluids粘性流体"><a href="#Viscous-Fluids粘性流体" class="headerlink" title="Viscous Fluids粘性流体"></a>Viscous Fluids粘性流体</h2><p>粘性流体工具是Particle Fluids的扩展，可以模拟具有更高黏度或粘性特性的流体，如糖浆或蜂蜜。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047573158-250e80d2-ac5b-4b9a-92aa-bf7322c58b23.png#averageHue=%23444241&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=52&amp;id=u7026d1aa&amp;originHeight=52&amp;originWidth=631&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19936&amp;status=done&amp;style=none&amp;taskId=ub322d555-b92c-48b2-be6d-e6b9edef758&amp;title=&amp;width=631" alt="image.png"><br><a name="YqqHB"></a></p><h2 id="Oceans海洋"><a href="#Oceans海洋" class="headerlink" title="Oceans海洋"></a>Oceans海洋</h2><p>这个工具集用于创建逼真的海洋和水面效果。它可以模拟海浪、波纹、海浪翻滚等效果，并生成逼真的水体表面。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047580614-e0973059-2703-4ed6-be3a-4d0ac18d67e7.png#averageHue=%233d3d3d&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=51&amp;id=u1466064c&amp;originHeight=51&amp;originWidth=490&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11344&amp;status=done&amp;style=none&amp;taskId=u481c3039-a4e5-4948-8708-e367941d442&amp;title=&amp;width=490" alt="image.png"><br><a name="GqVX1"></a></p><h2 id="PyroFX火焰和烟雾"><a href="#PyroFX火焰和烟雾" class="headerlink" title="PyroFX火焰和烟雾"></a>PyroFX火焰和烟雾</h2><p>PyroFX工具集用于创建逼真的火焰和烟雾效果。它可以模拟火焰的燃烧、烟雾的扩散和交互，并生成逼真的火焰和烟雾效果。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047589685-ca21bea0-df05-438a-9434-1b23c575f908.png#averageHue=%2344413e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=49&amp;id=u391cedc9&amp;originHeight=49&amp;originWidth=445&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10949&amp;status=done&amp;style=none&amp;taskId=u51b3f215-0c9e-4bcb-b052-16e3a97cd0e&amp;title=&amp;width=445" alt="image.png"></p><p><a name="XNVAr"></a></p><h2 id="FEM"><a href="#FEM" class="headerlink" title="FEM"></a>FEM</h2><p>FEM工具集用于模拟弹性和变形物体的行为。它可以模拟弹性体、变形物体的扭曲、弯曲和拉伸，并生成逼真的变形效果。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047965248-d4c249b6-97aa-44cb-bc35-9c0a86b6e14b.png#averageHue=%233e3e3e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=59&amp;id=u049ecf7a&amp;originHeight=59&amp;originWidth=450&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13132&amp;status=done&amp;style=none&amp;taskId=u8db51c22-25f1-4761-b782-c55d081b3ba&amp;title=&amp;width=450" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047972860-f7619f70-6592-4103-9b93-395209c486ed.png#averageHue=%2341403f&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=53&amp;id=uc4939793&amp;originHeight=53&amp;originWidth=502&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13498&amp;status=done&amp;style=none&amp;taskId=ue01236f1-0b24-4333-b1bc-d36df87b5e5&amp;title=&amp;width=502" alt="image.png"><br><a name="osjid"></a></p><h2 id="Wires线条"><a href="#Wires线条" class="headerlink" title="Wires线条"></a>Wires线条</h2><p>线条工具用于模拟线条和柔性物体的行为。它可以创建和模拟绳索、电线、海藻等柔性物体，并模拟它们的动态行为。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047988436-78a55797-e6b4-44a2-adb6-75d2ad514df7.png#averageHue=%233f3f3e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=51&amp;id=u1dbd512f&amp;originHeight=51&amp;originWidth=475&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11450&amp;status=done&amp;style=none&amp;taskId=u01e11f09-8f8c-48e9-8fe4-42792a41ca6&amp;title=&amp;width=475" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689047998940-88a62b7b-56d1-480e-b15e-608dd37619b2.png#averageHue=%23414040&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=56&amp;id=ue6f618c9&amp;originHeight=56&amp;originWidth=537&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13260&amp;status=done&amp;style=none&amp;taskId=ua1b4d17a-8780-4ff9-b7e3-837bd5c2218&amp;title=&amp;width=537" alt="image.png"><br><a name="zhyXl"></a></p><h2 id="Crowds群集"><a href="#Crowds群集" class="headerlink" title="Crowds群集"></a>Crowds群集</h2><p>Crowds工具集用于创建和模拟大规模的人群效果。它可以模拟人群的移动、交互和行为，并生成逼真的人群场景。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048015892-e454dfcb-9340-4226-9481-d6a620a85af9.png#averageHue=%23434140&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=51&amp;id=u2285fc29&amp;originHeight=51&amp;originWidth=527&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=17578&amp;status=done&amp;style=none&amp;taskId=u694c271d-9527-4b43-b7e6-ecd752294d1&amp;title=&amp;width=527" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048022519-69084fc3-3785-453b-ade1-897a2828523b.png#averageHue=%23433f3f&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=52&amp;id=u7a29d580&amp;originHeight=52&amp;originWidth=574&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10183&amp;status=done&amp;style=none&amp;taskId=u4268e0eb-d80c-41e5-866b-2ad7471b965&amp;title=&amp;width=574" alt="image.png"><br><a name="W5wjh"></a></p><h2 id="Drive-Simulation驱动模拟"><a href="#Drive-Simulation驱动模拟" class="headerlink" title="Drive Simulation驱动模拟"></a>Drive Simulation驱动模拟</h2><p>驱动模拟工具用于模拟和驱动复杂的物体和效果。它可以通过外部力、约束和动画数据来驱动模拟，并生成复杂的动态效果。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048031676-7f9e6a43-d247-4874-924b-0e015b903151.png#averageHue=%23403f3e&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=59&amp;id=u864e92fb&amp;originHeight=59&amp;originWidth=405&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12549&amp;status=done&amp;style=none&amp;taskId=u2c909bad-3402-43dd-a203-36086cd37cf&amp;title=&amp;width=405" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689048039399-57213f07-079f-4b8f-80a4-52b623fc7eab.png#averageHue=%23414040&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=54&amp;id=u8f8adacd&amp;originHeight=54&amp;originWidth=428&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=13692&amp;status=done&amp;style=none&amp;taskId=u255d73b6-ecfe-470b-86b1-b3e6a240239&amp;title=&amp;width=428" alt="image.png"><br><a name="CC9g8"></a></p><h1 id="快捷键与操作"><a href="#快捷键与操作" class="headerlink" title="快捷键与操作"></a>快捷键与操作</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1688983296559-86b10eca-f3dc-434b-9ae9-f2c8528dae7b.png#averageHue=%23fcfaf8&amp;clientId=u5c4fd87d-e6a3-4&amp;from=paste&amp;height=1161&amp;id=aOdsm&amp;originHeight=1161&amp;originWidth=931&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=288455&amp;status=done&amp;style=none&amp;taskId=u0b9afa62-31e9-410e-8065-6ca7f954adf&amp;title=&amp;width=931" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689058423850-c4fa95bc-f76f-47e2-a612-c4453c3f05af.png#averageHue=%2333211d&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=753&amp;id=ua3c4fffe&amp;originHeight=753&amp;originWidth=1052&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=721267&amp;status=done&amp;style=none&amp;taskId=u9426299a-ebed-464a-ba87-58254183db6&amp;title=&amp;width=1052" alt="image.png"><br><a name="N2PXA"></a></p><h2 id="视图操作快捷键"><a href="#视图操作快捷键" class="headerlink" title="视图操作快捷键"></a>视图操作快捷键</h2><p><a name="eKfwY"></a></p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>空格+f键： 居中显示<br>w键：切换为网格显示<br>e键： 缩放<br>r键：旋转<br>t键： 位移<br>视图模式中按1，2，3，4，5切换透视图，顶视图，前视图，右视图，UV视图<br>9键： 显示geometry对应的group和连接的geometry。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689214808487-bd7725ac-d0c1-44c8-b943-ed61e40b700e.png#averageHue=%23949a8f&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=430&amp;id=ufc07a38b&amp;originHeight=430&amp;originWidth=502&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155040&amp;status=done&amp;style=none&amp;taskId=u4675deb6-5883-4286-81e1-f8f44bfb61c&amp;title=&amp;width=502" alt="image.png"><br>空格键：切换view视窗模式和select选择编辑模式，如果切换不了就按s键也能进入选择编辑模式<br>ctrl+b：视图最大化，需要在对应视图处按<br>d键：设置选择视图的显示项<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663667735662-95f8016d-6a7f-49eb-81e5-561bb03c7bd3.png#averageHue=%23484848&amp;clientId=u5015aa74-1ea4-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=495&amp;id=u321afc6d&amp;originHeight=495&amp;originWidth=743&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=70072&amp;status=error&amp;style=none&amp;taskId=ud20e9657-e103-4788-8610-8babf97f7ab&amp;title=&amp;width=743" alt="image.png"><br>shift+G键：扩大选择的点边面区域<br>shift+s键：缩小选择的点边面区域<br>快速选择循环点边面：选中一个点边面以后，按a键配合鼠标中键快速选择循环点边面<br><a name="VQNlt"></a></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>将某一窗口最小化：例如想要将属性编辑器缩小就点击图中图标<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663661983206-f83421db-62fa-4c61-bb93-bcae82435e97.png#averageHue=%23333333&amp;clientId=u5c2a535c-7f3e-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=893&amp;id=WBF8B&amp;originHeight=893&amp;originWidth=1137&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84774&amp;status=error&amp;style=none&amp;taskId=u5a2d8777-7221-4a81-8393-3890a88d57e&amp;title=&amp;width=1137" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663662030215-d4cfdbae-58fc-4872-8868-e59cd11a9cac.png#averageHue=%23323232&amp;clientId=u5c2a535c-7f3e-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=683&amp;id=IQhqE&amp;originHeight=683&amp;originWidth=1097&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=53207&amp;status=error&amp;style=none&amp;taskId=u833d11db-d3fd-498f-a40f-3e477fe9c15&amp;title=&amp;width=1097" alt="image.png"></p><p><a name="npGdV"></a></p><h2 id="网络编辑器快捷键"><a href="#网络编辑器快捷键" class="headerlink" title="网络编辑器快捷键"></a>网络编辑器快捷键</h2><p>g键：快速定位到选择的节点<br>h键：定位显示所有的节点<br>l键：一键快速排列<br>令节点对齐：选中要对齐的节点然后按shift+a+鼠标左键按住拖动（上下拖动为竖着对齐，左右拖动为横着对齐）<br>R键：显示与隐藏节点<br>复制节点：ctrl+cv或者alt+鼠标拖动<br>y键：按着不松开启剪刀模式剪断节点之间的连接<br>shift+o：添加注释<br>shift+w：显示大纲<br>shift+c： 打包节点<br>p键：在网络编辑器中快捷显示隐藏属性编辑器<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663662078906-6cb9d917-ced2-4e3c-a957-f6afa888e3f8.png#averageHue=%23333333&amp;clientId=u5c2a535c-7f3e-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=639&amp;id=sLnZ3&amp;originHeight=639&amp;originWidth=1113&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66573&amp;status=error&amp;style=none&amp;taskId=u137ff9e5-3237-4839-93ca-afaabaea354&amp;title=&amp;width=1113" alt="image.png"><br><a name="zZup5"></a></p><h2 id="网格编辑器的一些操作"><a href="#网格编辑器的一些操作" class="headerlink" title="网格编辑器的一些操作"></a>网格编辑器的一些操作</h2><p><a name="NMZGD"></a></p><h3 id="创建一个节点的引用"><a href="#创建一个节点的引用" class="headerlink" title="创建一个节点的引用"></a>创建一个节点的引用</h3><p>使用此功能后会创建一个新的相同节点，新的节点的属性会完全同步旧节点的属性调整。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689134672795-56affba5-9d44-4094-a9ea-27eb14851f29.png#averageHue=%23454039&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=246&amp;id=uadd4f3e0&amp;originHeight=246&amp;originWidth=565&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28677&amp;status=done&amp;style=none&amp;taskId=ua5b0734b-1b72-4b64-8af8-1bc7daa112c&amp;title=&amp;width=565" alt="image.png"><br><a name="UkPEY"></a></p><h3 id="创建参数的引用"><a href="#创建参数的引用" class="headerlink" title="创建参数的引用"></a>创建参数的引用</h3><p>先复制要引用的参数<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689134794385-f2679a48-a5f2-4cda-a74a-cc14ed992018.png#averageHue=%23494137&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=209&amp;id=u414db8b4&amp;originHeight=209&amp;originWidth=372&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=16844&amp;status=done&amp;style=none&amp;taskId=u41d8c11b-1d59-460c-872c-1b7b8a08afb&amp;title=&amp;width=372" alt="image.png"><br>然后在另一个参数中右键使用粘贴，有两种方式，一个是相对路径一个是绝对路径。<br>使用此功能后将会建立双方参数的同步。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689134832342-bd421a14-cbfc-4d02-a4ff-8f16f956d240.png#averageHue=%23403c38&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=340&amp;id=ue4b26d5f&amp;originHeight=340&amp;originWidth=578&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36646&amp;status=done&amp;style=none&amp;taskId=u7d247a7e-69be-4a10-a7f7-3c5db7e2b0e&amp;title=&amp;width=578" alt="image.png"><br><a name="P8gdF"></a></p><h2 id="将VOP中的输入变量变成参数使其可以直接在VOP节点上自定义参数值"><a href="#将VOP中的输入变量变成参数使其可以直接在VOP节点上自定义参数值" class="headerlink" title="将VOP中的输入变量变成参数使其可以直接在VOP节点上自定义参数值"></a>将VOP中的输入变量变成参数使其可以直接在VOP节点上自定义参数值</h2><p>在变量处按鼠标中间然后选择Promote Parameter即可创建出来可以用户自定义的参数、<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689241831109-ecc4032c-2541-41c5-83be-43d3021c1970.png#averageHue=%2344413e&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=340&amp;id=u705d7c37&amp;originHeight=340&amp;originWidth=434&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28065&amp;status=done&amp;style=none&amp;taskId=udb37a3a6-fd55-405c-aa87-ce3dd65df39&amp;title=&amp;width=434" alt="image.png"><br>然后点击变量输入引脚的四边形即可调整参数的类型和名字。<br>添加完参数以后，即可在VOP节点外部调整参数的值。</p><p><a name="NaAeq"></a></p><h2 id="动画相关快捷键"><a href="#动画相关快捷键" class="headerlink" title="动画相关快捷键"></a>动画相关快捷键</h2><p>alt+鼠标左键点击属性进行k帧，设置关键帧<br>shift+鼠标左键点击属性：进入属性的动画曲线编辑器<br>⬆上箭头键：正序播放动画<br>⬇下箭头键：倒序播放动画</p><p><a name="smR4p"></a></p><h1 id="不同网络对应的常用节点"><a href="#不同网络对应的常用节点" class="headerlink" title="不同网络对应的常用节点"></a>不同网络对应的常用节点</h1><p><a name="nFePv"></a></p><h2 id="GEO-SOP-建模，程序化建模，K帧，展UV"><a href="#GEO-SOP-建模，程序化建模，K帧，展UV" class="headerlink" title="GEO(SOP)(建模，程序化建模，K帧，展UV)"></a>GEO(SOP)(建模，程序化建模，K帧，展UV)</h2><p><a name="neX0x"></a></p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>null：空节点，主要作用是标记和分类<br>merge：合并<br>transform ： 变换  <br>soft transform ： 带软选择的变换<br>blast：爆破（有删除的作用）<br>fuse: 焊接相邻的点<br>facet：把面与面进行拆分，将有多条边共用的点分离成多个点，需要勾选uniquePoints<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663746774746-d603a37a-6368-4c36-92c0-608661cf6429.png#averageHue=%23424242&amp;clientId=u2b212657-78c4-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=34&amp;id=uec3a6324&amp;originHeight=34&amp;originWidth=163&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1655&amp;status=error&amp;style=none&amp;taskId=uda015188-9f3c-43f8-aab0-4aa5144600c&amp;title=&amp;width=163" alt="image.png"><br>ends:可以使用这个节点将模型线框显示，需要将close U属性改为Open<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663747682517-bbb52790-06e0-4996-85b9-50ff04f52c21.png#averageHue=%233f3f3f&amp;clientId=u2b212657-78c4-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=38&amp;id=udf822390&amp;originHeight=38&amp;originWidth=265&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=2361&amp;status=error&amp;style=none&amp;taskId=u15880ef4-1bde-4587-98cd-9ae674a2600&amp;title=&amp;width=265" alt="image.png"><br>add:可以将模型删除但只保留点，需要勾选<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663747791647-b52ddd33-f444-4ed9-9e0e-245380cebce8.png#averageHue=%23404040&amp;clientId=u2b212657-78c4-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=34&amp;id=ub2763d35&amp;originHeight=34&amp;originWidth=312&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3488&amp;status=error&amp;style=none&amp;taskId=ua327da12-2dac-445b-a8bc-a2d3cbd6cd4&amp;title=&amp;width=312" alt="image.png">。<br>add也可以将点连成线：需要在Polygons一栏中选择By Group<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689242224496-6c9efebe-9c6a-462a-a887-f4f6737e4224.png#averageHue=%23373737&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=187&amp;id=u4989e598&amp;originHeight=187&amp;originWidth=383&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25596&amp;status=done&amp;style=none&amp;taskId=uec77778d-9bc2-4f38-89a4-a8381028fef&amp;title=&amp;width=383" alt="image.png"><br>scatter：模型变点(可以自己设置点的数量)<br>polywire：将线框向外扩展变成网格<br>polyextrude: 挤出<br>polysplit：多切割，以及插入循环边，如果不能交互的话就在视图窗口中按enter键，通过改变path type切换点击切割的模式还是循环边的模式<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689131620240-afc23153-3ed1-4e5e-888e-01b01262dae4.png#averageHue=%235b4e3d&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=77&amp;id=u4cc0e5ef&amp;originHeight=77&amp;originWidth=248&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7540&amp;status=done&amp;style=none&amp;taskId=u4813f39e-24d7-4d80-965c-e25c1969550&amp;title=&amp;width=248" alt="image.png"><br>split：分离<br>polybevel：倒角<br>polyfill(polycap)：填充<br>poly frame：输出normal和tangent属性并且可以更改其normal属性和tangent属性的名字，例如可以在tangent属性的名字写成N，这样就相当于使用其tangent属性作为N属性来使用。<br>copy to points ：将模型复制到点上<br>sort：可以用来反转点序号<br>match size: 匹配大小，例如通过一个box为标准来使其他物体大小跟box大小匹配（需要更改一些节点的参数）<br>reverse: 反转，通常用来处理法线<br>attribute create：创建自定义属性<br>attribute randimize ： 添加或设置属性值的随机<br>mountain：翻译为山，往山的形象进行变形，作用是为模型添加变形<br>subdivide: 细分<br>color：添加颜色<br>group：组，可以将顶点或者边等进行打组，在选择节点的情况下可以按~键然后就可以手动选择需要打组的元素，然后再按回车键进行打组。<br>也可以通过另一个geometry来进行范围的选择：<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689155853946-26709063-411d-45ac-88ea-293871a71db7.png#averageHue=%23464442&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=475&amp;id=u42bbf13c&amp;originHeight=475&amp;originWidth=510&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=39742&amp;status=done&amp;style=none&amp;taskId=u288538d7-d7a1-422d-a7f2-a267a3f8890&amp;title=&amp;width=510" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689155865380-583e139f-f199-4955-9ae7-e681b4e37159.png#averageHue=%23424241&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=475&amp;id=u2ada29a0&amp;originHeight=475&amp;originWidth=689&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=45432&amp;status=done&amp;style=none&amp;taskId=udaebe27d-5670-48a1-84f4-b2cc6fd846f&amp;title=&amp;width=689" alt="image.png"><br>L-System：提供了很多预设，可以快速做出一些形状，比如树，树丛，闪电等<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689218131712-b454f98d-3a06-484b-9eb6-85ebfccacb89.png#averageHue=%23393735&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=151&amp;id=u11757cd0&amp;originHeight=151&amp;originWidth=298&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=9939&amp;status=done&amp;style=none&amp;taskId=ub77eb91c-5ad5-41bd-a86d-a18d7794499&amp;title=&amp;width=298" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689218112636-63429f71-6df6-4db8-aa7a-1b470da11743.png#averageHue=%233d3b3b&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=868&amp;id=uc1eb3cc8&amp;originHeight=1168&amp;originWidth=444&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=89665&amp;status=done&amp;style=none&amp;taskId=u7efbaf37-b269-4e3c-8b85-9bba80fc419&amp;title=&amp;width=330" alt="image.png"><br>pack：打包，打包后组成元素变成1<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689218298841-e4185e88-2b99-423d-b678-3e19036b6fa7.png#averageHue=%232a2c37&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=120&amp;id=uc5e7bba8&amp;originHeight=120&amp;originWidth=155&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5759&amp;status=done&amp;style=none&amp;taskId=u34710503-d460-4cbf-b5ce-859b69771da&amp;title=&amp;width=155" alt="image.png"><br>resample：重新采样，可以改变曲线的组成，例如让曲线的点更多。<br>object merge：将obj层级下的其他geometry带到另一个geometry层级下<br>switch：可以控制两个节点之间切换显示<br>magnet：磁力配合metaball来制作geometry与metaball相互作用的磁力效果<br>skin: skin节点可以将线变成面<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689239491649-651323c6-7a8f-4f31-b81c-221a54b3918e.png#averageHue=%23a1a8ac&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=166&amp;id=u7dd50d25&amp;originHeight=166&amp;originWidth=212&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29012&amp;status=done&amp;style=none&amp;taskId=u458d6b47-4f57-456a-a784-5c3f56c26dc&amp;title=&amp;width=212" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689239493799-e6627735-8f73-4dc7-b077-e7d510915bcf.png#averageHue=%23acadac&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=165&amp;id=u20bee3ed&amp;originHeight=165&amp;originWidth=208&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27426&amp;status=done&amp;style=none&amp;taskId=ub8e8a114-a42a-4bea-8776-d6d6fc53adc&amp;title=&amp;width=208" alt="image.png"><br>group promote：切换组的类型<br>convert： 转换类型<br>connectivity： 新增一个属性（默认是class），将merge到一起的geometry按照顺序给0~（geometry个数-1）的值，例如这里将两个box合并后给connectivity后，第一个box的点（或面）的class属性为0，第二个box的点（或面）的class属性为1<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1690191324087-f1663acc-835d-4cfd-bee1-7331d11ea0f4.png#averageHue=%23333333&amp;clientId=u48f6dd24-7c60-4&amp;from=paste&amp;height=364&amp;id=u12e3b5a1&amp;originHeight=364&amp;originWidth=143&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4167&amp;status=done&amp;style=none&amp;taskId=u0da282e0-418a-4b77-8cbf-53660a17875&amp;title=&amp;width=143" alt="image.png">。<br>collisionSource：通过输入后输出一个geo一个vdb</p><p><a name="uLtUS"></a></p><h3 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h3><p>UV Texture：对geometry进行UV的投射,19.5测试的是在投射的时候同时能够显示出来UV的贴图18.5则不会显示出来。<br>UV Quick Shade : 赋予UV检查的Shader方便观察。</p><p><a name="ajq2u"></a></p><h3 id="地形"><a href="#地形" class="headerlink" title="地形"></a>地形</h3><p>下面的这些前面的HeightField都可以打hf缩写来快速定位到类型<br>HeightField：初始地形，平面网格<br>HeightField Noise : 专门针对地形的Noise<br>HeightField Distort by Noise： 对Noise进行扭曲<br>HeightField Transform：专门针对地形的移动节点<br>HeightField Erode： 模拟侵蚀（属于解算，通过移动关键帧可以看出来）<br>HeightField Flow Field：添加水流的影响<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689230248827-58b607a1-afe9-4ebe-9d91-4a0e8d48ed5a.png#averageHue=%237c5718&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=128&amp;id=u69df612c&amp;originHeight=276&amp;originWidth=572&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=154131&amp;status=done&amp;style=none&amp;taskId=u447c83a8-4a2a-4b38-a4cd-4460a467d8c&amp;title=&amp;width=265" alt="image.png">（红色）<br>HeightField Visualize：使为地形添加的不同细节更加形象话的表示出来（通过自定义的颜色）<br>Convert HeightField ：将地形转换成网格体<br>Time Shift：如果前面有模拟，那么可以通过这个节点停掉解算过程而得到需要的某一帧的效果。<br><a name="u2Xfb"></a></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>time shift：记录输入的对象的动画，然后让这个动画的帧数由timeshift节点的属性来操控。可以通过给timeshift的属性进行K帧达到给动画的某一阶段的动画进行倍速的效果。</p><p><a name="oMeyk"></a></p><h3 id="制作粒子可能用得到的"><a href="#制作粒子可能用得到的" class="headerlink" title="制作粒子可能用得到的"></a>制作粒子可能用得到的</h3><p>trail:记录输入的点的前一帧（或前几帧，可以自定义），然后会把这些记录显示在窗口上。也可以通过它来得到对象的速度属性，不过需要修改类型。<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1690535301265-4c0c9a92-5461-483d-859e-fb857e0d0776.png#averageHue=%23383736&amp;clientId=u182835ed-113b-4&amp;from=paste&amp;height=210&amp;id=u323329f3&amp;originHeight=210&amp;originWidth=716&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18116&amp;status=done&amp;style=none&amp;taskId=uaebcb37e-d114-40dd-98aa-72fc46cbaa8&amp;title=&amp;width=716" alt="image.png"><br>pointReplicate: 基于输入的sop的点，来为sop的点周围来生成点云。并且可以继承点的速度（在attribute里面），能够控制点云的形状数量的noise</p><p><a name="WMusM"></a></p><h2 id="VOP（VEX-Builder）"><a href="#VOP（VEX-Builder）" class="headerlink" title="VOP（VEX Builder）"></a>VOP（VEX Builder）</h2><p><a name="TiVHj"></a></p><h3 id="VOP变量颜色对应类型介绍"><a href="#VOP变量颜色对应类型介绍" class="headerlink" title="VOP变量颜色对应类型介绍"></a>VOP变量颜色对应类型介绍</h3><p>先介绍一下不同颜色对应的类型：<br>没有布尔类型，布尔类型用int类型的0和1来代替了<br>绿色：vector<br>青色：float<br>深青色：floata   浮点数数组<br>蓝色：int<br>棕黄色：string<br><a name="VnSyJ"></a></p><h3 id="VOP变量名字对应"><a href="#VOP变量名字对应" class="headerlink" title="VOP变量名字对应"></a>VOP变量名字对应</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689242456393-191f7ff8-e461-4c0c-b21e-baab2a044301.png#averageHue=%23464545&amp;clientId=u0b51113a-ff6a-4&amp;from=paste&amp;height=763&amp;id=uc5a4f31d&amp;originHeight=763&amp;originWidth=438&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32437&amp;status=done&amp;style=none&amp;taskId=ud999579b-86b9-4530-96b9-35ba3729bdc&amp;title=&amp;width=438" alt="image.png"><br>P对应顶点属性为vector类型<br>Cd对应颜色属性为vector类型<br>ptnum意思是point number 也就是点序号，int类型<br>numpt意思是number of point 也就是点的总数量，int类型<br><a name="wHGgV"></a></p><h3 id="VOP节点介绍"><a href="#VOP节点介绍" class="headerlink" title="VOP节点介绍"></a>VOP节点介绍</h3><p>VOP节点有很多种<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689151972832-5c5e48cc-2121-4cd3-a0b4-2d70e5194fe8.png#averageHue=%23444443&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=149&amp;id=u73d68979&amp;originHeight=149&amp;originWidth=175&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11172&amp;status=done&amp;style=none&amp;taskId=u3f8d51d3-532d-4437-a000-d8d986b1f59&amp;title=&amp;width=175" alt="image.png"><br>Point VOP 和 Primitive VOP 和 Vertex VOP都属于Attribute VOP,只是这三个默认的类型不同。<br><a name="LkkpL"></a></p><h4 id="Attribute-VOP"><a href="#Attribute-VOP" class="headerlink" title="Attribute VOP"></a>Attribute VOP</h4><p>attributeVOP，这个是一个可以处理各种属性的节点，在节点里面可以通过可视化编程网络设置属性。<br>bind：读取属性<br>bind export： 输出属性（创建一个新属性）（跟bind节点是一样的，只不过把bind里的默认参数修改了一下）<br>random：随机<br>fit range：将数值限制在一个范围内<br>round to integer：四舍五入<br>multply add constant：乘和添加常数，配合random调节随机值<br>switch： 通过接收的数来选择自身所具有的对应位置的数来进行输出<br>subtract： 减（要求有两个输入）<br>subtract Constant：减一个常数（只需要一个输入）<br>mix：混合，跟UE材质蓝图的lerp是一个道理<br><a name="Jvfsu"></a></p><h2 id="out（ROP）-渲染输出"><a href="#out（ROP）-渲染输出" class="headerlink" title="out（ROP）(渲染输出)"></a>out（ROP）(渲染输出)</h2><p>mantra：houdini自带的渲染器节点<img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689060197542-f982d1d5-d00b-47bc-9459-94ff50440ac6.png#averageHue=%23393837&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=825&amp;id=Meet3&amp;originHeight=825&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=89232&amp;status=done&amp;style=none&amp;taskId=uc94e0acf-2310-4867-978f-337e0bfae71&amp;title=&amp;width=480" alt="image.png"><br><a name="KG6F0"></a></p><h2 id="mat（材质网络）"><a href="#mat（材质网络）" class="headerlink" title="mat（材质网络）"></a>mat（材质网络）</h2><p>mat是为物体添加着色器和材质的网络<br>创建好shader以后可以将节点拖入到视图中的物体中可以快速地赋予材质<br>classicshader 经典shader<br><a name="zpg3i"></a></p><h2 id="dop（动力学解算）（烟火水粒子）"><a href="#dop（动力学解算）（烟火水粒子）" class="headerlink" title="dop（动力学解算）（烟火水粒子）"></a>dop（动力学解算）（烟火水粒子）</h2><p>gravity：引力，重力，9.8<br>staticObject:赋予SOP路径后生成被动碰撞体<br><a name="KVZ6A"></a></p><h3 id="粒子"><a href="#粒子" class="headerlink" title="粒子"></a>粒子</h3><p>popobject：配合popSolver使用，使其能够与DOP环境的其他对象正确交互<br>popSource：用于通过几何体生成粒子的节点<br>popCollisionDetect：用于粒子的碰撞并设置碰撞后的反应<br>popDrag：为粒子添加类似风阻的效果<br>popForce：为粒子添加新的作用力</p><p><a name="DSIEe"></a></p><h3 id="解算器节点"><a href="#解算器节点" class="headerlink" title="解算器节点"></a>解算器节点</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689064091029-2fcd79cc-edd2-4631-a26d-de96b91906dc.png#averageHue=%23f8f5f0&amp;clientId=u6ad503fa-7cfa-4&amp;from=paste&amp;height=436&amp;id=udefb0eaa&amp;originHeight=436&amp;originWidth=427&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=77449&amp;status=done&amp;style=none&amp;taskId=ufdf2f652-568d-4456-9b4e-de45ba10820&amp;title=&amp;width=427" alt="image.png"><br>rigid body solver：专门用于处理刚体物体的运动、碰撞和相互作用。<br>刚体是指在运动过程中形状和体积保持不变的物体，它们的运动受到物理力学规律的约束。<br>static solver：使其变成被动的碰撞体，但不受模拟的影响。例如，建筑物、地形、静态障碍物等都可以被视为静态物体。<br>flip solver：流体解算器，计算飞溅和波浪效应<br>Whitewater solver：在flip solve的基础上创建泡沫喷雾和气泡<br>vellum solver：属于POP solver类型，用于支持布料，头发，颗粒<br>POP Solver：用于粒子和颗粒，也可以用来模拟软体和布料。<br>Wire Solver： 用于解算毛发和皮毛或其他例如船的索具或树枝的索具等丝状物体。<br>Finite Element Solver：用于模拟四面体的材料和固体，用于模拟肌肉，软体，破碎的木头<br>Cloth Solver：对与变形物体作用的布料进行模拟<br>SOP Solver：用于SOP网络，随着时间的推移而改变物体的形状。例如墙壁被物体撞击而产生凹痕。<br><a name="pUZWY"></a></p><h1 id="文件管理规范和场景比例"><a href="#文件管理规范和场景比例" class="headerlink" title="文件管理规范和场景比例"></a>文件管理规范和场景比例</h1><p><a name="aoeGv"></a></p><h2 id="场景比例"><a href="#场景比例" class="headerlink" title="场景比例"></a>场景比例</h2><p>houdini的场景比例是一个单位是1m，其他dcc软件的单位一般是1cm。<br>修改场景比例的方法（houdini因为计算原因所以更推荐使用m为单位）：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689144934395-1f11c023-9f25-4bdd-b6a3-31bf3a7397b1.png#averageHue=%234c463d&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=255&amp;id=ub2f9f4c8&amp;originHeight=255&amp;originWidth=584&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=45467&amp;status=done&amp;style=none&amp;taskId=ufa9fb9df-2748-4bc0-b2ce-609e246613d&amp;title=&amp;width=584" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689144918467-548b3ab2-c1fc-4337-8275-b52c26471076.png#averageHue=%234f4e4e&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=328&amp;id=ud6088751&amp;originHeight=328&amp;originWidth=586&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33088&amp;status=done&amp;style=none&amp;taskId=u5e89cd63-cdbb-4d6a-bb8a-1905f5d6828&amp;title=&amp;width=586" alt="image.png"><br><a name="AXo7u"></a></p><h2 id="文件管理规范"><a href="#文件管理规范" class="headerlink" title="文件管理规范"></a>文件管理规范</h2><p><a name="j88ZV"></a></p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>内容<em>大版本</em>小版本.hip<br>v是version的意思<br>t是take的意思<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689146121770-780697f0-4a57-4566-acef-033793ebbbfc.png#averageHue=%23b2a75f&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=128&amp;id=u08afc83c&amp;originHeight=128&amp;originWidth=1227&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75118&amp;status=done&amp;style=none&amp;taskId=u9868cf07-4ea7-4e03-bef7-d92b14b5d45&amp;title=&amp;width=1227" alt="image.png"><br><a name="LUrJl"></a></p><h3 id="文件节点"><a href="#文件节点" class="headerlink" title="文件节点"></a>文件节点</h3><p>经常使用的文件节点有两个，一个是file 一个是filecache<br>一般file只使用它的读取功能<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689147333670-5e2fe2b1-4ef4-464a-9307-acb836da0ef6.png#averageHue=%23424039&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=201&amp;id=u784b0172&amp;originHeight=201&amp;originWidth=725&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22171&amp;status=done&amp;style=none&amp;taskId=uf1c083d2-1049-4d6a-ba7b-f3e9e767d87&amp;title=&amp;width=725" alt="image.png"><br>filecache：<br>这里的$HIPNAME和$OS和$HIP都是环境变量。 $HIPNAME是项目文件名称，$OS是filecache这个节点的名称，$HIP是项目文件的目录路径,$F是帧数<br>houdini项目文件名字的后缀就是hip<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689147406721-17ff8f42-fc18-42be-9e4e-1784e759a157.png#averageHue=%23383838&amp;clientId=u2b227c25-553c-4&amp;from=paste&amp;height=467&amp;id=u933bae38&amp;originHeight=467&amp;originWidth=748&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50525&amp;status=done&amp;style=none&amp;taskId=u8335ba63-08bc-4b65-ac07-6c4bfa33728&amp;title=&amp;width=748" alt="image.png"><br><a name="ZVfYy"></a></p><h1 id="扩展节点布局预设"><a href="#扩展节点布局预设" class="headerlink" title="扩展节点布局预设"></a>扩展节点布局预设</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689149877195-6a53a1a9-afc2-483c-85bd-85a1ca08991e.png#averageHue=%233a3835&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=252&amp;id=ub070e94d&amp;originHeight=252&amp;originWidth=1116&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=52566&amp;status=done&amp;style=none&amp;taskId=u420e674d-5c16-40c7-8dc0-072a628999b&amp;title=&amp;width=1116" alt="image.png"><br>在节点上使用编辑参数界面功能<br>左边是能够添加的参数列表，中间是属性界面中已经存在的参数列表，右边是改变参数的一些属性.<br>也可以通过鼠标左键拖动其他节点的属性参数至设置参数的这个列表使这个节点可以控制其他节点的属性参数。（比如可以将通过节点做好的模型进行打包，然后在打包节点里的模型节点的属性参数拖入到打包节点里，这样就可以在打包节点中调整模型的细节；也可以在打包节点中新增新的属性然后将打包节点的属性值复制到模型里的节点的属性上面）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689150395682-cdb2b59f-ae84-4f0b-96ad-a98f86a489f3.png#averageHue=%23403f3f&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=874&amp;id=ub5d1e80a&amp;originHeight=874&amp;originWidth=1234&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=236244&amp;status=done&amp;style=none&amp;taskId=u1d4cc4bf-cc4b-4eb1-8392-908cc531b24&amp;title=&amp;width=1234" alt="image.png"><br>调整好的节点界面可以保存预设，或者替换默认预设<br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689150710208-46863586-3560-4948-8fa0-ecd6cd326bde.png#averageHue=%233e3c39&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=430&amp;id=ue32dbeda&amp;originHeight=430&amp;originWidth=550&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41303&amp;status=done&amp;style=none&amp;taskId=u90186905-a9bf-416a-80b7-f85fe240939&amp;title=&amp;width=550" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689150731498-e65088a0-ca8b-4d78-900b-901ed64bc41e.png#averageHue=%23646260&amp;clientId=u4909db3d-a257-4&amp;from=paste&amp;height=159&amp;id=u698b4bb0&amp;originHeight=159&amp;originWidth=399&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14301&amp;status=done&amp;style=none&amp;taskId=u00d4fcc3-94d7-4ae5-9fe4-c007047650f&amp;title=&amp;width=399" alt="image.png"><br><a name="U09wQ"></a></p><h1 id="HScript"><a href="#HScript" class="headerlink" title="HScript"></a>HScript</h1><p><a name="BSsV6"></a></p><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="@和$的区别"></a>@和$的区别</h2><p>@是VEX的变量，$是HScript的变量<br>通常通过@来使用局部的变量(例如访问几何属性),$来使用全局的变量(例如访问houdini的帧数，文件路径)。<br><a name="hq9lB"></a></p><h2 id="全局变量举例"><a href="#全局变量举例" class="headerlink" title="全局变量举例"></a>全局变量举例</h2><p>houdini文档上提供的一些：<br><a href="https://www.sidefx.com/docs/houdini/network/expressions.html">https://www.sidefx.com/docs/houdini/network/expressions.html</a><br>文档上没有的：<br>$CEX,$CEY,$CEZ分别表示一个物体的中心的XYZ在坐标系下的对应的X或Y或Z的值<br><a name="T1NTL"></a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://www.sidefx.com/docs/houdini/expressions/index.html">https://www.sidefx.com/docs/houdini/expressions/index.html</a><br>常用的函数：<br>rand<br>stamp<br>fit<br>fit01<br><a name="RACTF"></a></p><h1 id="VEX"><a href="#VEX" class="headerlink" title="VEX"></a>VEX</h1><p>VOP节点是将VEX可视化了，如果想要直接写VEX可以使用Point Wrangle节点。<br><a name="tm2KR"></a></p><h2 id="浏览连接好的VOP的VEX代码"><a href="#浏览连接好的VOP的VEX代码" class="headerlink" title="浏览连接好的VOP的VEX代码"></a>浏览连接好的VOP的VEX代码</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1689563138289-fda09f3b-82ec-4911-b11b-7d3003ba3e33.png#averageHue=%234c453c&amp;clientId=u8c90dfb8-4e44-4&amp;from=paste&amp;height=215&amp;id=u1723ebdc&amp;originHeight=215&amp;originWidth=429&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25295&amp;status=done&amp;style=none&amp;taskId=u85523f0d-9b5e-435e-a0e6-c423413a8c7&amp;title=&amp;width=429" alt="image.png"><br><a name="lUlRk"></a></p><h1 id="VOP里的Noise的介绍"><a href="#VOP里的Noise的介绍" class="headerlink" title="VOP里的Noise的介绍"></a>VOP里的Noise的介绍</h1><p>首先需要知道的是Noise不是完全随机的计算，例如针对一系列点添加Noise时，Noise控制的每个点和上一个点的变化差别。<br><a name="HcNqw"></a></p><h2 id="不同NoiseType的区别"><a href="#不同NoiseType的区别" class="headerlink" title="不同NoiseType的区别"></a>不同NoiseType的区别</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1690390338743-74b1d669-ceeb-48d0-87ff-febbc1cc0be0.png#averageHue=%23b2a593&amp;clientId=uf63b0efc-1872-4&amp;from=paste&amp;height=763&amp;id=ud6666b83&amp;originHeight=1145&amp;originWidth=2693&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=1128504&amp;status=done&amp;style=none&amp;taskId=uc73e4ce0-be8b-40eb-923c-2da73b7a1ec&amp;title=&amp;width=1795.3333333333333" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1690390366436-88d73d1b-cf5b-4411-bca1-5bae50ac9f3f.png#averageHue=%23a5a3a1&amp;clientId=uf63b0efc-1872-4&amp;from=paste&amp;height=998&amp;id=u682f120f&amp;originHeight=1497&amp;originWidth=2871&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=1656225&amp;status=done&amp;style=none&amp;taskId=ub5d57e8b-9f10-4ffb-bbf8-e6800904627&amp;title=&amp;width=1914" alt="image.png"><br><a name="UF170"></a></p><h2 id="Noise的一些参数"><a href="#Noise的一些参数" class="headerlink" title="Noise的一些参数"></a>Noise的一些参数</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2623605/1690388461405-429b1aba-f4da-4e7a-a3a0-87ed4c3ccc88.png#averageHue=%23323232&amp;clientId=uf63b0efc-1872-4&amp;from=paste&amp;height=188&amp;id=u02961c8f&amp;originHeight=282&amp;originWidth=1153&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=24558&amp;status=done&amp;style=none&amp;taskId=u30f6f194-24ec-4c06-8c8e-80eb95be2ce&amp;title=&amp;width=768.6666666666666" alt="image.png"><br>frequency是频率，频率在0~1之间调整可以看到明显的区别，越高变化的次数越多<br>Amplitude意思是振幅，是指变化的幅度，正一和负一是完全相反的<br>roughness是粗糙度，0~1之间粗糙度越高变化的越明显<br>Attenuation是衰减系数， 官方解释是Flattens the noise to prevent extreme spikes by damping the values. Higher values create a smoother look.<br>Turbulence翻译是湍流，可以理解为控制Noise的Noise，也就是为Noise再添加Noise</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;a name=&quot;biomu&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Houdini的一些专业术语&quot;&gt;&lt;a href=&quot;#Houdini的一些专业术语&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="DCC软件" scheme="http://example.com/categories/DCC%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="houdini" scheme="http://example.com/tags/houdini/"/>
    
  </entry>
  
  <entry>
    <title>从零开始安装ComfyUI</title>
    <link href="http://example.com/2024/06/18/AI-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85ComfyUI/"/>
    <id>http://example.com/2024/06/18/AI-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85ComfyUI/</id>
    <published>2024-06-18T09:16:00.000Z</published>
    <updated>2024-07-27T18:58:06.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大概过程总结"><a href="#大概过程总结" class="headerlink" title="大概过程总结"></a>大概过程总结</h1><p>确保拥有git -&gt; 拉取comfyui的github仓库 -&gt; 使用conda配置comfyui的对应环境 -&gt; 使用.bat文件来方便运行启动comfyui </p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>git官方网站:<a href="https://www.git-scm.com/">https://www.git-scm.com/</a></p><h1 id="拉取comfyui的github仓库"><a href="#拉取comfyui的github仓库" class="headerlink" title="拉取comfyui的github仓库"></a>拉取comfyui的github仓库</h1><p><a href="https://github.com/comfyanonymous/ComfyUI">https://github.com/comfyanonymous/ComfyUI</a><br>在你要安装comfyui的盘中右键打开git bash<br><img src="/.com//image.png" alt="alt text"><br>在界面中输入:</p><pre><code class="lang-bash">git clone https://github.com/comfyanonymous/ComfyUI.git</code></pre><p>如果是第一次使用git,可能会有注册github账号,配置账号,下载速度慢的问题.这些问题都可以通过谷歌百度得到详细的问题解决过程,这里不再赘述.</p><h1 id="使用conda配置python环境"><a href="#使用conda配置python环境" class="headerlink" title="使用conda配置python环境"></a>使用conda配置python环境</h1><h2 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h2><p>通过使用conda可以方便地进行python环境的管理,常见的对应软件有,anaconda,miniconda,miniforge,这三个更推荐miniconda,如果公司不让用anaconda和miniconda的话可以使用miniforge代替.<br>请谷歌搜索自行下载与安装,下载和安装conda网上有很多.<br><strong>需要强调的是安装完conda以后需要手动配置环境变量,不然没办法使用conda命令</strong><br>在Path变量中新建添加类似于这两个的路径<br><img src="/.com//image-1.png" alt="alt text"><br><strong>添加完环境变量以后需要重新开一个终端</strong></p><h2 id="通过conda配置comfyui的python环境"><a href="#通过conda配置comfyui的python环境" class="headerlink" title="通过conda配置comfyui的python环境"></a>通过conda配置comfyui的python环境</h2><p>在comfyui的文件夹上输入cmd进入对应路径的终端<br><img src="/.com//image-2.png" alt="alt text"><br>根据终端中显示的提示依次输入命令回车.命令的作用是:创建comfyui的基础环境,激活这个环境</p><pre><code class="lang-bash">conda create -n comfyuiBase python=3.10conda activate comfyuiBase</code></pre><h2 id="在comfyuiBase环境中安装pytorch"><a href="#在comfyuiBase环境中安装pytorch" class="headerlink" title="在comfyuiBase环境中安装pytorch"></a>在comfyuiBase环境中安装pytorch</h2><p>在上一步中,已经通过conda创建了一个comfyuiBase的环境并且已经激活.<br>接下来为需要在comfyuiBase环境中安装pytorch.<br>如果你的电脑是n卡的话,可以在终端中输入命令查看自己的显卡支持的cuda版本.</p><pre><code class="lang-bash">nvidia-smi</code></pre><p><img src="/.com//image-4.png" alt="alt text"></p><p>接下来你需要去谷歌搜索cuda去进行cuda的安装</p><p>安装完cuda之后安装pytorch<br>进入pytorch的网站<br><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a><br>根据自己的所支持的cuda版本(你的cuda版本需要大于界面中选择的cuda版本),使用对应的命令进行安装.<br><img src="/.com//image-3.png" alt="alt text"><br>在comfyuiBase环境下安装完pytorch后,安装comfyui的依赖环境,并通过python main.py来打开comfyui进行环境测试</p><pre><code class="lang-bash">pip install -r requirements.txtpython main.py --auto-launch</code></pre><h2 id="基于配置好的comfyuiBase环境-创建属于自己的comfyui环境-可不做"><a href="#基于配置好的comfyuiBase环境-创建属于自己的comfyui环境-可不做" class="headerlink" title="基于配置好的comfyuiBase环境,创建属于自己的comfyui环境(可不做)"></a>基于配置好的comfyuiBase环境,创建属于自己的comfyui环境(可不做)</h2><p>经过前面的环境配置以后你就拥有了运行comfyui所需要的最基础的环境.<br>接下来你可以保留这个最基础的comfyui环境,创建一个自己平时使用的comfyui环境.<br>这样环境随便搞,后面搞坏了也有一个基础的可以用的环境.<br>在终端中输入命令,基于comfyuiBase环境创建一个新的环境,我这里命名为comfyui.</p><pre><code class="lang-bash">conda create comfyui --clone comfyuiBase</code></pre><h1 id="使用-bat文件来方便运行启动comfyui"><a href="#使用-bat文件来方便运行启动comfyui" class="headerlink" title="使用.bat文件来方便运行启动comfyui"></a>使用.bat文件来方便运行启动comfyui</h1><p>在comfyui文件夹中新建一个txt文件,然后输入类似于下面的内容<br>第二行activate comfyui是激活你的comfyui环境(因为我创建的环境名字是comfyui所以填comfyui)<br>第三行C:\ComfyUI对应你的comfyui的文件夹路径</p><pre><code class="lang-bash">@echo offcall activate comfyuicd C:\ComfyUIpython main.py --auto-launchpause</code></pre><p>填好以后保存txt文件,改后缀名为.bat,这样以后都可以通过这个.bat文件直接激活comfyui环境并启动comfyui了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大概过程总结&quot;&gt;&lt;a href=&quot;#大概过程总结&quot; class=&quot;headerlink&quot; title=&quot;大概过程总结&quot;&gt;&lt;/a&gt;大概过程总结&lt;/h1&gt;&lt;p&gt;确保拥有git -&amp;gt; 拉取comfyui的github仓库 -&amp;gt; 使用conda配置comfyu</summary>
      
    
    
    
    <category term="AI" scheme="http://example.com/categories/AI/"/>
    
    
    <category term="ComfyUI" scheme="http://example.com/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>Pymxs</title>
    <link href="http://example.com/2024/03/21/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Pymxs-Pymxs/"/>
    <id>http://example.com/2024/03/21/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Pymxs-Pymxs/</id>
    <published>2024-03-20T16:52:00.000Z</published>
    <updated>2024-07-27T18:58:06.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=MAXDEV_Python_executing_python_html">https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=MAXDEV_Python_executing_python_html</a></p><h1 id="如何使用3dsmax自带的图标"><a href="#如何使用3dsmax自带的图标" class="headerlink" title="如何使用3dsmax自带的图标"></a>如何使用3dsmax自带的图标</h1><p>参考Loading Multi-resolution Icons:<a href="https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=MAXDEV_Python_creating_python_uis_html">https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=MAXDEV_Python_creating_python_uis_html</a><br>3dsmax自带的图标指南:<a href="https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=Max_Developer_Help_icon_guide_icon_resource_guide_html">https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=Max_Developer_Help_icon_guide_icon_resource_guide_html</a><br>核心代码:</p><pre><code class="lang-python">from qtmax import LoadMaxMultiResIcontoolBtn1 = QToolButton()toolBtn1.setIcon(LoadMaxMultiResIcon(&quot;Common/Lock&quot;))</code></pre><h1 id="官方提供的pymxs与pyside2的实例代码"><a href="#官方提供的pymxs与pyside2的实例代码" class="headerlink" title="官方提供的pymxs与pyside2的实例代码"></a>官方提供的pymxs与pyside2的实例代码</h1><p>路径:C:\Program Files\Autodesk\3ds Max 2024\scripts\PythonSamples\Python3\</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=</summary>
      
    
    
    
    <category term="DCC工具开发" scheme="http://example.com/categories/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Pymxs" scheme="http://example.com/tags/Pymxs/"/>
    
  </entry>
  
  <entry>
    <title>FastAPI</title>
    <link href="http://example.com/2024/03/15/Geek-FastAPI-FastAPI/"/>
    <id>http://example.com/2024/03/15/Geek-FastAPI-FastAPI/</id>
    <published>2024-03-15T02:51:00.000Z</published>
    <updated>2024-07-27T18:58:06.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>官方文档:<a href="https://fastapi.tiangolo.com/python-types/">https://fastapi.tiangolo.com/python-types/</a></p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>文件夹里创建一个main.py文件<br>运行实时服务器(代码更新时服务器也会自动更新):<br>uvicorn main:app —reload<br>有可能会报错,报错的话一般就是8000端口被占用了,需要处理一下</p><h2 id="代码内容"><a href="#代码内容" class="headerlink" title="代码内容"></a>代码内容</h2><pre><code class="lang-python">from fastapi import FastAPIapp = FastAPI()@app.get(&quot;/&quot;) # HTTP方法async def root():    return &#123;&quot;message&quot;: &quot;Hello World&quot;&#125;</code></pre><h2 id="api文档链接"><a href="#api文档链接" class="headerlink" title="api文档链接"></a>api文档链接</h2><p>交互式API文档链接(原链接基础上加/docs):<a href="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a><br>替代API文档链接(原链接基础上加/redoc):<a href="http://127.0.0.1:8000/redoc">http://127.0.0.1:8000/redoc</a></p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>post:创建数据<br>get:读取数据<br>put:更新数据<br>delete:删除数据</p><h1 id="接口路由的类型"><a href="#接口路由的类型" class="headerlink" title="接口路由的类型"></a>接口路由的类型</h1><h2 id="路径带有参数"><a href="#路径带有参数" class="headerlink" title="路径带有参数"></a>路径带有参数</h2><pre><code class="lang-python">from fastapi import FastAPIapp = FastAPI()@app.get(&quot;/items/&#123;item_id&#125;&quot;) # item_id可以作为参数async def read_item(item_id):    return &#123;&quot;item_id&quot;: item_id&#125;</code></pre><h2 id="路径参数带有类型"><a href="#路径参数带有类型" class="headerlink" title="路径参数带有类型"></a>路径参数带有类型</h2><pre><code class="lang-python">from fastapi import FastAPIapp = FastAPI()@app.get(&quot;/items/&#123;item_id&#125;&quot;)async def read_item(item_id: int):    return &#123;&quot;item_id&quot;: item_id&#125;</code></pre><h2 id="如何让带参数的路径与固定路径共存"><a href="#如何让带参数的路径与固定路径共存" class="headerlink" title="如何让带参数的路径与固定路径共存"></a>如何让带参数的路径与固定路径共存</h2><p>例如既需要@app.get(“/users/me”)又需要@app.get(“/users/{user_id}”)时<br>只需要将@app.get(“/users/me”)声明放到@app.get(“/users/{user_id}”)前面即可<br>举例:</p><pre><code class="lang-python">from fastapi import FastAPIapp = FastAPI()@app.get(&quot;/users/me&quot;)async def read_user_me():    return &#123;&quot;user_id&quot;: &quot;the current user&quot;&#125;@app.get(&quot;/users/&#123;user_id&#125;&quot;)async def read_user(user_id: str):    return &#123;&quot;user_id&quot;: user_id&#125;</code></pre><h2 id="通过枚举来让一个函数实现多个路径"><a href="#通过枚举来让一个函数实现多个路径" class="headerlink" title="通过枚举来让一个函数实现多个路径"></a>通过枚举来让一个函数实现多个路径</h2><p>通过继承str和enum来创建string类型的枚举类</p><pre><code class="lang-python">from enum import Enumfrom fastapi import FastAPIclass ModelName(str, Enum):    alexnet = &quot;alexnet&quot;    resnet = &quot;resnet&quot;    lenet = &quot;lenet&quot;app = FastAPI()@app.get(&quot;/models/&#123;model_name&#125;&quot;)async def get_model(model_name: ModelName):    if model_name is ModelName.alexnet:        return &#123;&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Deep Learning FTW!&quot;&#125;    if model_name.value == &quot;lenet&quot;:        return &#123;&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;LeCNN all the images&quot;&#125;    return &#123;&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Have some residuals&quot;&#125;</code></pre><h2 id="包含路径的路径参数"><a href="#包含路径的路径参数" class="headerlink" title="包含路径的路径参数"></a>包含路径的路径参数</h2><p>在本例中，参数的名称是 file_path ，最后一部分 :path 告诉它该参数应该匹配任何路径。</p><pre><code class="lang-python">from fastapi import FastAPIapp = FastAPI()@app.get(&quot;/files/&#123;file_path:path&#125;&quot;)async def read_file(file_path: str):    return &#123;&quot;file_path&quot;: file_path&#125;</code></pre><h1 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h1&gt;&lt;p&gt;官方文档:&lt;a href=&quot;https://fastapi.tiangolo.com/python-types/&quot;&gt;https://fast</summary>
      
    
    
    
    <category term="Geek" scheme="http://example.com/categories/Geek/"/>
    
    
    <category term="FastAPI" scheme="http://example.com/tags/FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://example.com/2024/03/03/Geek-python/"/>
    <id>http://example.com/2024/03/03/Geek-python/</id>
    <published>2024-03-03T12:24:00.000Z</published>
    <updated>2024-07-27T18:58:06.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象概念与设计原则"><a href="#面向对象概念与设计原则" class="headerlink" title="面向对象概念与设计原则"></a>面向对象概念与设计原则</h1><h2 id="面向对象编程的基本原理"><a href="#面向对象编程的基本原理" class="headerlink" title="面向对象编程的基本原理"></a>面向对象编程的基本原理</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>程序是由多种对象组合而成。<br>类是对象的类型定义，每一个对象都有类型，每一种类型的对象，都有同样的属性和方法。<br>对象是具备属性和功能的实例，而类则是定义属性和功能的模板。<br>类和对象的关系：类是对象的抽象，对象是类的实例。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>定义一个类的过程就是将一些相关的属性和方法组织在一起的过程。这样的操作被称为封装。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类，那么子类就拥有了父类的的所有属性和方法。<br>使用继承的方式复用类定义的代码</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>由一个类实例化出来的对象之间是相互独立的，不同对象虽然具备相同作用的属性和方法。但是由于它们各自在程序中扮演的角色不同，相同的属性值也将各自不同，相同的方法运行的结果也会不同。<br>这种同类对象各自独立的特性也被称为多态。</p><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>接口是一种对程序模块间互相访问方式的约定，在面向对象语言中，一般都会使用抽象类来定义。<br>抽象类指的是一种只定义了行为，但并没有提供完整功能实现的类。<br>举例：交通工具这样一个概念就可以被理解为一个抽象类或者一个接口。它只定义了交通工具运输的功能，但是并没有限制实现的方法。无论是汽车还是轮船，只要提供了对应的功能。就都符合了交通工具这个类型的定义。</p><h3 id="面向接口的设计模式"><a href="#面向接口的设计模式" class="headerlink" title="面向接口的设计模式"></a>面向接口的设计模式</h3><p>面向接口指的是以面向对象的方式定义程序功能和模块间传递数据的格式，以面向接口的方式设计程序框架结构是建立复杂程序的基础。<br>举例：在图形界面编程中定义一个按钮，我们会考虑到按钮需要可以被点击，点击可以触发一个信号来做一些别的事情，这就是一个行为，我们可以定义一个方法来描述这个行为。而这个按钮上，还有它的外观，比如形状尺寸等，按钮上面的文字，图标，控件的名称等等这些信息，有的是数字有的是文字有的是其他类型的对象。因此作为一个按钮对象，除了提供行为能力的方法之外，还需要各种类型的属性来支持。而设计一个界面编程库的时候，我们显然并不需要立刻就实例化一个真正的按钮控件，此时需要做的就是定义将来真正的按钮控件，被实例化时应当符合的规则。在设计接口时，我们需要做的就是创建一个类型来定义这些信息,并提示开发者在使用这个库的时候，完成这些抽象定义的具体实现，面向接口的设计模式从架构层面出发，从开发之初就预先定义了程序的复杂度，在之后的开发工作中，编程工作只需要不断地细化程序功能的实现从而避免随着开发的继续程序复杂度无限制的膨胀的问题。</p><h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>设计模式的五大基本原则根据英文被统称为SOLID原则：<br><img src="/.com//image.png" alt="alt text"></p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则指的是一个模块或一个类应当只承担一个职责，如果一个类在程序中同时扮演多种角色的话，当其中一个功能面临修改时势必会影响其他功能的使用。<br>在程序开发的阶段，一个类被修改的几率是很大的，因此应该专注于单一的功能。</p><h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><p>开放封闭原则指的是对扩展开放，对修改封闭，调整已存在的代码逻辑，往往会破坏与之相关的诸多模块。而在相同的逻辑规则下，增加更多的不同功能的插件实现，则可以有效的保持程序的稳定性。<br>如果提前划分了模块，并定义了各种模块的程序接口，当遇到需要调整某个模块才能适应新需求的问题时，只需要实现新的符合程序接口的模块即可实现适配。这样一个需要修改的问题就变成了扩展问题了。<br>实现更多变种的模块，以适应更多的需求实际上只是对程序的扩展，而非牵扯内部逻辑关系的修改，支持扩展反对修改就是开放封闭原则的关键。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则规定子类或以任何形式派生的类，都应当具备完全替代父类的能力。这意味着在编程中，当我们需要依赖一个明确定义的接口类型时，可以放心地依赖这个类，以及其任意子类实例地对象。而无需担心程序地预期行为受到影响。<br>举例：假如定义了一个交通工具这个父类，并实现了一个行驶的方法，假设这个方法允许输入一个目的地类型的对象从而改变当前对象的位置。如果继承交通工具来创建一个叫做汽车的子类，无论我们如何扩展这个子类，必须保证的是，他依然具备父类的功能，也就是行驶的方法，其输入的参数类型以及作用应当与父类保持一致。<br>通俗地讲：子类对象必须是一种更为具体地父类对象，一辆汽车必须是一个交通工具，否则它就不符合里氏替换原则，这样才能确保已经依赖了交通工具类型对象的模块，再将对象替换为汽车时依然是有效的。一个可以操作maya节点的程序，必须可以操作maya中的多边形节点，因为多边形节点必须与maya节点具备符合里氏替换的原则的关系。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口，是模块行为的描述。在程序构建阶段，我们需要定义的类型，都需要继承并实现接口中定义的功能。因此接口应当尽可能的单纯。换句话说，类不应该被迫地依赖它们不使用的方法。在python中语言本身并没有提供标准的接口类型，因此执行接口隔离原则需要具备对面向对象设计中的各种抽象概念有较深入的认识。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>依赖倒置原则主张在程序开发中，当模块之间互相关联时，应当依赖抽象而不应当依赖具体。假如实现一个控制多功能的渲染农场的程序，这个程序需要支持多种格式的任务文件。如果在开发中并没有提前定义一个任务文件的接口类型，而是直接在程序中依赖一些具体的文件格式，当需要支持新的格式时，势必无法避免重构所涉及这些对象的代码，这样的设计无疑造成了开发工作量和维护难度的增加。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>定义了一个函数,这个函数里有个内部函数,这个内部函数使用了函数中定义的变量,当外部函数执行完毕后,内部函数依然可以访问和操作外部函数中的变量.</p><pre><code class="lang-python">def greeting():    message = &quot;hello&quot;    value = 20    def inner():        print(f&#39;&#123;value&#125; - &#123;message&#125;&#39;)    message = &quot;second&quot;    return innerf = greeting()print(f.__closure__) f()</code></pre><h1 id="python自带的装饰器"><a href="#python自带的装饰器" class="headerlink" title="python自带的装饰器"></a>python自带的装饰器</h1><p>在定义函数时可以使用装饰器来改变函数的性质。</p><pre><code class="lang-python">from functools import wraps# def welcome(fn):#     @wraps(fn)#     def wrapper(*args, **kwargs):#         print(&quot;Welcome&quot;)#         result = fn(*args, **kwargs)#         return result##     return wrapperdef welcome(name):    def decorator(fn):        @wraps(fn)        def wrapper(*args, **kwargs):            print(f&quot;Welcome &#123;name&#125;&quot;)            result = fn(*args, **kwargs)            return result        return wrapper    return decorator@welcome(&quot;Tom&quot;)def my_fun(message: str):    print(f&quot;Hello &#123;message&#125;&quot;)@welcome(&quot;Mary&quot;)def my_fun_2():    print(&quot;my fun 2&quot;)# f1 = welcome(my_fun)# f1(&quot;Jack&quot;)my_fun(&quot;Jack&quot;)print(my_fun.__name__)</code></pre><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>property是一个用于创建特殊属性的装饰器，他的功能是将一个方法转换为一个属性，方法的返回值就是属性的返回值。<br>使用property装饰器定义的属性具有只读的特性，他的值在每一次被访问时，是实时的被计算出来的。<br>一般来说我们调用类的方法都是加一个括号，但是如果这个方法添加了property装饰器，那么我们就可以像调用类的属性一样直接使用这个方法调用返回的结果。</p><h2 id="attr-setter"><a href="#attr-setter" class="headerlink" title="attr.setter"></a>attr.setter</h2><p>这里的attr是经过property装饰后的方法的名字。因为经过property装饰后的方法就变成只能读的属性了，要想通过对象修改这个属性就需要使用setter装饰器</p><h2 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod"></a>classmethod</h2><p>类中定义的不加装饰器的方法都是实例方法，都需要一个self参数，而用classmethod装饰器装饰的方法被称为类方法，它需要的第一个参数不是self而是cls参数，用于表示类本身，类方法只能被类直接的调用，而不能在对象下调用。 </p><h2 id="staticmethod"><a href="#staticmethod" class="headerlink" title="staticmethod"></a>staticmethod</h2><p>被staticmethod装饰的方法叫静态方法，静态方法不需要传入self或cls参数。<br>静态方法和定义在类以外的方法是相似的。</p><h1 id="类与装饰器"><a href="#类与装饰器" class="headerlink" title="类与装饰器"></a>类与装饰器</h1><p>可以通过类来定义函数装饰器,也可以给类定义装饰器.</p><pre><code class="lang-python"># 以下装饰器实现的功能是在原来功能的基础上添加输出start与输出end的功能# 创建一个不需要参数的通过类定义的函数装饰器class MyDecorator:    def __init__(self, f):        self.f = f    def __call__(self, *args, **kwargs):        print(&quot;start&quot;)        result = self.f(*args, **kwargs)        print(&quot;end&quot;)        return result# 创建一个带参数的通过类定义的函数装饰器class ParamDecorator:    def __init__(self, name):        self.name = name    def __call__(self, f):        def wrap(*args):            print(f&quot;start &#123;self.name&#125;&quot;)            result = f(*args)            print(&quot;end&quot;)            return result        return wrap@ParamDecorator(&quot;Jack&quot;)def test():    print(&quot;test&quot;)    return 200print(test())# 定义类的装饰器def cls_decorator(cls):    print(&quot;start class decorator&quot;)    def inner():        print(&quot;start&quot;)        obj = cls()        print(&quot;end&quot;)        return obj    return inner@cls_decoratorclass Person:    passp1 = Person()p2 = Person()</code></pre><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><blockquote><p>迭代器（Iterator）是访问集合元素的一种方式。在Python中，迭代器对象必须实现两个特殊方法，  _<em>iter_<em>()   和   _<em>next_<em>()  。<br>  _<em>iter_</em>()  : 返回迭代器对象本身。如果类定义了此方法，则可以使用 in 语句和 for 循环来遍历。<br>  __next\</em></em>()  : 返回下一个值。如果没有后续元素，应该抛出StopIteration 异常。<br>```python<br>class Square:<br>    def __init</em></em>(self,count):<br>        self.count = count<br>        self.current = 0</p></blockquote><pre><code>def __iter__(self):    return selfdef __next__(self):    result = self.current**2    self.current += 1    if self.current &gt; self.count:        raise StopIteration    return result</code></pre><p>Square_obj = Square(5)<br>for i in Square_obj:<br>    print(i)</p><pre><code># 生成器当一个函数里包含yield语句时,这个函数就是一个生成器,生成器用来生成东西,相比return语句有个本质的区别:return在函数中只能返回一次,yield可以返回很多次.这个函数执行后返回一个生成器对象,这个对象是可以迭代的.生成器的好处是更节省内存,只要在用到数据的时候才会加载数据到内存中.next(生成器对象)可以用来迭代```pythondef hello():  # an iteratable object    print(&quot;step 1&quot;)    yield 1    print(&quot;step 2&quot;)    yield 2    print(&quot;step 3&quot;)    yield 3def my_fun():    result = []    for n in range(3):        result.append(n ** 2)    return resultg = hello()for res in g:    print(res)# 通过生成器来实现上一章的迭代器实现的功能也可以实现这里my_fun的功能def squares(count: int):    for n in range(count):        yield n ** 2for num in squares(3):    print(num)</code></pre><h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p>上下管理器是一个对象,它定义了运行时的上下文,上下文管理器为它造出来的对象定义了一个时间段,在这个时间段开始的时候做一件事情,在结束的时候做另外一件事情,在时间段开始到结束之间可以使用这个上下文管理器对象.<br>上下文管理器的类需要实现以下方法:<br>_<em>enter_<em>():上下文管理器造出来时执行,并且enter返回的对象为上下文管理器的别名<br>__exit\</em></em>(): 上下文管理器结束后执行的内容</p><pre><code class="lang-python"># instance = open(&quot;mydata.txt&quot;, &quot;w&quot;)# instance.write(&quot;Hello this is a test file&quot;)# instance.close()# with open(&quot;mydata.txt&quot;, &quot;w&quot;) as instance:#     instance.write(&quot;Hello this is a test file&quot;)### print(&quot;The end&quot;)import time# 定义实现上下文管理器的类class Timer:    def __init__(self):        self.elapsed = 0    def __enter__(self):        self.start = time.perf_counter()        return self    def __exit__(self, exc_type, exc_val, exc_tb):        self.stop = time.perf_counter()        self.elapsed = self.stop - self.start        return False# 这里的timer是__enter__的返回值with Timer() as timer:    nums = []    for n in range(10000):        nums.append(n ** 2)print(timer.elapsed)</code></pre><h1 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h1><p>Mixin模式是一种设计模式,将许多可以重用的功能写到类中当Mixin,凡是需要Mixin类功能的类都去通过多继承来获得Mixin类的功能.</p><pre><code class="lang-python">import jsonclass MapMixin:    def __getitem__(self, key):        return self.__dict__[key]    def __setitem__(self, key, value):        self.__dict__[key] = valueclass DictMixin:    def to_dict(self):        return self.__convert_dict(self.__dict__)    def __convert_dict(self, attrs: dict):        result = &#123;&#125;        for key, value in attrs.items():            result[key] = self.__convert_value(value)        return result    def __convert_value(self, value):        if isinstance(value, DictMixin):            return value.to_dict()        elif isinstance(value, dict):            return self.__convert_dict(value)        elif isinstance(value, list):            return [self.__convert_value(v) for v in value]        elif hasattr(value, &#39;__dict__&#39;):            return self.__convert_dict(value.__dict__)        else:            return valueclass JSONMixin:    def to_json(self):        return json.dumps(self.to_dict())class Student(MapMixin, DictMixin, JSONMixin):    def __init__(self, name, age):        self.name = name        self.age = age# &#123;&quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 20, &quot;clasx&quot;: &#123;&quot;name&quot;: &quot;class 9-1&quot;, &quot;building&quot;: &quot;A&quot;&#125;&#125;s = Student(&quot;Jack&quot;, 20)print(s[&quot;name&quot;])print(s.to_dict())print(s.to_json())</code></pre><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的根本目的就是让一个类只能制造出一个对象<br>单例的需求一般是针对需要共享数据的对象,例如:工厂对象,数据库连接池对象,任何其他想要所有人共享的对象</p><pre><code class="lang-python">def singleton(cls):    _instance = &#123;&#125;    def inner(*args, **kwargs):        if cls in _instance:            return _instance[cls]        obj = cls(*args, **kwargs)        _instance[cls] = obj        return obj    return innerclass SingletonMeta(type):    def __call__(cls, *args, **kwargs):        if hasattr(cls, &#39;_instance&#39;):            return getattr(cls, &#39;_instance&#39;)        obj = super().__call__(*args, **kwargs)        setattr(cls, &#39;_instance&#39;, obj)        return obj# @singletonclass Person(metaclass=SingletonMeta):    passp_1 = Person()p_2 = Person()print(p_1 is p_2)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象概念与设计原则&quot;&gt;&lt;a href=&quot;#面向对象概念与设计原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象概念与设计原则&quot;&gt;&lt;/a&gt;面向对象概念与设计原则&lt;/h1&gt;&lt;h2 id=&quot;面向对象编程的基本原理&quot;&gt;&lt;a href=&quot;#面向对象编程</summary>
      
    
    
    
    <category term="Geek" scheme="http://example.com/categories/Geek/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI工作流</title>
    <link href="http://example.com/2024/01/08/AI-ComfyUI%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://example.com/2024/01/08/AI-ComfyUI%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2024-01-08T10:21:00.000Z</published>
    <updated>2024-07-27T18:58:06.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作流的参考方法"><a href="#工作流的参考方法" class="headerlink" title="工作流的参考方法"></a>工作流的参考方法</h1><p>方法一:将图片拖拽进ComfyUI中<br>方法二:复制json内容粘贴至ComfyUI</p><h1 id="ipadapter配合controlnet"><a href="#ipadapter配合controlnet" class="headerlink" title="ipadapter配合controlnet"></a>ipadapter配合controlnet</h1><p><img src="/.com//ipadapter_and_controlnet.png" alt="Alt text"></p><h1 id="只需要通过一个节点就可以负责Lora一个或多个的添加"><a href="#只需要通过一个节点就可以负责Lora一个或多个的添加" class="headerlink" title="只需要通过一个节点就可以负责Lora一个或多个的添加"></a>只需要通过一个节点就可以负责Lora一个或多个的添加</h1><p><img src="/.com//image.png" alt="Alt text"><br>工作流解析:<br>通过设置节点参数来使用一个或多个Lora<br><img src="/.com//image-1.png" alt="Alt text"></p><h1 id="局部重绘"><a href="#局部重绘" class="headerlink" title="局部重绘"></a>局部重绘</h1><p><img src="/.com//image-2.png" alt="Alt text"><br>省流版:<br>其中VAE Encode(for Inpainting) 和 Set Latent Noise Mask效果差不多,可以都测试测试看哪个效果好.<br><img src="/.com//image-4.png" alt="Alt text"></p><h1 id="PS投屏实时绘画"><a href="#PS投屏实时绘画" class="headerlink" title="PS投屏实时绘画"></a>PS投屏实时绘画</h1><pre><code class="lang-json">&#123;  &quot;last_node_id&quot;: 169,  &quot;last_link_id&quot;: 326,  &quot;nodes&quot;: [    &#123;      &quot;id&quot;: 107,      &quot;type&quot;: &quot;Note&quot;,      &quot;pos&quot;: [        292.05923012390133,        649.03209475708      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 293.3884582519531,        &quot;1&quot;: 158.1380615234375      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 0,      &quot;mode&quot;: 0,      &quot;title&quot;: &quot;采样器数值说明&quot;,      &quot;properties&quot;: &#123;        &quot;text&quot;: &quot;&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;1.seed:值为-1时每次出图都是随机的\n2.steps:意思是步数,值越高质量越高,相应的出图速度越慢,实时绘画建议4~8.\n3.cfg:cfg越大生成的图就越符合提示词内容,由于使用了LCM来加速了实时绘画出图的速度因此需要控制在1~2最好.\n4.sampler_name:采样器dpmpp对应SDWebUI的dmp++\n5.scheduler: 采样调度,一般选择karras或者normal即可                        \n6.denoise:重绘幅度,值越大重绘幅度越大\n7.preview_method:预览方法,不重要,跟出图效果无关\n8.vae_decode:控制如何使用vae,保持默认即可&quot;      ],      &quot;color&quot;: &quot;#432&quot;,      &quot;bgcolor&quot;: &quot;#653&quot;    &#125;,    &#123;      &quot;id&quot;: 108,      &quot;type&quot;: &quot;Note&quot;,      &quot;pos&quot;: [        -949.0268085632321,        1128.7023533935537      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 322.2235107421875,        &quot;1&quot;: 107.0997085571289      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 1,      &quot;mode&quot;: 0,      &quot;title&quot;: &quot;如何设置PS与ComfyUI连接&quot;,      &quot;properties&quot;: &#123;        &quot;text&quot;: &quot;&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;1.点击ShareScreen按钮,会弹出一个窗口,有三种模式,分别是Chrome标签页,窗口,整个屏幕.选择窗口模式,然后找到要与Comfyui连接的PS项目.点击选中并点击分享按钮.\n2.点击SetArea按钮,在弹出的窗口中框住画布区域,可以理解为框住的画布区域就是图生图流程中提供的参考图.\n3.点击LiveRun按钮&quot;      ],      &quot;color&quot;: &quot;#432&quot;,      &quot;bgcolor&quot;: &quot;#653&quot;    &#125;,    &#123;      &quot;id&quot;: 109,      &quot;type&quot;: &quot;LoraLoader&quot;,      &quot;pos&quot;: [        -1307,        802      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 337.1312255859375,        &quot;1&quot;: 126      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 9,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 177,          &quot;label&quot;: &quot;model&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 178,          &quot;label&quot;: &quot;clip&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            179          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;MODEL&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;CLIP&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;links&quot;: [            180          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CLIP&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;LoraLoader&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;add_detail.safetensors&quot;,        1,        1      ]    &#125;,    &#123;      &quot;id&quot;: 10,      &quot;type&quot;: &quot;VAELoader&quot;,      &quot;pos&quot;: [        -488,        1192      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 348.7921447753906,        &quot;1&quot;: 58      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 2,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;VAE&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;links&quot;: [            30,            144          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;VAE&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;加载VAE&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;VAELoader&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;Anything-V3.0.vae.pt&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 82,      &quot;type&quot;: &quot;ModelSamplingDiscrete&quot;,      &quot;pos&quot;: [        -476,        556      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 82      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 12,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 181,          &quot;label&quot;: &quot;model&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            140          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;MODEL&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ModelSamplingDiscrete&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;lcm&quot;,        false      ]    &#125;,    &#123;      &quot;id&quot;: 5,      &quot;type&quot;: &quot;CLIPTextEncode&quot;,      &quot;pos&quot;: [        -495,        954      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 380.93463134765625,        &quot;1&quot;: 185.83177185058594      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 14,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 183,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            142          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;反向提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPTextEncode&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 3,      &quot;type&quot;: &quot;CheckpointLoaderSimple&quot;,      &quot;pos&quot;: [        -2230,        810      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 321.88446044921875,        &quot;1&quot;: 98      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 3,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            14          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;MODEL&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;CLIP&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;links&quot;: [            16          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CLIP&quot;,          &quot;slot_index&quot;: 1        &#125;,        &#123;          &quot;name&quot;: &quot;VAE&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;links&quot;: null,          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;VAE&quot;        &#125;      ],      &quot;title&quot;: &quot;加载模型&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CheckpointLoaderSimple&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;cardosAnimated_v30.safetensors&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 4,      &quot;type&quot;: &quot;CLIPTextEncode&quot;,      &quot;pos&quot;: [        -494,        718      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 382.7315368652344,        &quot;1&quot;: 166.9505615234375      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 13,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 182,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            141          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;正向提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPTextEncode&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;natural light, incandescent light, fiber optic,\nmorning light,Moody Lighting, edge light, movie\nlighting, studio lighting, soft lighting, Distorted\nenergy flow,quantitative, Contra Jour, beautiful\nlighting,emphasizing lighting,global lighting,\nscreen space global lighting,ray tracing global\nlighting, optics，scattering,\nluminescence，shadows,\nroughness,flash, incremental detail and integration,\nultra maximum, element, ultra realistic,ultra\ndetailed&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 100,      &quot;type&quot;: &quot;ScreenShare&quot;,      &quot;pos&quot;: [        -947.0268085632321,        1284.7023533935537      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 372.8167724609375,        &quot;1&quot;: 276.5818786621094      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 4,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            175          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;MASK&quot;,          &quot;type&quot;: &quot;MASK&quot;,          &quot;links&quot;: [],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;MASK&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;STRING&quot;,          &quot;type&quot;: &quot;STRING&quot;,          &quot;links&quot;: null,          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;STRING&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;INT&quot;,          &quot;type&quot;: &quot;INT&quot;,          &quot;links&quot;: null,          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;INT&quot;        &#125;      ],      &quot;title&quot;: &quot;设置如何共享屏幕&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ScreenShare&quot;      &#125;,      &quot;widgets_values&quot;: [        null,        null,        null,        null,        null      ]    &#125;,    &#123;      &quot;id&quot;: 21,      &quot;type&quot;: &quot;VAEEncode&quot;,      &quot;pos&quot;: [        -71,        1293      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 210,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 10,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;pixels&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 263,          &quot;label&quot;: &quot;pixels&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;vae&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;link&quot;: 30,          &quot;label&quot;: &quot;vae&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;LATENT&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [            301          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;LATENT&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;VAEEncode&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 13,      &quot;type&quot;: &quot;LoraLoader&quot;,      &quot;pos&quot;: [        -1840,        810      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 337.1312255859375,        &quot;1&quot;: 126      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 7,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 14,          &quot;label&quot;: &quot;model&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 16,          &quot;label&quot;: &quot;clip&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            177          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;MODEL&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;CLIP&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;links&quot;: [            178          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CLIP&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;LoraLoader&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;LCM_LoRA_SD15.safetensors&quot;,        1,        1      ]    &#125;,    &#123;      &quot;id&quot;: 28,      &quot;type&quot;: &quot;ImageScale&quot;,      &quot;pos&quot;: [        -476,        1305      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 324.6936340332031,        &quot;1&quot;: 130      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 8,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;image&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 175,          &quot;label&quot;: &quot;image&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            263          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;设置图片分辨率大小&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ImageScale&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;nearest-exact&quot;,        576,        603,        &quot;disabled&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 89,      &quot;type&quot;: &quot;KSampler (Efficient)&quot;,      &quot;pos&quot;: [        222,        871      ],      &quot;size&quot;: [        438.64739990234375,        579.5003051757812      ],      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 17,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 140,          &quot;label&quot;: &quot;model&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;positive&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 141,          &quot;label&quot;: &quot;positive&quot;,          &quot;slot_index&quot;: 1        &#125;,        &#123;          &quot;name&quot;: &quot;negative&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 142,          &quot;label&quot;: &quot;negative&quot;,          &quot;slot_index&quot;: 2        &#125;,        &#123;          &quot;name&quot;: &quot;latent_image&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;link&quot;: 301,          &quot;label&quot;: &quot;latent_image&quot;,          &quot;slot_index&quot;: 3        &#125;,        &#123;          &quot;name&quot;: &quot;optional_vae&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;link&quot;: 144,          &quot;label&quot;: &quot;optional_vae&quot;,          &quot;slot_index&quot;: 4        &#125;,        &#123;          &quot;name&quot;: &quot;script&quot;,          &quot;type&quot;: &quot;SCRIPT&quot;,          &quot;link&quot;: null,          &quot;label&quot;: &quot;script&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            241          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;MODEL&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;CONDITIONING+&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            324          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING+&quot;,          &quot;slot_index&quot;: 1        &#125;,        &#123;          &quot;name&quot;: &quot;CONDITIONING-&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            313          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING-&quot;,          &quot;slot_index&quot;: 2        &#125;,        &#123;          &quot;name&quot;: &quot;LATENT&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;LATENT&quot;,          &quot;slot_index&quot;: 3        &#125;,        &#123;          &quot;name&quot;: &quot;VAE&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;links&quot;: [            245,            280          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;VAE&quot;,          &quot;slot_index&quot;: 4        &#125;,        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            176,            186          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 5        &#125;      ],      &quot;title&quot;: &quot;采样器&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;KSampler (Efficient)&quot;      &#125;,      &quot;widgets_values&quot;: [        863389622127326,        null,        7,        1.5,        &quot;dpmpp_sde_gpu&quot;,        &quot;karras&quot;,        0.33,        &quot;auto&quot;,        &quot;true&quot;      ],      &quot;color&quot;: &quot;#332222&quot;,      &quot;bgcolor&quot;: &quot;#553333&quot;,      &quot;shape&quot;: 1    &#125;,    &#123;      &quot;id&quot;: 110,      &quot;type&quot;: &quot;LoraLoader&quot;,      &quot;pos&quot;: [        -947,        802      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 126      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 11,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 179,          &quot;label&quot;: &quot;model&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 180,          &quot;label&quot;: &quot;clip&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            181          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;MODEL&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;CLIP&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;links&quot;: [            182,            183,            325,            326          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CLIP&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;LoraLoader&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;animeoutlineV4_16.safetensors&quot;,        1,        1      ]    &#125;,    &#123;      &quot;id&quot;: 106,      &quot;type&quot;: &quot;FloatingVideo&quot;,      &quot;pos&quot;: [        -27,        1601      ],      &quot;size&quot;: [        749.3804321289062,        58      ],      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 18,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;images&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 176,          &quot;label&quot;: &quot;images&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;FloatingVideo&quot;      &#125;,      &quot;widgets_values&quot;: [        null      ]    &#125;,    &#123;      &quot;id&quot;: 166,      &quot;type&quot;: &quot;CLIPTextEncode&quot;,      &quot;pos&quot;: [        786,        917      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 15,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 325,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            322          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;新增调节的正向提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPTextEncode&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 167,      &quot;type&quot;: &quot;CLIPTextEncode&quot;,      &quot;pos&quot;: [        790,        1165      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 16,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 326,          &quot;label&quot;: &quot;clip&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            317          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;新增调节的反向提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPTextEncode&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 168,      &quot;type&quot;: &quot;ConditioningCombine&quot;,      &quot;pos&quot;: [        1258,        1172      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: true      &#125;,      &quot;order&quot;: 25,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_1&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 319,          &quot;label&quot;: &quot;conditioning_1&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_2&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 317,          &quot;label&quot;: &quot;conditioning_2&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            320          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningCombine&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 169,      &quot;type&quot;: &quot;ConditioningConcat&quot;,      &quot;pos&quot;: [        1255,        958      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 380.4000244140625,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: true      &#125;,      &quot;order&quot;: 24,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_to&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 321,          &quot;label&quot;: &quot;conditioning_to&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_from&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 322,          &quot;label&quot;: &quot;conditioning_from&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            323          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningConcat&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 137,      &quot;type&quot;: &quot;KSampler&quot;,      &quot;pos&quot;: [        1522,        1003      ],      &quot;size&quot;: [        294.13656779296934,        273.1279147644045      ],      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 26,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 241,          &quot;label&quot;: &quot;model&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;positive&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 323,          &quot;label&quot;: &quot;positive&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;negative&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 320,          &quot;label&quot;: &quot;negative&quot;,          &quot;slot_index&quot;: 2        &#125;,        &#123;          &quot;name&quot;: &quot;latent_image&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;link&quot;: 246,          &quot;label&quot;: &quot;latent_image&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;LATENT&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [            279          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;LATENT&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;KSampler&quot;      &#125;,      &quot;widgets_values&quot;: [        982036911888596,        &quot;randomize&quot;,        12,        1.6,        &quot;dpmpp_sde_gpu&quot;,        &quot;karras&quot;,        0.3      ]    &#125;,    &#123;      &quot;id&quot;: 115,      &quot;type&quot;: &quot;UpscaleModelLoader&quot;,      &quot;pos&quot;: [        777,        487      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 58      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 5,      &quot;mode&quot;: 4,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;UPSCALE_MODEL&quot;,          &quot;type&quot;: &quot;UPSCALE_MODEL&quot;,          &quot;links&quot;: [            184          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;UPSCALE_MODEL&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;UpscaleModelLoader&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;4x-UltraSharp.pth&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 133,      &quot;type&quot;: &quot;ImageScaleBy&quot;,      &quot;pos&quot;: [        779,        602      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 82      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 20,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;image&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 231,          &quot;label&quot;: &quot;image&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            244,            303          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ImageScaleBy&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;nearest-exact&quot;,        0.5      ]    &#125;,    &#123;      &quot;id&quot;: 163,      &quot;type&quot;: &quot;TilePreprocessor&quot;,      &quot;pos&quot;: [        1164,        585      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 82      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 22,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;image&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 303,          &quot;label&quot;: &quot;image&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            304          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;TilePreprocessor&quot;      &#125;,      &quot;widgets_values&quot;: [        3,        512      ]    &#125;,    &#123;      &quot;id&quot;: 138,      &quot;type&quot;: &quot;VAEEncode&quot;,      &quot;pos&quot;: [        814,        800      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 210,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: true      &#125;,      &quot;order&quot;: 21,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;pixels&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 244,          &quot;label&quot;: &quot;pixels&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;vae&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;link&quot;: 245,          &quot;label&quot;: &quot;vae&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;LATENT&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [            246          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;LATENT&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;VAEEncode&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 165,      &quot;type&quot;: &quot;ControlNetLoader&quot;,      &quot;pos&quot;: [        796,        759      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 58      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: true      &#125;,      &quot;order&quot;: 6,      &quot;mode&quot;: 4,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONTROL_NET&quot;,          &quot;type&quot;: &quot;CONTROL_NET&quot;,          &quot;links&quot;: [            307          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONTROL_NET&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ControlNetLoader&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;ControlNet-v1-1/control_v11f1e_sd15_tile.pth&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 164,      &quot;type&quot;: &quot;ControlNetApplyAdvanced&quot;,      &quot;pos&quot;: [        1161,        710      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 166      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 23,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;positive&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 324,          &quot;label&quot;: &quot;positive&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;negative&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 313,          &quot;label&quot;: &quot;negative&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;control_net&quot;,          &quot;type&quot;: &quot;CONTROL_NET&quot;,          &quot;link&quot;: 307,          &quot;label&quot;: &quot;control_net&quot;,          &quot;slot_index&quot;: 2        &#125;,        &#123;          &quot;name&quot;: &quot;image&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 304,          &quot;label&quot;: &quot;image&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;positive&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            321          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;positive&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;negative&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            319          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;negative&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ControlNetApplyAdvanced&quot;      &#125;,      &quot;widgets_values&quot;: [        0.4,        0,        1      ]    &#125;,    &#123;      &quot;id&quot;: 157,      &quot;type&quot;: &quot;VAEDecode&quot;,      &quot;pos&quot;: [        1911,        938      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 210,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: true      &#125;,      &quot;order&quot;: 27,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;samples&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;link&quot;: 279,          &quot;label&quot;: &quot;samples&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;vae&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;link&quot;: 280,          &quot;label&quot;: &quot;vae&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            282          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;VAEDecode&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 114,      &quot;type&quot;: &quot;ImageUpscaleWithModel&quot;,      &quot;pos&quot;: [        1145,        477      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 241.79998779296875,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 19,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;upscale_model&quot;,          &quot;type&quot;: &quot;UPSCALE_MODEL&quot;,          &quot;link&quot;: 184,          &quot;label&quot;: &quot;upscale_model&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;image&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 186,          &quot;label&quot;: &quot;image&quot;,          &quot;slot_index&quot;: 1        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            231          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ImageUpscaleWithModel&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 158,      &quot;type&quot;: &quot;PreviewImage&quot;,      &quot;pos&quot;: [        785,        1624      ],      &quot;size&quot;: [        750.4013947012313,        832.9999910122001      ],      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 28,      &quot;mode&quot;: 4,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;images&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 282,          &quot;label&quot;: &quot;images&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;PreviewImage&quot;      &#125;    &#125;  ],  &quot;links&quot;: [    [      14,      3,      0,      13,      0,      &quot;MODEL&quot;    ],    [      16,      3,      1,      13,      1,      &quot;CLIP&quot;    ],    [      30,      10,      0,      21,      1,      &quot;VAE&quot;    ],    [      140,      82,      0,      89,      0,      &quot;MODEL&quot;    ],    [      141,      4,      0,      89,      1,      &quot;CONDITIONING&quot;    ],    [      142,      5,      0,      89,      2,      &quot;CONDITIONING&quot;    ],    [      144,      10,      0,      89,      4,      &quot;VAE&quot;    ],    [      175,      100,      0,      28,      0,      &quot;IMAGE&quot;    ],    [      176,      89,      5,      106,      0,      &quot;IMAGE&quot;    ],    [      177,      13,      0,      109,      0,      &quot;MODEL&quot;    ],    [      178,      13,      1,      109,      1,      &quot;CLIP&quot;    ],    [      179,      109,      0,      110,      0,      &quot;MODEL&quot;    ],    [      180,      109,      1,      110,      1,      &quot;CLIP&quot;    ],    [      181,      110,      0,      82,      0,      &quot;MODEL&quot;    ],    [      182,      110,      1,      4,      0,      &quot;CLIP&quot;    ],    [      183,      110,      1,      5,      0,      &quot;CLIP&quot;    ],    [      184,      115,      0,      114,      0,      &quot;UPSCALE_MODEL&quot;    ],    [      186,      89,      5,      114,      1,      &quot;IMAGE&quot;    ],    [      231,      114,      0,      133,      0,      &quot;IMAGE&quot;    ],    [      241,      89,      0,      137,      0,      &quot;MODEL&quot;    ],    [      244,      133,      0,      138,      0,      &quot;IMAGE&quot;    ],    [      245,      89,      4,      138,      1,      &quot;VAE&quot;    ],    [      246,      138,      0,      137,      3,      &quot;LATENT&quot;    ],    [      263,      28,      0,      21,      0,      &quot;IMAGE&quot;    ],    [      279,      137,      0,      157,      0,      &quot;LATENT&quot;    ],    [      280,      89,      4,      157,      1,      &quot;VAE&quot;    ],    [      282,      157,      0,      158,      0,      &quot;IMAGE&quot;    ],    [      301,      21,      0,      89,      3,      &quot;LATENT&quot;    ],    [      303,      133,      0,      163,      0,      &quot;IMAGE&quot;    ],    [      304,      163,      0,      164,      3,      &quot;IMAGE&quot;    ],    [      307,      165,      0,      164,      2,      &quot;CONTROL_NET&quot;    ],    [      313,      89,      2,      164,      1,      &quot;CONDITIONING&quot;    ],    [      317,      167,      0,      168,      1,      &quot;CONDITIONING&quot;    ],    [      319,      164,      1,      168,      0,      &quot;CONDITIONING&quot;    ],    [      320,      168,      0,      137,      2,      &quot;CONDITIONING&quot;    ],    [      321,      164,      0,      169,      0,      &quot;CONDITIONING&quot;    ],    [      322,      166,      0,      169,      1,      &quot;CONDITIONING&quot;    ],    [      323,      169,      0,      137,      1,      &quot;CONDITIONING&quot;    ],    [      324,      89,      1,      164,      0,      &quot;CONDITIONING&quot;    ],    [      325,      110,      1,      166,      0,      &quot;CLIP&quot;    ],    [      326,      110,      1,      167,      0,      &quot;CLIP&quot;    ]  ],  &quot;groups&quot;: [    &#123;      &quot;title&quot;: &quot;第一步&quot;,      &quot;bounding&quot;: [        -1004,        1062,        493,        917      ],      &quot;color&quot;: &quot;#3f789e&quot;,      &quot;font_size&quot;: 24,      &quot;locked&quot;: false    &#125;,    &#123;      &quot;title&quot;: &quot;设置出图的效果&quot;,      &quot;bounding&quot;: [        135,        530,        600,        998      ],      &quot;color&quot;: &quot;#3f789e&quot;,      &quot;font_size&quot;: 24,      &quot;locked&quot;: false    &#125;,    &#123;      &quot;title&quot;: &quot;图片放大&quot;,      &quot;bounding&quot;: [        767,        304,        1357,        2185      ],      &quot;color&quot;: &quot;#3f789e&quot;,      &quot;font_size&quot;: 24,      &quot;locked&quot;: false    &#125;  ],  &quot;config&quot;: &#123;&#125;,  &quot;extra&quot;: &#123;&#125;,  &quot;version&quot;: 0.4&#125;</code></pre><h1 id="SVD图生视频"><a href="#SVD图生视频" class="headerlink" title="SVD图生视频"></a>SVD图生视频</h1><pre><code class="lang-json">&#123;  &quot;last_node_id&quot;: 24,  &quot;last_link_id&quot;: 42,  &quot;nodes&quot;: [    &#123;      &quot;id&quot;: 17,      &quot;type&quot;: &quot;KSampler&quot;,      &quot;pos&quot;: [        802.4000122070315,        566.4000274658204      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 474      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 8,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 28,          &quot;label&quot;: &quot;model&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;positive&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 30,          &quot;label&quot;: &quot;positive&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;negative&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 32,          &quot;label&quot;: &quot;negative&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;latent_image&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;link&quot;: 37,          &quot;slot_index&quot;: 3,          &quot;label&quot;: &quot;latent_image&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;LATENT&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [            33          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;LATENT&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;KSampler&quot;      &#125;,      &quot;widgets_values&quot;: [        870215885552051,        &quot;randomize&quot;,        15,        8,        &quot;uni_pc_bh2&quot;,        &quot;normal&quot;,        1      ]    &#125;,    &#123;      &quot;id&quot;: 22,      &quot;type&quot;: &quot;EmptyLatentImage&quot;,      &quot;pos&quot;: [        422.4000122070312,        866.4000274658204      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 310,        &quot;1&quot;: 110      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 0,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;LATENT&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [            37          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;LATENT&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;EmptyLatentImage&quot;      &#125;,      &quot;widgets_values&quot;: [        1024,        576,        1      ]    &#125;,    &#123;      &quot;id&quot;: 8,      &quot;type&quot;: &quot;VAEDecode&quot;,      &quot;pos&quot;: [        2635.0480407592772,        634      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 210,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 13,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;samples&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;link&quot;: 7,          &quot;label&quot;: &quot;samples&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;vae&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;link&quot;: 26,          &quot;label&quot;: &quot;vae&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            10          ],          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;IMAGE&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;VAEDecode&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 14,      &quot;type&quot;: &quot;VideoLinearCFGGuidance&quot;,      &quot;pos&quot;: [        1896.0480407592775,        578      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 58      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 5,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 23,          &quot;label&quot;: &quot;model&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            39          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;MODEL&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;VideoLinearCFGGuidance&quot;      &#125;,      &quot;widgets_values&quot;: [        1      ]    &#125;,    &#123;      &quot;id&quot;: 20,      &quot;type&quot;: &quot;VAEDecode&quot;,      &quot;pos&quot;: [        1179,        581      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 210,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 9,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;samples&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;link&quot;: 33,          &quot;label&quot;: &quot;samples&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;vae&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;link&quot;: 34,          &quot;slot_index&quot;: 1,          &quot;label&quot;: &quot;vae&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [            36,            42          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;IMAGE&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;VAEDecode&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 18,      &quot;type&quot;: &quot;CLIPTextEncode&quot;,      &quot;pos&quot;: [        342.4000122070312,        516.4000274658204      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 390,        &quot;1&quot;: 130      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 6,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 29,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            30          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPTextEncode&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;photograph beautiful scenery nature mountains alps river rapids snow sky cumulus clouds&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 3,      &quot;type&quot;: &quot;KSampler&quot;,      &quot;pos&quot;: [        2268.0480407592772,        629      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 294.6124267578125,        &quot;1&quot;: 474      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 12,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;model&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;link&quot;: 39,          &quot;label&quot;: &quot;model&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;positive&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 40,          &quot;label&quot;: &quot;positive&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;negative&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 17,          &quot;label&quot;: &quot;negative&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;latent_image&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;link&quot;: 18,          &quot;label&quot;: &quot;latent_image&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;LATENT&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [            7          ],          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;LATENT&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;KSampler&quot;      &#125;,      &quot;widgets_values&quot;: [        1064761774727342,        &quot;randomize&quot;,        20,        2.5,        &quot;euler&quot;,        &quot;karras&quot;,        1      ]    &#125;,    &#123;      &quot;id&quot;: 15,      &quot;type&quot;: &quot;ImageOnlyCheckpointLoader&quot;,      &quot;pos&quot;: [        1495,        397      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 369.6000061035156,        &quot;1&quot;: 98      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 1,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            23          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;MODEL&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;CLIP_VISION&quot;,          &quot;type&quot;: &quot;CLIP_VISION&quot;,          &quot;links&quot;: [            24          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 1,          &quot;label&quot;: &quot;CLIP_VISION&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;VAE&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;links&quot;: [            25,            26          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 2,          &quot;label&quot;: &quot;VAE&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ImageOnlyCheckpointLoader&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;svd_xt.safetensors&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 21,      &quot;type&quot;: &quot;PreviewImage&quot;,      &quot;pos&quot;: [        1155,        727      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 275.9453125,        &quot;1&quot;: 246      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 10,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;images&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 36,          &quot;label&quot;: &quot;images&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;PreviewImage&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 23,      &quot;type&quot;: &quot;LoadImage&quot;,      &quot;pos&quot;: [        1045,        1119      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 314      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 2,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;IMAGE&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;links&quot;: [],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;IMAGE&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;MASK&quot;,          &quot;type&quot;: &quot;MASK&quot;,          &quot;links&quot;: null,          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;MASK&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;LoadImage&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;ComfyUI_00140_.png&quot;,        &quot;image&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 16,      &quot;type&quot;: &quot;CheckpointLoaderSimple&quot;,      &quot;pos&quot;: [        -87,        510      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 98      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 3,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;MODEL&quot;,          &quot;type&quot;: &quot;MODEL&quot;,          &quot;links&quot;: [            28          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;MODEL&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;CLIP&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;links&quot;: [            29,            31          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 1,          &quot;label&quot;: &quot;CLIP&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;VAE&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;links&quot;: [            34          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;VAE&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CheckpointLoaderSimple&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;dreamshaper_7.safetensors&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 12,      &quot;type&quot;: &quot;SVD_img2vid_Conditioning&quot;,      &quot;pos&quot;: [        1906.0480407592775,        689      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 218      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 11,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip_vision&quot;,          &quot;type&quot;: &quot;CLIP_VISION&quot;,          &quot;link&quot;: 24,          &quot;label&quot;: &quot;clip_vision&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;init_image&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 42,          &quot;slot_index&quot;: 1,          &quot;label&quot;: &quot;init_image&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;vae&quot;,          &quot;type&quot;: &quot;VAE&quot;,          &quot;link&quot;: 25,          &quot;label&quot;: &quot;vae&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;positive&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            40          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;positive&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;negative&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            17          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 1,          &quot;label&quot;: &quot;negative&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;latent&quot;,          &quot;type&quot;: &quot;LATENT&quot;,          &quot;links&quot;: [            18          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 2,          &quot;label&quot;: &quot;latent&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;SVD_img2vid_Conditioning&quot;      &#125;,      &quot;widgets_values&quot;: [        1024,        576,        25,        87,        6,        0.05      ]    &#125;,    &#123;      &quot;id&quot;: 24,      &quot;type&quot;: &quot;Note&quot;,      &quot;pos&quot;: [        1896,        929      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 356.2646484375,        &quot;1&quot;: 103.78158569335938      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 4,      &quot;mode&quot;: 0,      &quot;properties&quot;: &#123;        &quot;text&quot;: &quot;&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;width:生成视频的宽度\nheight:生成视频的高度\nvideo_frames:生成的运动总帧数(建议最大25)\nMotion_bucket_id:数值越大运动幅度越大(建议100以内,不超过200)\nFPS:视频的每秒帧数(6或8)\nAugmentation_level:添加到图像的噪声量(0.1以内,不超过0.5)&quot;      ],      &quot;color&quot;: &quot;#432&quot;,      &quot;bgcolor&quot;: &quot;#653&quot;    &#125;,    &#123;      &quot;id&quot;: 19,      &quot;type&quot;: &quot;CLIPTextEncode&quot;,      &quot;pos&quot;: [        342,        691      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 390,        &quot;1&quot;: 130      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 7,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 31,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            32          ],          &quot;shape&quot;: 3,          &quot;slot_index&quot;: 0,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPTextEncode&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;text, watermark&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 10,      &quot;type&quot;: &quot;SaveAnimatedWEBP&quot;,      &quot;pos&quot;: [        2907,        405      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 708.6719970703125,        &quot;1&quot;: 843.7864379882812      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 14,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;images&quot;,          &quot;type&quot;: &quot;IMAGE&quot;,          &quot;link&quot;: 10,          &quot;label&quot;: &quot;images&quot;        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;SaveAnimatedWEBP&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;ComfyUI&quot;,        10,        false,        85,        &quot;default&quot;,        null      ]    &#125;  ],  &quot;links&quot;: [    [      7,      3,      0,      8,      0,      &quot;LATENT&quot;    ],    [      10,      8,      0,      10,      0,      &quot;IMAGE&quot;    ],    [      17,      12,      1,      3,      2,      &quot;CONDITIONING&quot;    ],    [      18,      12,      2,      3,      3,      &quot;LATENT&quot;    ],    [      23,      15,      0,      14,      0,      &quot;MODEL&quot;    ],    [      24,      15,      1,      12,      0,      &quot;CLIP_VISION&quot;    ],    [      25,      15,      2,      12,      2,      &quot;VAE&quot;    ],    [      26,      15,      2,      8,      1,      &quot;VAE&quot;    ],    [      28,      16,      0,      17,      0,      &quot;MODEL&quot;    ],    [      29,      16,      1,      18,      0,      &quot;CLIP&quot;    ],    [      30,      18,      0,      17,      1,      &quot;CONDITIONING&quot;    ],    [      31,      16,      1,      19,      0,      &quot;CLIP&quot;    ],    [      32,      19,      0,      17,      2,      &quot;CONDITIONING&quot;    ],    [      33,      17,      0,      20,      0,      &quot;LATENT&quot;    ],    [      34,      16,      2,      20,      1,      &quot;VAE&quot;    ],    [      36,      20,      0,      21,      0,      &quot;IMAGE&quot;    ],    [      37,      22,      0,      17,      3,      &quot;LATENT&quot;    ],    [      39,      14,      0,      3,      0,      &quot;MODEL&quot;    ],    [      40,      12,      0,      3,      1,      &quot;CONDITIONING&quot;    ],    [      42,      20,      0,      12,      1,      &quot;IMAGE&quot;    ]  ],  &quot;groups&quot;: [    &#123;      &quot;title&quot;: &quot;SVD&quot;,      &quot;bounding&quot;: [        1453,        297,        2203,        1015      ],      &quot;color&quot;: &quot;#8A8&quot;,      &quot;font_size&quot;: 24    &#125;,    &#123;      &quot;title&quot;: &quot;txt2img&quot;,      &quot;bounding&quot;: [        332,        442,        1106,        635      ],      &quot;color&quot;: &quot;#3f789e&quot;,      &quot;font_size&quot;: 24    &#125;  ],  &quot;config&quot;: &#123;&#125;,  &quot;extra&quot;: &#123;&#125;,  &quot;version&quot;: 0.4&#125;</code></pre><h1 id="分区域写提示词"><a href="#分区域写提示词" class="headerlink" title="分区域写提示词"></a>分区域写提示词</h1><pre><code class="lang-json">&#123;  &quot;last_node_id&quot;: 190,  &quot;last_link_id&quot;: 178,  &quot;nodes&quot;: [    &#123;      &quot;id&quot;: 180,      &quot;type&quot;: &quot;ConditioningSetArea&quot;,      &quot;pos&quot;: [        956,        3076      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 317.4000244140625,        &quot;1&quot;: 154      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 13,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 153,          &quot;label&quot;: &quot;conditioning&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            162          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;二张视图的整体区域&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningSetArea&quot;      &#125;,      &quot;widgets_values&quot;: [        2048,        1536,        0,        0,        1      ]    &#125;,    &#123;      &quot;id&quot;: 124,      &quot;type&quot;: &quot;ConditioningSetArea&quot;,      &quot;pos&quot;: [        955,        3285      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 317.4000244140625,        &quot;1&quot;: 154      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 12,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 36,          &quot;label&quot;: &quot;conditioning&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            165          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;三张视图的整体区域&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningSetArea&quot;      &#125;,      &quot;widgets_values&quot;: [        3072,        1536,        0,        0,        1      ]    &#125;,    &#123;      &quot;id&quot;: 118,      &quot;type&quot;: &quot;ConditioningSetArea&quot;,      &quot;pos&quot;: [        943,        2383      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 317.4000244140625,        &quot;1&quot;: 154      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 10,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 30,          &quot;label&quot;: &quot;conditioning&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            29          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;控制第二张视图的区域&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningSetArea&quot;      &#125;,      &quot;widgets_values&quot;: [        1024,        1536,        1024,        0,        0.8      ]    &#125;,    &#123;      &quot;id&quot;: 116,      &quot;type&quot;: &quot;ConditioningSetArea&quot;,      &quot;pos&quot;: [        943,        2091      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 317.4000244140625,        &quot;1&quot;: 154      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 9,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 27,          &quot;label&quot;: &quot;conditioning&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            28,            171          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;控制第一张视图的区域&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningSetArea&quot;      &#125;,      &quot;widgets_values&quot;: [        1024,        1536,        0,        0,        0.8      ]    &#125;,    &#123;      &quot;id&quot;: 173,      &quot;type&quot;: &quot;Logic Boolean&quot;,      &quot;pos&quot;: [        -142,        2673      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 78      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 0,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;NUMBER&quot;,          &quot;type&quot;: &quot;NUMBER&quot;,          &quot;links&quot;: [            174,            176          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;NUMBER&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;INT&quot;,          &quot;type&quot;: &quot;INT&quot;,          &quot;links&quot;: null,          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;INT&quot;        &#125;      ],      &quot;title&quot;: &quot;是否是三张视图&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;Logic Boolean&quot;      &#125;,      &quot;widgets_values&quot;: [        1      ]    &#125;,    &#123;      &quot;id&quot;: 120,      &quot;type&quot;: &quot;ConditioningSetArea&quot;,      &quot;pos&quot;: [        953,        2605      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 317.4000244140625,        &quot;1&quot;: 154      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 11,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 33,          &quot;label&quot;: &quot;conditioning&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            32          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;控制第三张视图的区域&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningSetArea&quot;      &#125;,      &quot;widgets_values&quot;: [        1024,        1536,        2048,        0,        0.8      ]    &#125;,    &#123;      &quot;id&quot;: 183,      &quot;type&quot;: &quot;ConditioningSetArea&quot;,      &quot;pos&quot;: [        960,        2873      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 317.4000244140625,        &quot;1&quot;: 154      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 14,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 160,          &quot;label&quot;: &quot;conditioning&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            161          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;一张视图的整体区域&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningSetArea&quot;      &#125;,      &quot;widgets_values&quot;: [        1024,        1536,        0,        0,        1      ]    &#125;,    &#123;      &quot;id&quot;: 117,      &quot;type&quot;: &quot;ConditioningCombine&quot;,      &quot;pos&quot;: [        1358,        2096      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 15,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_1&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 28,          &quot;label&quot;: &quot;conditioning_1&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_2&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 29,          &quot;label&quot;: &quot;conditioning_2&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            172          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;结合第一张视图与第二张视图&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningCombine&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 187,      &quot;type&quot;: &quot;Conditioning Input Switch&quot;,      &quot;pos&quot;: [        1409,        2207      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 66      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 17,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_a&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 172,          &quot;label&quot;: &quot;conditioning_a&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_b&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 171,          &quot;label&quot;: &quot;conditioning_b&quot;,          &quot;slot_index&quot;: 1        &#125;,        &#123;          &quot;name&quot;: &quot;boolean_number&quot;,          &quot;type&quot;: &quot;NUMBER&quot;,          &quot;link&quot;: 173,          &quot;label&quot;: &quot;boolean_number&quot;,          &quot;slot_index&quot;: 2        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            170,            175          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;Conditioning Input Switch&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 119,      &quot;type&quot;: &quot;ConditioningCombine&quot;,      &quot;pos&quot;: [        1788,        2221      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 19,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_1&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 170,          &quot;label&quot;: &quot;conditioning_1&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_2&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 32,          &quot;label&quot;: &quot;conditioning_2&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            168          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;结合第二张视图与第三张视图&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningCombine&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 186,      &quot;type&quot;: &quot;Conditioning Input Switch&quot;,      &quot;pos&quot;: [        1988,        2316      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 66      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 20,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_a&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 168,          &quot;label&quot;: &quot;conditioning_a&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_b&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 175,          &quot;label&quot;: &quot;conditioning_b&quot;,          &quot;slot_index&quot;: 1        &#125;,        &#123;          &quot;name&quot;: &quot;boolean_number&quot;,          &quot;type&quot;: &quot;NUMBER&quot;,          &quot;link&quot;: 174,          &quot;label&quot;: &quot;boolean_number&quot;,          &quot;slot_index&quot;: 2        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            169          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;Conditioning Input Switch&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 122,      &quot;type&quot;: &quot;ConditioningCombine&quot;,      &quot;pos&quot;: [        2367,        2318      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 21,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_1&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 169,          &quot;label&quot;: &quot;conditioning_1&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_2&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 166,          &quot;label&quot;: &quot;conditioning_2&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            156          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;结合控制整体区域&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningCombine&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 125,      &quot;type&quot;: &quot;ConditioningCombine&quot;,      &quot;pos&quot;: [        2734,        2402      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 46      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 22,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_1&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 156,          &quot;label&quot;: &quot;conditioning_1&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_2&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 38,          &quot;label&quot;: &quot;conditioning_2&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;结合控制整体&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;ConditioningCombine&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 142,      &quot;type&quot;: &quot;CLIPSetLastLayer&quot;,      &quot;pos&quot;: [        9,        2275      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 58      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 1,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: null,          &quot;label&quot;: &quot;clip&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CLIP&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;links&quot;: [            66,            67,            68,            69,            70,            71          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CLIP&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPSetLastLayer&quot;      &#125;,      &quot;widgets_values&quot;: [        -2      ]    &#125;,    &#123;      &quot;id&quot;: 133,      &quot;type&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;,      &quot;pos&quot;: [        488,        2093      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 4,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 67,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            27          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;第一张视图的提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;,        &quot;none&quot;,        &quot;A1111&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 134,      &quot;type&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;,      &quot;pos&quot;: [        488,        2383      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 5,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 68,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            30          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;第二张视图的提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;,        &quot;none&quot;,        &quot;A1111&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 135,      &quot;type&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;,      &quot;pos&quot;: [        479,        2640      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 6,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 69,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            33          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;第三张视图的提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;,        &quot;none&quot;,        &quot;A1111&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 136,      &quot;type&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;,      &quot;pos&quot;: [        474,        2916      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 7,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 70,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            36,            153,            160          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;控制整体区域的提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;,        &quot;none&quot;,        &quot;A1111&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 137,      &quot;type&quot;: &quot;CLIPTextEncode&quot;,      &quot;pos&quot;: [        471,        3233      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 8,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 71,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            38          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;        &#125;      ],      &quot;title&quot;: &quot;使整张图统一,可以不填提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;CLIPTextEncode&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;      ]    &#125;,    &#123;      &quot;id&quot;: 184,      &quot;type&quot;: &quot;Conditioning Input Switch&quot;,      &quot;pos&quot;: [        1337,        2941      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 66      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 16,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_a&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 162,          &quot;label&quot;: &quot;conditioning_a&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_b&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 161,          &quot;label&quot;: &quot;conditioning_b&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;boolean_number&quot;,          &quot;type&quot;: &quot;NUMBER&quot;,          &quot;link&quot;: 163,          &quot;label&quot;: &quot;boolean_number&quot;,          &quot;slot_index&quot;: 2        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            164          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;Conditioning Input Switch&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 185,      &quot;type&quot;: &quot;Conditioning Input Switch&quot;,      &quot;pos&quot;: [        1756,        2957      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 342.5999755859375,        &quot;1&quot;: 66      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 18,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;conditioning_a&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 165,          &quot;label&quot;: &quot;conditioning_a&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;conditioning_b&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;link&quot;: 164,          &quot;label&quot;: &quot;conditioning_b&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;boolean_number&quot;,          &quot;type&quot;: &quot;NUMBER&quot;,          &quot;link&quot;: 176,          &quot;label&quot;: &quot;boolean_number&quot;,          &quot;slot_index&quot;: 2        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [            166          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;Conditioning Input Switch&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: 176,      &quot;type&quot;: &quot;Logic Boolean&quot;,      &quot;pos&quot;: [        -148,        2509      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 315,        &quot;1&quot;: 78      &#125;,      &quot;flags&quot;: &#123;        &quot;collapsed&quot;: false      &#125;,      &quot;order&quot;: 2,      &quot;mode&quot;: 0,      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;NUMBER&quot;,          &quot;type&quot;: &quot;NUMBER&quot;,          &quot;links&quot;: [            163,            173          ],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;NUMBER&quot;,          &quot;slot_index&quot;: 0        &#125;,        &#123;          &quot;name&quot;: &quot;INT&quot;,          &quot;type&quot;: &quot;INT&quot;,          &quot;links&quot;: null,          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;INT&quot;        &#125;      ],      &quot;title&quot;: &quot;是否是两张视图&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;Logic Boolean&quot;      &#125;,      &quot;widgets_values&quot;: [        0      ]    &#125;,    &#123;      &quot;id&quot;: 140,      &quot;type&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;,      &quot;pos&quot;: [        487,        1832      ],      &quot;size&quot;: &#123;        &quot;0&quot;: 400,        &quot;1&quot;: 200      &#125;,      &quot;flags&quot;: &#123;&#125;,      &quot;order&quot;: 3,      &quot;mode&quot;: 0,      &quot;inputs&quot;: [        &#123;          &quot;name&quot;: &quot;clip&quot;,          &quot;type&quot;: &quot;CLIP&quot;,          &quot;link&quot;: 66,          &quot;label&quot;: &quot;clip&quot;        &#125;      ],      &quot;outputs&quot;: [        &#123;          &quot;name&quot;: &quot;CONDITIONING&quot;,          &quot;type&quot;: &quot;CONDITIONING&quot;,          &quot;links&quot;: [],          &quot;shape&quot;: 3,          &quot;label&quot;: &quot;CONDITIONING&quot;,          &quot;slot_index&quot;: 0        &#125;      ],      &quot;title&quot;: &quot;反向提示词&quot;,      &quot;properties&quot;: &#123;        &quot;Node name for S&amp;R&quot;: &quot;BNK_CLIPTextEncodeAdvanced&quot;      &#125;,      &quot;widgets_values&quot;: [        &quot;&quot;,        &quot;none&quot;,        &quot;comfy&quot;      ]    &#125;  ],  &quot;links&quot;: [    [      27,      133,      0,      116,      0,      &quot;CONDITIONING&quot;    ],    [      28,      116,      0,      117,      0,      &quot;CONDITIONING&quot;    ],    [      29,      118,      0,      117,      1,      &quot;CONDITIONING&quot;    ],    [      30,      134,      0,      118,      0,      &quot;CONDITIONING&quot;    ],    [      32,      120,      0,      119,      1,      &quot;CONDITIONING&quot;    ],    [      33,      135,      0,      120,      0,      &quot;CONDITIONING&quot;    ],    [      36,      136,      0,      124,      0,      &quot;CONDITIONING&quot;    ],    [      38,      137,      0,      125,      1,      &quot;CONDITIONING&quot;    ],    [      66,      142,      0,      140,      0,      &quot;CLIP&quot;    ],    [      67,      142,      0,      133,      0,      &quot;CLIP&quot;    ],    [      68,      142,      0,      134,      0,      &quot;CLIP&quot;    ],    [      69,      142,      0,      135,      0,      &quot;CLIP&quot;    ],    [      70,      142,      0,      136,      0,      &quot;CLIP&quot;    ],    [      71,      142,      0,      137,      0,      &quot;CLIP&quot;    ],    [      153,      136,      0,      180,      0,      &quot;CONDITIONING&quot;    ],    [      156,      122,      0,      125,      0,      &quot;CONDITIONING&quot;    ],    [      160,      136,      0,      183,      0,      &quot;CONDITIONING&quot;    ],    [      161,      183,      0,      184,      1,      &quot;CONDITIONING&quot;    ],    [      162,      180,      0,      184,      0,      &quot;CONDITIONING&quot;    ],    [      163,      176,      0,      184,      2,      &quot;NUMBER&quot;    ],    [      164,      184,      0,      185,      1,      &quot;CONDITIONING&quot;    ],    [      165,      124,      0,      185,      0,      &quot;CONDITIONING&quot;    ],    [      166,      185,      0,      122,      1,      &quot;CONDITIONING&quot;    ],    [      168,      119,      0,      186,      0,      &quot;CONDITIONING&quot;    ],    [      169,      186,      0,      122,      0,      &quot;CONDITIONING&quot;    ],    [      170,      187,      0,      119,      0,      &quot;CONDITIONING&quot;    ],    [      171,      116,      0,      187,      1,      &quot;CONDITIONING&quot;    ],    [      172,      117,      0,      187,      0,      &quot;CONDITIONING&quot;    ],    [      173,      176,      0,      187,      2,      &quot;NUMBER&quot;    ],    [      174,      173,      0,      186,      2,      &quot;NUMBER&quot;    ],    [      175,      187,      0,      186,      1,      &quot;CONDITIONING&quot;    ],    [      176,      173,      0,      185,      2,      &quot;NUMBER&quot;    ]  ],  &quot;groups&quot;: [],  &quot;config&quot;: &#123;&#125;,  &quot;extra&quot;: &#123;&#125;,  &quot;version&quot;: 0.4&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作流的参考方法&quot;&gt;&lt;a href=&quot;#工作流的参考方法&quot; class=&quot;headerlink&quot; title=&quot;工作流的参考方法&quot;&gt;&lt;/a&gt;工作流的参考方法&lt;/h1&gt;&lt;p&gt;方法一:将图片拖拽进ComfyUI中&lt;br&gt;方法二:复制json内容粘贴至ComfyUI&lt;/</summary>
      
    
    
    
    <category term="AI" scheme="http://example.com/categories/AI/"/>
    
    
    <category term="ComfyUI" scheme="http://example.com/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>MaxScript</title>
    <link href="http://example.com/2024/01/06/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-MaxScript/"/>
    <id>http://example.com/2024/01/06/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-MaxScript/</id>
    <published>2024-01-06T07:43:00.000Z</published>
    <updated>2024-07-27T18:58:06.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何阅读帮助文档"><a href="#如何阅读帮助文档" class="headerlink" title="如何阅读帮助文档"></a>如何阅读帮助文档</h1><p>文档地址:<a href="https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=GUID-F039181A-C072-4469-A329-AE60FF7535E7">https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=GUID-F039181A-C072-4469-A329-AE60FF7535E7</a><br>max的各种object类的描述的地址:<a href="https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=GUID-F159E458-15C2-4CDC-B926-0FB7EFB810DB">https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=GUID-F159E458-15C2-4CDC-B926-0FB7EFB810DB</a><br>文档的描述约定:<br><img src="/.com//image-1.png" alt="Alt text"><br>尖括号中的词语是对内容的规则定义<br>方括号中的内容是可选的<br>被竖线分割的的内容是在其中选择一个<br>大括号的内容可以重复零次或多次<br>大括号+意思是里的内容可以重复一次或多次<br>::= 可以理解为一个符号,右边描述了左边名称的定义,例如 <digit> ::= 1|2|3|4 意思是 digit可以取1,2,3,4一共四个数</digit></p><h1 id="VScode-for-MaxScript"><a href="#VScode-for-MaxScript" class="headerlink" title="VScode for MaxScript"></a>VScode for MaxScript</h1><ol><li>搜索Language MaxScript插件并安装</li><li>点击下载:<a href="https://github.com/techartorg/MXSPyCOM/releases/download/1.14/MXSPyCOM.zip">MXSPyCOM</a>,<a href="https://github.com/techartorg/MXSPyCOM">可以参考的GitHub地址</a></li><li>解压文件,将MXSPyCOM.exe放入到”C:\Program Files\MXSPyCOM\MXSPyCOM.exe”,将initialize_COM_server.ms放入到”C:\Program Files\Autodesk\3ds Max 2024\scripts\Startup\initialize_COM_server.ms”</li><li><a href="https://github.com/techartorg/MXSPyCOM/wiki/Visual-Studio-Code">进行vscode的配置</a><br>配置的关键:<br>将以下内容放到task里面<pre><code class="lang-json">&#123;         &quot;label&quot;: &quot;Execute Script in 3ds Max&quot;,         &quot;type&quot;: &quot;shell&quot;,         &quot;command&quot;: &quot;C:\\Program Files\\MXSPyCOM\\MXSPyCOM.exe&quot;,         &quot;args&quot;: [             &quot;-s&quot;,             &quot;$&#123;file&#125;&quot;         ],         &quot;presentation&quot;: &#123;             &quot;echo&quot;: false,             &quot;reveal&quot;: &quot;never&quot;,             &quot;focus&quot;: false,             &quot;panel&quot;: &quot;dedicated&quot;         &#125;,         &quot;problemMatcher&quot;: [],&#125;</code></pre>然后输入&gt;key进入快捷键绑定<br>填入内容,将ctrl+e与运行任务进行绑定.<pre><code class="lang-json">[ &#123;     &quot;key&quot;: &quot;ctrl+e&quot;,     &quot;command&quot;: &quot;workbench.action.tasks.runTask&quot;,     &quot;args&quot;: &quot;Execute Script in 3ds max&quot; &#125;,]</code></pre><h1 id="MaxScript的语法"><a href="#MaxScript的语法" class="headerlink" title="MaxScript的语法"></a>MaxScript的语法</h1>```<br>— 数学表达式</li></ol><ul><li><ul><li><ul><li>/ ^ as(类型转换)<br>— 比较表达式<br>== != &gt; &lt; &gt;= &lt;=<br>— 逻辑表达式<br>or and not<br>— 判断<br>if … then … else …<br>if … do …<br>— case语句 语法一<br>for obj in geometry do<br>(<br>local d = distance obj $cam1<br>case of<br>(<br>  (d &lt;= 50):  obj.segs = 40<br>  (d &lt;= 120): obj.segs = 25<br>  (d &lt;= 250): obj.segs = 10<br>  default:    obj.segs = 5<br>)<br>)<br>— case语句 语法二<br>newObj = case cloneType.state of<br>   (<pre><code>  1: instance pickedObj  2: reference pickedObj  3: copy pickedObj</code></pre>   )<br>— while 循环<br>while … do …<br>— for 循环<br>写法1,遍历数字: for i = 1 to 10 do print i<br>写法2,遍历数组: for item in [able] do x = x+item.height<br>写法3,在for循环里判断然后放到数组中: bigones = for obj in $Box* where obj.height &gt; 100 collect obj</li></ul></li></ul></li></ul><p>— continue 同python的continue<br>— exit 同python的break<br>— try 异常处理<br>try … catch …</p><pre><code># MaxScript的UI## 控件类型与介绍文档地址:https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=GUID-E421933F-958E-42FD-80A1-D66F2A2C0A06参考图片:![Alt text](image-12.png)### 各种button的区别:button:最基础的按钮,有点击事件checkbutton:点一次和点两次的状态不同mapbutton:单击按钮时会弹出3dsmax的贴图浏览器对话框materialbutton:单击按钮时会弹出3dsmax的材质浏览器对话框pickbutton:单击按钮后进入对象拾取模式,再单击一个场景对象后自动退出拾取模式或右键单击取消拾取模式button举例:</code></pre><p>rollout test_buttons “Testing Buttons”<br>(<br>    button theButton iconName:@”PolyTools\TransformTools\PB_CW” iconSize:[20,20]<br>    button theBorderlessButton “I am a button, too!” border:false<br>    on theButton pressed do<br>    messagebox “Remember: Never press unknown buttons!”<br>)<br>createDialog test_buttons 150 60</p><pre><code>checkbutton举例:</code></pre><p>rollout test “Test”<br>(<br>checkbutton setup “Setup” checked:true tooltip:”Opens setup panels”<br>on setup changed state do<br>if state == on then<br>    openRollout setup_pan<br>else<br>    closeRollout setup_pan<br>)</p><pre><code>mapbutton举例:</code></pre><p>rollout test_mapbutton “Background”<br>(<br>    label sbm_lbl “Background Map:”<br>    mapbutton choosemap “&lt;<none>&gt;” tooltip:”Select Background Map” width:120<br>    on choosemap picked texmap do<br>    (<br>    environmentmap = texmap<br>    choosemap.text=classof texmap as string<br>    )<br>)<br>createDialog test_mapbutton</none></p><pre><code>materialbutton举例:</code></pre><p>Rollout assign_material “Assign Material”<br>(<br>    label smtl_lbl “Set selected object’s material to:”<br>    materialbutton choosemtl “Pick Material”<br>    on choosemtl picked mtl do<br>    (<br>    print mtl<br>    if $ != undefined do $.material=mtl<br>    )<br>)<br>createDialog assign_material</p><pre><code>pcikbutton举例:</code></pre><p>rollout pick_box_test “Pick Box Test”<br>(<br>—filter all objects of class Box:<br>fn box_filt obj = classof obj == Box<br>—Pickbutton to select a Box from the scene<br>pickbutton chooseit “Select Box” width:140 filter:box_filt<br>—If the user picked an object, then<br>on chooseit picked obj do<br>(<br>—see if the user did not cancel the picking…<br>if obj != undefined do<br>(<br>—if he did not, make the box’s wireframe red:<br>obj.wirecolor = red<br>—and display the name of the object on the button:<br>chooseit.text = obj.name<br>)<br>)—end on<br>)—end rollout<br>createDialog pick_box_test</p><pre><code># 让max启动时就执行对应的脚本参考官方文档:https://help.autodesk.com/view/MAXDEV/2024/ENU/?guid=GUID-615D14FB-0F2D-4801-B381-1128C4128C70## 使用startup.ms文件通过文档可知MAXScript首先按列出的顺序在以下目录中搜索名为startup.ms 的文件然后运行:用户脚本目录,用户启动脚本目录,3ds Max 系统脚本目录,3ds Max 系统启动脚本目录.用户脚本、系统脚本、用户启动脚本和系统启动脚本分别对应于 #userscripts 、 #systemscripts 、 #userstartupscripts 和 #startupScripts 的位置。可以通过命令:GetDir &lt;文件类型名字&gt;来获取路径举例:GetDir #startupScripts返回:C:\Program Files\Autodesk\3ds Max 2024\scripts\startup## 使用命令行启动max,并伴随对应脚本文件```shell# 首先先cd到对应的max目录中cd C:\Program Files\Autodesk\3ds Max 2024# 参考以下命令打开对应max文件并启动对应脚本3dsmax.exe E:\3dsmaxTest\a.max -U MAXScript D:\MaxScript\TestMaxScript.ms</code></pre><h1 id="使用MaxScript处理数据"><a href="#使用MaxScript处理数据" class="headerlink" title="使用MaxScript处理数据"></a>使用MaxScript处理数据</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p>filterString \<string> \<token_string><br><strong>注意:</strong> token_string,也就是第二个的字符串中的每个字符都会被识别为分割<br>点,因此第二个字符串建议只有单字符</token_string></string></p><pre><code>filterString &quot;MAX Script, is-dead-funky&quot; &quot;, -&quot;  -- 返回#(&quot;MAX&quot;, &quot;Script&quot;, &quot;is&quot;, &quot;dead&quot;, &quot;funky&quot;)filterString &quot;MAX Script, is-dead-funky&quot; &quot;-&quot;    -- 返回#(&quot;MAX Script, is&quot;, &quot;dead&quot;, &quot;funky&quot;)</code></pre><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><p>replace \<string> \<from_integer> \<length_integer> \<new_string></new_string></length_integer></from_integer></string></p><pre><code>s = &quot;1234567890&quot;s1=replace s 5 3 &quot;inserted string&quot; --返回&quot;1234inserted string890&quot;</code></pre><h3 id="字符串的切片"><a href="#字符串的切片" class="headerlink" title="字符串的切片"></a>字符串的切片</h3><p>substring \<string> \<from_integer> \<length_integer></length_integer></from_integer></string></p><pre><code>s = &quot;Balerofon&quot;ss = substring s 5 3 --返回&quot;rof&quot;ss = substring s 5 -1 --返回&quot;rofon&quot;ss = substring s 5 100 --返回&quot;rofon&quot;</code></pre><h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>matchPattern \<string> pattern:\<pattern_string> [ ignoreCase:\<boolean> ]<br>如果字符串\<string>与通配符 pattern:匹配，返回 True，否则返回 False。如果没有指定<br>参数 ignoreCase:False，比较是大小写不敏感的。</string></boolean></pattern_string></string></p><pre><code>s = &quot;text1&quot;matchPattern s pattern : &quot;text?&quot; --返回 TruematchPattern s pattern : &quot;T*&quot; --返回 TruematchPattern s pattern : &quot;T*&quot; ignoreCase:False --返回 FalsematchPattern s pattern : &quot;s*&quot; --返回 False</code></pre><h2 id="Point3矢量"><a href="#Point3矢量" class="headerlink" title="Point3矢量"></a>Point3矢量</h2><p>Point3 类定义了三维空间的点，也称为三维矢量，包含三个 Float 类数。<br>[320,240] — 定义2维点<br>[10,20,30] — 定义3维点<br>有x,y,z三个属性来代表xyz坐标</p><pre><code>-- 定义两个point3类型的对象vector1 = [10,20,30]vector2 = [20,30,40]-- 返回矢量的长度length vector1-- 返回两个矢量的点积dot vector1 vector2-- 返回两个矢量的叉积cross vector1 vector2-- 返回矢量的标准矢量normalize vector1-- 返回指定两点之间的距离distance vector1 vector2-- 返回指定两点之间的随机点random vector1 vector2</code></pre><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><p>定义数组的语法是: #(数组内容)<br>用户可以将一个对象集和通配符路径名用 as 操作符转化为一个数组。这相当于给对象集或与路径名匹配的当前对象拍了一张“快照”，这样可以在随后的脚本里操作集合里的对象，而不用担心对象集改变。这种功能与 3ds max 用户界面下的 Named Selection Sets 按钮类似。如果用户删除了数组里的某一对象，而在随后的脚本里再对数组进行映射操作，系统会给出一个错误信息。<br>例子：<br>sel1 = Selection as array<br>Boxes_at_load = $Box<em> as array<br>snap_children = $torso…</em> as array<br>original_cameras = cameras as array </p><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ol><li>append\<array>\<value><br>将指定值插入到数组的最后</value></array></li><li>deleteItem\<array>\<number><br>从数组里删除指定序号的元素</number></array></li><li>join\<array>\<collection><br>将变量\<collection>里的所有元素添加到数组\<array>的后面</array></collection></collection></array></li><li>sort\<array><br>按升序对数组进行排序.所有数组的元素必须具有可比性</array></li><li>findItem\<array>\<value><br>在数组里查找指定目标对象,返回第一次找到的元素序号,如果没有找到就返回0,Point3类值与String类值如果内容相同,系统也认为欸它们是匹配的.</value></array></li><li>insertItem\<value>\<array>\<integer><br>在数组的指定位置\<integer>插入指定值\<value></value></integer></integer></array></value></li><li>amin(\<array>|{value})<br>返回数组或指定值序列里的最小值.如果数组长度为0或没有指定值序列,返回值undefined</array></li><li>amax(\<array>|{value})<br>返回数组或指定值序列里的最大值.如果数组长度为0或没有指定值序列,返回值undefined<h1 id="批量生成球"><a href="#批量生成球" class="headerlink" title="批量生成球"></a>批量生成球</h1><img src="/.com//image.png" alt="Alt text"><br>```MAXScript<br>— UI的定义<br>rollout SphereTool “Spheres Creator”<br>(<br> — 创建UI<br> spinner count “Number: “ type:#integer range:[1,100,10]<br> spinner growth “Radius growth: “ range:[1,100,10]<br> button create “Create Spheres”<br> — UI事件<br> on create pressed do<pre><code> for i in 1 to count.value do     sphere radius:(i*growth.value) position:[i^2*growth.value,0,0]</code></pre>)<br>— 创建对应UI窗口<br>createDialog SphereTool width:200</array></li></ol><pre><code># 函数的写法## 一般函数(生成一排球体)参数:count growth作用:生成一排球体</code></pre><p>— 函数的定义<br>function createSphere count growth =<br>(<br>    for i in 1 to count do<br>        sphere radius:(i<em>growth) position:[i^2</em>growth,0,0]<br>)<br>— 函数的调用<br>createSphere 25 10</p><pre><code>## 带默认值的函数(渲染场景内所有摄像机)参数:label,size,frames,folder.  其中size与folder有默认值,frames意思是可选的,可以传参数也可以不传,不传时为unsupplied作用:寻找场景内所有摄像机并进行渲染</code></pre><p>— 函数的定义<br>function snapCams label size:[320,240] frames: folder:”C:/testimages/“ =<br>(<br>    for c in cameras do<br>    (<br>        local fname = folder + label + “-“ + c.name<br>        if frames == unsupplied then<br>            render camera:c outputFile:(fname+”.jpg”) outputSize:size<br>        else<br>            render camera:c frameRange:frames \<br>                   outputFile:(fname+”.avi”) outputSize:size<br>    )<br>)<br>— 函数的调用<br>snapCams “phase1” size:[640,480]</p><pre><code>## 有返回值的函数(创建材质的函数)参数:baseColor cellSize作用:通过函数创建材质并返回这里函数调用是给模型Box001和Box002赋予材质</code></pre><p>— 函数的定义<br>function cellMaterial baseColor cellSize =<br>(<br>    local mtl = standardMaterial specularLevel:55 glossiness:35,<br>          map = cellular cellColor:baseColor size:cellSize fractal:on<br>    mtl.diffusemAP = map<br>    return mtl<br>)<br>— 函数调用<br>$Box001.material = cellMaterial red 25<br>$Box002.material = cellMaterial blue 50</p><pre><code>## 递归这里举例是找名字叫Box001的模型,自动赋予材质,然后会找Box001的子模型并赋予材质(材质的参数也会自动发生变化)</code></pre><p>— 上一标题的函数的定义<br>function cellMaterial baseColor cellSize =<br>(<br>    local mtl = standardMaterial specularLevel:55 glossiness:35,<br>          map = cellular cellColor:baseColor size:cellSize fractal:on<br>    mtl.diffusemAP = map<br>    return mtl<br>)<br>— 函数的定义(写function和fn都可以,一样的效果)<br>fn mtlToChildren obj cellColor cellSize =<br>(<br>    — 设置材质给obj<br>    obj.material = cellMaterial cellColor cellSize<br>    — 循环遍历子obj<br>    for child in obj.children do<br>        mtlToChildren child (cellColor + [75,0,0]) (cellSize - 3)<br>)<br>— 函数调用<br>mtlToChildren $Box001 blue 10</p><pre><code># 得到变量的类型</code></pre><p>classOf 23 — Integer<br>classOf “foo” — String<br>classOf &amp;ball  — &amp;phere</p><pre><code># 得到相关类名称与方法MAXWrapper是max的所有object的父类(maxscript里称为超类)</code></pre><p>showClass “sphere” — 显示sphere开头的类<br>showClass “sphere<em>.</em>“ — 显示sphere开头的类以及对应的方法</p><p>— 通过对象或路径名得到其所具有的方法<br>b = box()<br>showproperties b<br>showproperties $Box001</p><pre><code># 集合和数组数组的下标是从1开始的,不是0集合是没有重复元素的,集合是无序的定义数组: a = #(1,3,5,7,9)定义集合: a = #&#123;1,2,3,4,5&#125;修改数组的第三个数的值: a[3] = five向数组追加内容: append a 11   输出的数值:1,3,,5,7,9,11通过表达式创建数组: 遍历1到5,然后对其进行开平方并存入roots的数组中.roots = for i in 1 to 5 collect sqrt i遍历的同时进行判断:smallSpheres = for obj in geometry    where classOf obj == sphere and obj.numFaces &lt; 50    collect obj# 生成排列好的球体(增强版)界面:![Alt text](image-2.png)可以随时通过UI数值的调整来实时改变球体的数量和大小```maxScriptrollout SphereTool3 &quot;Spheres Creator 3&quot;(    local spheres = #()    spinner count &quot;Number: &quot; type:#integer range:[1,100,10]    spinner growth &quot;Radius growth :&quot; range:[1,100,10]    button create &quot;Create Spheres&quot;    button del &quot;Delete Spheres&quot;    on create pressed do        spheres = for i in 1 to count.value collect            sphere radius:(i*growth.value) position:[i^2*growth.value,0,0]    on del pressed do delete spheres    on growth changed val do        for i in 1 to spheres.count do        (            spheres[i].radius = i * val            spheres[i].pos = [i ^ 2 * val, 0, 0]        )    on count changed val do    (        delete spheres        create.pressed()    ))create dialog SphereTool3 width: 300</code></pre><h1 id="类集合数据类型"><a href="#类集合数据类型" class="headerlink" title="类集合数据类型"></a>类集合数据类型</h1><h2 id="对象集合"><a href="#对象集合" class="headerlink" title="对象集合"></a>对象集合</h2><p>这些对象集合是动态刷新的<br>geometry 指定类型的3dsmax对象<br>lights<br>cameras<br>helpers<br>shapes<br>systems<br>spacewarps<br>objects 所有场景对象<br>selection 获得当前选择的对象并保存为数组</p><p>相关方法:</p><ol><li>clearSelection() 清除当前场景对象选择集</li><li>deselect \<PathName> 将指定对象从当前选择集里去掉</PathName></li><li>select \<PathName> 先解除所有当前选择集,然后选择指定的对象</PathName></li><li>selectMore \<PathName> 将指定对象集添加到当前选择集</PathName></li><li>getCurrentSelection() 返回一个数组，表示当前选择集。本函数相当于函数 Selection as array，但如果场景里有大量的对象，本函数的执行速度会大大快于后者。</li></ol><p>基础对象集合的使用举例<br>举例1:<br>删除距离原点距离大于10000的几何体,使用 as array的作用是防止geometry发生改变而造成的影响<br>for o in geometry as array where (distance o.pos [0,0,0]) &gt; 10000 do delete o<br>举例2:<br><img src="/.com//image-4.png" alt="Alt text"><br>举例3:<br><img src="/.com//image-5.png" alt="Alt text"></p><h2 id="Pathname"><a href="#Pathname" class="headerlink" title="Pathname"></a>Pathname</h2><p>模型可能有层级关系,因此可以用Pathname的方式来得到对应的模型<br>也可以通过类似正则表达式的方式来得到相关模型<br> select $Box002/Box003<br> select $Box<em><br> select $Box001/Box002/</em>  (注意这个的<em>号是只针对Box002的子集这个层级)<br> select $Box001/…/Sphere</em> 通过”…”让*号不止局限于固定的层级</p><p> select $Box00? </p><h1 id="动画脚本"><a href="#动画脚本" class="headerlink" title="动画脚本"></a>动画脚本</h1><p>开启自动k帧模式然后在0和100帧处k帧并设定名字叫Sphere001的模型的位置</p><pre><code>-- 在界面中显示当前max模式为自动k帧模式max tool animmode-- 开启自动k帧 加set的作用是让自动k帧持续开启set animate on-- 进行脚本k帧animation on(    at time 0 $Sphere001.pos = [-100,0,0]    at time 100 $Sphere001.pos = [100,0,0])</code></pre><p>制作一个动画,在名字叫做ball的模型位置处创建一个小球,然后0~100帧中每5帧在ball的模型位置处的16个距离单位下k一帧,然后将ball的半径进行sin趋势的改变</p><pre><code>b2 = sphere radius:3 wireColor:redanimate on for t in 0 to 100 by 5 do    at time t    (        b2.pos = $ball.pos + random [-16,-16,-16] [16,16,16]        $ball.radius = 8+4*sin(720*t/100)    )</code></pre><p>得到10帧和50帧ball名称的模型的位置并计算之间距离<br><img src="/.com//image-3.png" alt="Alt text"><br>其他时间的写法<br><img src="/.com//image-6.png" alt="Alt text"><br>遍历时间<br><img src="/.com//image-7.png" alt="Alt text"><br>通过脚本制作,一个box在两个线之间移动的动画<br><img src="/.com//image-8.png" alt="Alt text"><br>box的长度和方向会跟着线的距离来变化.</p><pre><code>fn railFollow obj line1 line2 u =(    -- u的值代表了从起始点到结束点的值,范围是从0到1,计算方式是(t-start) as float/(end-start) as float    -- 计算位置,方向,距离    -- 通过lengthInterp可以得到在线的u的数值下的点位置    -- 通过nearestPathParam可以得到在线上,离p1点位置最近的点的位置的u值    -- 通过pathInterp可以得到在线上的u的数值下点的位置    -- p1-p2得到p1到p2向量    local p1 = lengthInterp line1 u,    u2 = nearestPathParam line2 p1,    p2 = pathInterp line2 u2,    dv = p2 - p1,    d = distance p1 p2    obj.pos = p1    obj.dir = dv    obj.height = d)start = animationRange.startend = animationRange.endanimate on    for t in start to end by 2 do    (        local u = (t - start) as float / (end - start) as float        at time t railFollow $Box001 $Line001 $Line002 u    )</code></pre><h1 id="控制器的使用"><a href="#控制器的使用" class="headerlink" title="控制器的使用"></a>控制器的使用</h1><p>将box01的高度控制器赋予c<br>c = $box01.height.controller<br>创建一个路径约束控制器<br>pc = path_constraint follow:true bank:true path:$line01<br>创建一个路径约束控制器并赋予一个box的位置参数<br>$Box001.pos.controller = path_constraint follow:true bank:true path:$Line001<br>调整控制器的属性参数<br>$box01.pos.controller.bankAmount -= 0.25<br>复制控制器.<br>因为maxscript的变量赋值是引用赋值,所以第一句两个控制器变量是同一个值<br>使用copy语句以后会创建右边变量的一个副本来赋予左边<br>$box01.scale.controller = $box02.scale.controller<br>$sphere01.radius.controller = copy $box01.height.controller<br>得到控制器上的keys,返回一个数组<br>keys = $box02.height.controller.keys<br>得到keys后对应的可以使用的方法<br>keys = $box02.height.controller.keys<br>keys[1].value = 23<br>for k in keys do fomat “% at %\n” k.value k.time</p><h1 id="通过读取数据文件-设置摄像机在对应key下的位置"><a href="#通过读取数据文件-设置摄像机在对应key下的位置" class="headerlink" title="通过读取数据文件,设置摄像机在对应key下的位置"></a>通过读取数据文件,设置摄像机在对应key下的位置</h1><p>数据文件:<br><img src="/.com//image-9.png" alt="Alt text"></p><pre><code>function stepCam cam dataFile = (    -- 判断摄像机是否有bezier_position控制器,如果有就删掉重新建,否则就直接建    if claasoOf cam.pos.controller != bezier_position then        cam.pos.controller = bezier_position()    else        deleteKeys cam.pos.controller    if classOf cam.target.pos.controller != bezier_position then        cam.target.pos.controller = bezier_postion()    else        deleteKeys cam.target.pos.controller    -- 得到摄像机的控制器    local cc = cam.pos.controller,          tc = cam.target.pos.controller    -- 得到文件    local f = openFile dataFile,          curFrame = 0    -- 读取文件并设置    -- eof 是 MaxScript 中的一个函数，用于检查文件是否已经到达末尾    while not eof f do    (        -- 读取文件三个参数        local camPos = readValue f,              targPos = readValue f,              frames = readValue f        -- 为摄像机的控制器在当前帧进行k帧        local ck = addNewKey cc curFrame,              tk = addNewKey tc curFrame        -- 设置帧的数值还有切线类型为#step        ck.value = camPos; ck.inTangentType = #step        tk.value = targPos;  tk.inTangentType = #step        -- 设置下一个要设置的关键帧        curFrame += frames    )    close f)</code></pre><h1 id="修改器的应用"><a href="#修改器的应用" class="headerlink" title="修改器的应用"></a>修改器的应用</h1><pre><code>-- 创建修改器b = bend angle:45 direction:90-- 将修改器添加到模型上addModifier $box01 b-- 创建修改器并添加到模型上addModifier $box01 (twist angle:90)-- 访问模型上的修改器(假如box01模型上有bend,twist)$box01.bend$box01.twist-- 修改模型上的修改器的数值$box01.bend.angle += 20-- 得到模型上的所有修改器$box01.modifiers</code></pre><h1 id="MaxScript中的循环"><a href="#MaxScript中的循环" class="headerlink" title="MaxScript中的循环"></a>MaxScript中的循环</h1><h2 id="while-…-do-…"><a href="#while-…-do-…" class="headerlink" title="while … do …"></a>while … do …</h2><pre><code>-- 定义一个获取路径名称的函数fn get_pathname obj =(    -- 一直循环找物体的parent,然后设置路径名,当parent为undefined时终止循环    local pathname = obj.name    while obj.parent != undefined do    (        obj = obj.parent        pathname = obj.name + &quot;/&quot; + pathname    )    &quot;&amp;&quot; + pathname)-- 对当前选择的物体进行获取路径名get_pathname $</code></pre><h2 id="continue命令"><a href="#continue命令" class="headerlink" title="continue命令"></a>continue命令</h2><pre><code>for obj in selection do(    -- 通过isKindOf 判断obj是否是Editable_Mesh类或其子类    if not isKindOf obj Editable_Mesh then    (        local msg = &quot;Selected object \&quot;&quot; + obj.name + &quot;\&quot; is not a mesh. \nObject skipped.&quot;        -- 显示信息弹窗        messageBox msg        continue    )    totalObjects += 1    totalFaces += obj.numFaces    totalVerts += obj.numVerts)</code></pre><h2 id="exit命令"><a href="#exit命令" class="headerlink" title="exit命令"></a>exit命令</h2><p>在循环中通过exit命令退出循环,类似于python的break<br><img src="/.com//image-10.png" alt="Alt text"></p><h2 id="return命令"><a href="#return命令" class="headerlink" title="return命令"></a>return命令</h2><p>函数中的循环中使用return命令也可以跳出循环<br><img src="/.com//image-11.png" alt="Alt text"></p><h1 id="coordsys控制坐标空间"><a href="#coordsys控制坐标空间" class="headerlink" title="coordsys控制坐标空间"></a>coordsys控制坐标空间</h1><h2 id="坐标空间的种类"><a href="#坐标空间的种类" class="headerlink" title="坐标空间的种类"></a>坐标空间的种类</h2><pre><code>coordsys word          -- 世界空间coordsys local         -- 局部空间coordsys parent        -- 父对象空间,如果没有父对象则是世界空间coordsys grid          -- 激活的网格的坐标空间coordsys screen        -- 当前激活的视图的坐标空间coordsys &lt;node&gt;        -- 对应node的局部的坐标空间coordsys &lt;matrix3&gt;     -- 基于给定的矩阵来当坐标空间</code></pre><h2 id="coordsys的使用参考"><a href="#coordsys的使用参考" class="headerlink" title="coordsys的使用参考"></a>coordsys的使用参考</h2><pre><code>coordsys local(    move $box3 [100,0,0]    rotate $box4 45 z_axis)</code></pre><h1 id="制作选取线然后生成锁链的工具"><a href="#制作选取线然后生成锁链的工具" class="headerlink" title="制作选取线然后生成锁链的工具"></a>制作选取线然后生成锁链的工具</h1><p><img src="/.com//image-13.png" alt="Alt text"></p><pre><code>rollout ChainMaker &quot;Chain Maker&quot;(    local curve,          chain = #()    -- 定义一个负责筛选物体是否是shape的函数来辅助Pickbutton判断    fn shapesOnly obj = isKindOf obj Shape    group &quot;Controlling Shape&quot;    (        pickbutton pickCurve &quot;Pick Curve&quot; width:100 filter:shapesOnly        label theCurve &quot;-- none --&quot;    )    group &quot;Chain Parameters&quot;    (        -- diam负责控制锁链的大小        -- thickness负责控制锁链的宽厚        spinner diam &quot;Link Diameter: &quot; range:[1,500,12]        spinner thickness &quot;Link Thickness:&quot; range:[0.1,500,2]        colorPicker wireColor &quot;Wire Color:&quot; align:#center    )    button deleteChain &quot;Delete Chain&quot; width:100 enable:false    -- 负责生成锁链    fn updateChain =     (        local len = curvelength curve, -- 曲线的长度              uStep = (diam.value - thickness.value) / len, -- 环的直径减去厚度等于内圈的直径,再除以曲线的长度可以得到一个圆环占曲线长度的比例              up = true,              i  = 1        for u = 0.0 to 1.0 by uStep do        (            if i &gt; chain.count then chain[i] = torus wireColor:wireColor.color            local t = chain[i]            t.radius1 = diam.value / 2              t.radius2 = thickness.value / 2            t.pos = lengthInterp curve u            t.dir = lengthTangent curve u            -- 方向一次x,一次y            coordsys local rotate t 90 (if up then y_axis else x_axis)            up = not up             i += 1        )        for j in i to chain.count do        (            delete chain[i]            deleteItem chain i        )    )    on pickCurve picked obj do    (        curve = obj        theCurve.text = obj.name        deleteChain.enabled = true        updateChain()    )    on deleteChain pressed do (delete chain; chain = #())    on diam changed val do updateChain()    on thickness changed val do updateChain()    on wireColor changed val do chain.wireColor = val)createDialog ChainMaker width:180</code></pre><h1 id="把脚本放到菜单栏中"><a href="#把脚本放到菜单栏中" class="headerlink" title="把脚本放到菜单栏中"></a>把脚本放到菜单栏中</h1><p>例如把刚才做的ChainMaker放到菜单栏中<br>前提已知:做好了一个脚本,脚本中的布局的变量名字叫ChainMaker,脚本另存到了3dmax的根目录的scripts文件夹中<br>创建macroScript:</p><pre><code>macroScript ChainMakerMacro    category:&quot;My Tools&quot;    buttonText:&quot;Chain Maker&quot;    toolTip:&quot;根据曲线创建锁链的工具&quot;(    global ChainMaker    if ChainMaker == undefined or not ChainMaker.open do        fileIn &quot;ChainMaker.ms&quot;)</code></pre><p>创建自定义菜单:<br><img src="/.com//image-14.png" alt="Alt text"></p><h1 id="导出模型信息举例"><a href="#导出模型信息举例" class="headerlink" title="导出模型信息举例"></a>导出模型信息举例</h1><pre><code>function exportMesh obj fileName origin=(    local file = createfile fileName ,          vertStore = #(),          numFrames = (animationRange.end - animationRange.start).frame as integer    format &quot;%, numVerts = %, numFrames = %\n\n&quot; obj.name obj.numVerts numFrames to:file    format &quot;Frame,Vert #, Delta\n&quot; to:file    for f = animationRange.start to animationRange.end do    (    sliderTime = f    for i in 1 to obj.numVerts do    (        local v = coordsys origin getVert obj i        local dv = if vertStore[i] == undefined then v else v - vertStore[i]        vertStore[i] = v        format &quot;%, %, %\n&quot; (f.frame as integer) (i-1) dv to:file    )    )    close file    edit fileName  )exportMesh $Sphere001 &quot;E:/3dsmaxTest/test.txt&quot; $Sphere001</code></pre><h1 id="批量渲染对应文件夹下的max文件然后输出图片"><a href="#批量渲染对应文件夹下的max文件然后输出图片" class="headerlink" title="批量渲染对应文件夹下的max文件然后输出图片"></a>批量渲染对应文件夹下的max文件然后输出图片</h1><p><img src="/.com//image-15.png" alt="Alt text"></p><pre><code>function thumbNailFolder inFolder outFolder thumbType:&quot;.jpg&quot; thumbSize:[320,240] =(    makeDir outFolder    local maxFilePattern = inFolder + &quot;\\*.max&quot;    -- 遍历对应文件夹下的所有max文件    for filePath in getFiles maxFilePattern do    (        local fileName = getFileNameFile filePath,              thumbPath = outFolder + &quot;\\&quot; + fileName + thumbType              format &quot;Rendering thumbnail for %\n&quot; filePath              -- 进入max文件进行渲染,并设置输出路径和输出大小,vfb为off则渲染完不自动打开图像窗口              loadMaxFile filePath              render outputFile:thumbPath outputSize:thumbSize vfb:off    )    resetMaxFile #noPrompt    print(&quot;Done.&quot;))thumbNailFolder &quot;E:/3dsmaxTest&quot; &quot;E:/3dsmaxTest&quot;</code></pre><h1 id="沿着曲线种树的脚本"><a href="#沿着曲线种树的脚本" class="headerlink" title="沿着曲线种树的脚本"></a>沿着曲线种树的脚本</h1><p>前提:需要有名字叫road的曲线,有一个叫ground的地面模型,有一个叫masterTree的树的模型<br><img src="/.com//image-16.png" alt="Alt text"></p><pre><code>numTrees = 500for i in 1 to numTrees do(    local u = random 0.0 1.0,          pos = lengthInterp $road u,          tan = lengthTangent $road u    local offset = random 5 18 * (if i &lt; numTrees / 2 then 1 else -1),          -- cross tan z_axis得到切线与z轴的叉积,然后再乘以偏移值,最终得到偏移的向量          offsetVec = cross tan z_axis * offset,          -- 当前位置加上偏移的向量等于偏移的位置          offsetPos = pos + offsetVec,          -- 以当前偏移的位置的z轴1000的位置处向正下方0,0,-1处生成射线          treeRay = ray [offsetPos.x, offsetPos.y, 1000] [0,0,-1]    -- 定义树的位置和大小,intersectRay $ground treeRay得到的是模型与射线相交地方的法向量,因此再加个.pos得到位置    local treePos = (intersectRay $ground treeRay).pos,          treeScale = [1,1,1] * random 0.2 1.1    -- 创建masterTree这个模型的实例    instance $masterTree pos:treePos scale:treeScale name:&quot;tree&quot;    -- 更新max的视图,来观察到脚本执行时的状态    if mod i 10 == 0 then redrawViews())</code></pre><h1 id="实现进度条功能"><a href="#实现进度条功能" class="headerlink" title="实现进度条功能"></a>实现进度条功能</h1><pre><code>-- 进度条的名字progressStart &quot;test&quot;-- 进度条处理的任务总数loop_count = 500for i in 1 to loop_count do (    if getProgressCancel()     then     (        progressEnd()        exit    )    else    (            -- 这里填写要做的事情        print(i)        -- 更新进度条        percent = i*100/loop_count         progressUpdate percent    )    if percent==100 do progressEnd())</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何阅读帮助文档&quot;&gt;&lt;a href=&quot;#如何阅读帮助文档&quot; class=&quot;headerlink&quot; title=&quot;如何阅读帮助文档&quot;&gt;&lt;/a&gt;如何阅读帮助文档&lt;/h1&gt;&lt;p&gt;文档地址:&lt;a href=&quot;https://help.autodesk.com/view/M</summary>
      
    
    
    
    <category term="DCC工具开发" scheme="http://example.com/categories/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="MaxScript" scheme="http://example.com/tags/MaxScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript快速入门</title>
    <link href="http://example.com/2023/12/10/Geek-JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/12/10/Geek-JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2023-12-10T06:52:00.000Z</published>
    <updated>2024-07-27T18:58:06.880Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>教程链接:<a href="https://www.bilibili.com/video/BV11B4y1U7aH?p=2&amp;vd_source=b1de3fe38e887eb40fc55a5485724480">https://www.bilibili.com/video/BV11B4y1U7aH?p=2&amp;vd_source=b1de3fe38e887eb40fc55a5485724480</a></p></blockquote><h1 id="JavaScript的介绍"><a href="#JavaScript的介绍" class="headerlink" title="JavaScript的介绍"></a>JavaScript的介绍</h1><p>JavaScript是一种编程语言,JavaScript用于在浏览器中建立交互式网页,移动应用程序,实时网络应用程序,命令行工具,游戏.每个浏览器都有JavaScript引擎.将谷歌的引擎取出嵌入到cpp程序当中,这个cpp程序叫做Node.有了Node后可以在浏览器中运行JavaScript代码,把JavaScript代码发送给Node执行.所以JavaScript可以为网络和移动设备构建后端.JavaScript的运行环境叫Node.</p><h1 id="第一次使用JavaScript测试"><a href="#第一次使用JavaScript测试" class="headerlink" title="第一次使用JavaScript测试"></a>第一次使用JavaScript测试</h1><p>按F12进入控制台<br><img src="/.com//image.png" alt="Alt text"><br>输入console.log(“Hello World”)进行日志打印<br>输入alert(“Hello World”)可以在页面中弹窗输出Hello World</p><h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><p>使用vscode</p><ol><li>安装第三方库需要使用nodejs,如果没有nodejs就去官网下载:<a href="https://nodejs.org/en">https://nodejs.org/en</a></li><li>创建一个文件夹,里面先放一个index.html文件</li><li>在index.html文件中输入!加上tab键即可生成html通用模板</li><li>下载live server插件,live server是一个非常轻量级的web服务器,可以使用它为web应用程序提供服务, 下载好以后在html文件上面右键,点击Open with live server即可在浏览器中预览html<h1 id="第一个JavaScript脚本"><a href="#第一个JavaScript脚本" class="headerlink" title="第一个JavaScript脚本"></a>第一个JavaScript脚本</h1>以下代码只需要关注body和/body中间的内容,其他的内容都是模板生成的.h1和/h1里的内容是浏览器的内容.script和/script中的内容是JavaScript脚本的内容,作用是输出HelloWorld日志,可以在浏览器网页中使用F12进入控制台中查看到.<br><img src="/.com//image-1.png" alt="Alt text"><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;script&gt;     // 打印Hello World日志     console.log(&#39;Hello World&#39;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="将JavaScript脚本放到单独的js文件中"><a href="#将JavaScript脚本放到单独的js文件中" class="headerlink" title="将JavaScript脚本放到单独的js文件中"></a>将JavaScript脚本放到单独的js文件中</h1>刚才创建了index.html文件,然后将js代码写到了script字符段里面.还有另一种方法,那就是写到js文件中,然后在html文件中将js文件弄进来.<br>使用方法:<br>1.再创建一个index.js文件,文件名可以随意<br>2.将js代码放到index.js文件中<br>3.然后可以把<pre><code class="lang-html">&lt;script&gt; // 原html文件内容: console.log(&#39;Hello World&#39;);&lt;/script&gt;</code></pre>修改为<pre><code class="lang-html">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code></pre><h1 id="JavaScript的语法"><a href="#JavaScript的语法" class="headerlink" title="JavaScript的语法"></a>JavaScript的语法</h1>```js<br>// 定义一个字符串变量my_name1,并打印<br>let my_name1 = ‘chen’;<br>console.log(my_name);</li></ol><p>// 定义一个字符串常量my_name2<br>const my_name2 = ‘chen’;</p><p>// 检测变量的类型<br>typeof my_name2;</p><p>// 创建一个对象,并修改其内容<br>let person = {<br>    name: ‘chen’,<br>    age: 22,<br>};<br>// 修改对象内容方法一:<br>person.name = ‘ruichen’;<br>// 修改对象内容方法二:<br>person[‘name’] = ‘ruichen’;<br>// 修改对象内容方法三:<br>my_name = ‘name’;<br>person[my_name] = ‘ruichen’;<br>// 输出对象的内容<br>console.log(person.name);</p><p>// 创建一个数组,数组也是一个对象<br>let selectedColors = [‘red’,’blue’];<br>selectedColors[2] = 1;<br>console.log(selectedColors);</p><p>// 定义函数<br>function greet(name){<br>    console.log(‘Hello ‘ + name);<br>}<br>greet(‘ruichen’);</p><p>// 定义有返回值的函数<br>function square(number){<br>    return number * nember;<br>}<br>console.log(square(2));<br>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;教程链接:&lt;a href=&quot;https://www.bilibili.com/video/BV11B4y1U7aH?p=2&amp;amp;vd_source=b1de3fe38e887eb40fc55a5485724480&quot;&gt;https://www.bi</summary>
      
    
    
    
    <category term="Geek" scheme="http://example.com/categories/Geek/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2023/11/30/Geek-Docker/"/>
    <id>http://example.com/2023/11/30/Geek-Docker/</id>
    <published>2023-11-30T06:12:00.000Z</published>
    <updated>2024-07-27T18:58:06.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些网站"><a href="#一些网站" class="headerlink" title="一些网站"></a>一些网站</h1><p>教程网站:<a href="https://www.bilibili.com/video/BV1og4y1q7M4/?p=1&amp;vd_source=b1de3fe38e887eb40fc55a5485724480">狂神说JAVA Docker最新超详细版教程通俗易懂</a><br>linux命令搜索网站: <a href="https://www.yiibai.com/linux/ps.html">https://www.yiibai.com/linux/ps.html</a><br>vim编辑器的使用:<a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p><h1 id="2023-12-20更新-使用WSL在Windows上安装Linux"><a href="#2023-12-20更新-使用WSL在Windows上安装Linux" class="headerlink" title="2023/12/20更新: 使用WSL在Windows上安装Linux"></a>2023/12/20更新: 使用WSL在Windows上安装Linux</h1><h2 id="为什么使用WSL"><a href="#为什么使用WSL" class="headerlink" title="为什么使用WSL"></a>为什么使用WSL</h2><p>通过虚拟机安装linux无法使用本机的gpu,对于一些需要gpu的开源项目无法很好的支持.因此改用WSL在Windows上安装Linux.<br>这样传文件,开发,都更加方便.</p><h2 id="WSL的安装步骤"><a href="#WSL的安装步骤" class="headerlink" title="WSL的安装步骤"></a>WSL的安装步骤</h2><p>文档参考:<a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment">https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment</a><br>前提:安装过程需要科学上网,配置清华镜像加速自行查阅.必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11 才能使用以下命令。如果用的更早的版本,需要自行手动安装.</p><ol><li>右键通过管理员模式启动PowerShell或Windows命令提示符</li><li>安装wsl和Ubuntu<pre><code class="lang-PowerShell">wsl --installwsl --install Ubuntu</code></pre></li><li>重启计算机会自动进入Ubuntu,自行设置账号与密码<br><img src="/.com//image-14.png" alt="Alt text"></li><li>更新和升级包<pre><code class="lang-shell">sudo apt update &amp;&amp; sudo apt upgrade</code></pre><h2 id="vscode与wsl配合使用"><a href="#vscode与wsl配合使用" class="headerlink" title="vscode与wsl配合使用"></a>vscode与wsl配合使用</h2>文档参考:<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode">https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode</a></li><li>更新Ubuntu,添加wget和ca证书.<pre><code class="lang-shell">sudo apt-get updatesudo apt-get install wget ca-certificates</code></pre></li><li>在wsl中通过vscode打开项目<pre><code class="lang-shell">code .</code></pre></li><li>下载wsl扩展<br>下载好以后可以通过左下角与wsl进行连接<br><img src="/.com//image-15.png" alt="Alt text"><br>也可以新建终端,通过shell进行调试<br><img src="/.com//image-16.png" alt="Alt text"></li></ol><h2 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h2><p>文档参考:<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-containers">https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-containers</a><br><strong>通过文档参考中得到的可以查阅的网站:</strong><br>Docker的介绍文档:<a href="https://learn.microsoft.com/zh-cn/training/modules/intro-to-docker-containers/">https://learn.microsoft.com/zh-cn/training/modules/intro-to-docker-containers/</a><br>在Windows上安装Docker桌面:<a href="https://docs.docker.com/desktop/install/windows-install/">https://docs.docker.com/desktop/install/windows-install/</a><br>在vscode中安装Dev Containers:<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers</a><br>在vscode中安装Docker:<a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker">https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker</a></p><h2 id="WSL的一些好用命令"><a href="#WSL的一些好用命令" class="headerlink" title="WSL的一些好用命令"></a>WSL的一些好用命令</h2><p>WSL（Windows Subsystem for Linux）发行版是指在 Windows 上运行的 Linux 操作系统版本。每个 WSL 发行版都包含了一个完整的用户模式环境，就像真实运行的 Linux 一样，可以支持大多数原生 Linux 应用和工具。</p><pre><code class="lang-shell"># 列出所有wsl发行版wsl -l -v# 导出一份wsl发行版(文件会放到用户文件夹中):wsl --export Ubuntu 备份名字.tar# 导入wsl发行版文件wsl --import 新名称 存储新发行版的系统目录 导入的wsl文件名称.tar# 进入某一个wsl发行版wsl -d 环境名# 关闭某一个wsl发行版(释放资源)(需要在shell中使用exit命令)wsl --terminate 环境名# 删除某一个wsl发行版wsl --unregister 环境名</code></pre><h1 id="Docker的作用"><a href="#Docker的作用" class="headerlink" title="Docker的作用"></a>Docker的作用</h1><blockquote><p>Docker是一种轻量级的虚拟化技术，同时是一个开源的应用容器运行环境搭建平台，可以让开发者以便捷方式打包应用到一个可移植的容器中，然后安装至任何运行Linux或Windows等系统的服务器上。相较于传统虚拟机，Docker容器提供轻量化的虚拟化方式、安装便捷、启停速度快。</p></blockquote><h1 id="Docker的名词介绍"><a href="#Docker的名词介绍" class="headerlink" title="Docker的名词介绍"></a>Docker的名词介绍</h1><p><img src="/.com//image.png" alt="Alt text"><br><strong>镜像(image)</strong>:通过镜像可以创建多个容器<br><strong>容器(container)</strong>:Docker创建出来的携带环境的应用,是通过镜像创建的<br><strong>仓库(repository)</strong>:存放镜像的地方,分为公有仓库和私有仓库</p><h1 id="从零开始安装Docker的过程"><a href="#从零开始安装Docker的过程" class="headerlink" title="从零开始安装Docker的过程"></a>从零开始安装Docker的过程</h1><ol><li>前往官网安装VMWareWorkstation: <a href="https://www.vmware.com/cn/products/workstation-player.html">https://www.vmware.com/cn/products/workstation-player.html</a></li><li>安装linux(centos):<a href="https://www.cnblogs.com/Dengv5/p/16386206.html">https://www.cnblogs.com/Dengv5/p/16386206.html</a></li><li>安装xshell(负责在本机操控linux):<a href="https://www.xshell.com/zh/free-for-home-school/">https://www.xshell.com/zh/free-for-home-school/</a></li><li>将xshell与虚拟机的linux进行连接:<a href="https://www.xshellcn.com/zhishi/guanli-xuniji.html">https://www.xshellcn.com/zhishi/guanli-xuniji.html</a></li><li>Docker的安装:<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></li><li>可选: DBeaver的安装(windows版即可,这个软件可以用来可视化查看数据库):<a href="https://dbeaver.io/download/">https://dbeaver.io/download/</a></li></ol><h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><p>Docker的帮助文档地址:<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a><br>什么是shell,bash,sh:<a href="https://blog.csdn.net/wht1995316/article/details/115837282">https://blog.csdn.net/wht1995316/article/details/115837282</a></p><h2 id="重启Docker服务"><a href="#重启Docker服务" class="headerlink" title="重启Docker服务"></a>重启Docker服务</h2><pre><code class="lang-shell"># 重启DOckersudo systemctl restart docker# 重启containerdsudo systemctl restart containerd</code></pre><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><pre><code class="lang-shell">docker version # 显示docker的版本信息docker info # 显示docker的系统信息,包括镜像和容器的数量docker 命令名字 --help # 帮助命令</code></pre><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><pre><code class="lang-shell">docker images # 查看所有本地的主机上的镜像docker images -q # 查看所有镜像IDdocker search 镜像名 # 搜索镜像docker pull 镜像名 # 下载镜像docker pull 镜像名:镜像版本号 # 下载对应版本镜像docker rmi -f 镜像id  #删除指定id的镜像docker rmi -f 镜像id 镜像id 镜像id # 批量删除指定id镜像docker rmi -f $(docker images -aq) # 删除全部镜像</code></pre><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><pre><code class="lang-shell"># 创建并启动容器docker run -it 镜像名字 /bin/bash # 以bash的交互方式创建容器 -it意思是后面可以跟一个命令,这里跟/bin/bash意思是以bash方式进入容器# 后台启动容器docker run -d 镜像名字 # 后台创建容器,如果容器发现没有应用就会自动停止# 查询容器docker ps # 列出当前正在运行的容器docker ps -a # 列出当前正在运行的容器加上历史运行过的容器docker ps -n=数字 # 列出最近创建的对应数字的容器docker ps -q # # 退出容器exit # 停止容器并退出快捷键:ctrl+p+q # 退出但不停止容器# 删除容器docker rm 容器id # 删除容器docker rm -f 容器id # 强制删除容器docker rm -f $(docker ps -aq) # 强制删除所有容器# 启动和停止已经创建好的容器docker start 容器id # 可以通过这个命令将之前退出的容器重新启动docker restart 容器id # 重启容器docker stop 容器id # 停止当前正在运行的容器docker kill 容器id # 强制停止当前容器# 查看日志docker logs -tf --tail 查看日志条数 容器id # 查看日志# 查看容器中进程信息docker top 容器id# 查看容器的元数据docker inspect 容器id # 查看容器的元数据# 进入当前正在运行的容器docker exec -it 容器id /bin/bash # 进入容器后开启一个新的终端,可以在里面操作(常用)docker attach 容器id # 进入容器正在执行的终端,不会启动新的进程# 将容器的文件拷贝到主机上docker cp 容器id:容器内的文件路径 要拷贝到的主机文件路径</code></pre><h1 id="测试1-部署Nginx"><a href="#测试1-部署Nginx" class="headerlink" title="测试1:部署Nginx"></a>测试1:部署Nginx</h1><p>步骤:</p><ol><li>搜索镜像 docker search,虽然有命令,但更推荐前往dockerhub去搜索,里面内容更详细.<a href="https://hub.docker.com/">dockerhub链接</a></li><li>下载镜像 docker pull 镜像名 或者 docker pull 镜像名:版本号</li><li>查看镜像是否下载成功,docker images 查看所有已经下载的镜像</li><li>创建容器, docker run -d —name 容器名 -p 宿主机的端口号:容器的端口号 镜像名<br>举例: docker run -d —name nginx01 -p 3344:80 nginx</li><li>curl localhost:宿主机端口号 # 在linux中测试访问域名</li><li>通过xshell窗口上显示的192.168.<em>*</em>然后冒号端口号,进行浏览器上的访问<br><img src="/.com//image-1.png" alt="Alt text"><h1 id="测试2-部署Tomcat"><a href="#测试2-部署Tomcat" class="headerlink" title="测试2:部署Tomcat"></a>测试2:部署Tomcat</h1>```shell<h1 id="官方的使用"><a href="#官方的使用" class="headerlink" title="官方的使用"></a>官方的使用</h1>docker run -it —rm tomcat:9.0 # 这里如果找不到tomcat镜像会自动下载,之前的启动都是后台,停止了容器之后,容器还是可以查到,加了—rm一般用来测试,因为退出容器后就自动删除了,查不到容器.<h1 id="如果-docker-run-没有自动下载-就docker-pull-去下载"><a href="#如果-docker-run-没有自动下载-就docker-pull-去下载" class="headerlink" title="如果 docker run 没有自动下载,就docker pull 去下载"></a>如果 docker run 没有自动下载,就docker pull 去下载</h1><h1 id="运行完以后可以使用ctrl-c或者ctrl-p-q退出"><a href="#运行完以后可以使用ctrl-c或者ctrl-p-q退出" class="headerlink" title="运行完以后可以使用ctrl+c或者ctrl+p+q退出"></a>运行完以后可以使用ctrl+c或者ctrl+p+q退出</h1></li></ol><h1 id="下载最新版本tomcat"><a href="#下载最新版本tomcat" class="headerlink" title="下载最新版本tomcat"></a>下载最新版本tomcat</h1><p>docker pull tomcat</p><h1 id="创建并运行容器-提供公网访问端口-给容器取别名叫tomcat01-容器对应端口号可以通过docker-ps-来查看"><a href="#创建并运行容器-提供公网访问端口-给容器取别名叫tomcat01-容器对应端口号可以通过docker-ps-来查看" class="headerlink" title="创建并运行容器,提供公网访问端口,给容器取别名叫tomcat01,容器对应端口号可以通过docker ps 来查看"></a>创建并运行容器,提供公网访问端口,给容器取别名叫tomcat01,容器对应端口号可以通过docker ps 来查看</h1><p>docker run -d -p 3355:8080 —name tomcat01 tomcat # docker run -d -p 本机提供端口号:容器对应端口号 —name 容器名字 镜像名字</p><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>docker exec -it tomcat01 /bin/bash</p><h1 id="测试本地访问"><a href="#测试本地访问" class="headerlink" title="测试本地访问"></a>测试本地访问</h1><p>curl localhost:端口号</p><h1 id="测试网站访问"><a href="#测试网站访问" class="headerlink" title="测试网站访问"></a>测试网站访问</h1><p>通过xshell窗口上显示的192.168.<em>*</em>然后冒号端口号,进行浏览器上的访问</p><h1 id="发现显示404"><a href="#发现显示404" class="headerlink" title="发现显示404"></a>发现显示404</h1><h1 id="在容器中使用-docker-ls-列出容器的文件结构"><a href="#在容器中使用-docker-ls-列出容器的文件结构" class="headerlink" title="在容器中使用 docker ls 列出容器的文件结构"></a>在容器中使用 docker ls 列出容器的文件结构</h1><h1 id="发现webapps里没有文件-但是webapps-dist中有文件"><a href="#发现webapps里没有文件-但是webapps-dist中有文件" class="headerlink" title="发现webapps里没有文件,但是webapps.dist中有文件"></a>发现webapps里没有文件,但是webapps.dist中有文件</h1><h1 id="将webapps-dist中的文件复制到webapps中"><a href="#将webapps-dist中的文件复制到webapps中" class="headerlink" title="将webapps.dist中的文件复制到webapps中"></a>将webapps.dist中的文件复制到webapps中</h1><p>cp -r webapps.dist/* webapps</p><h1 id="测试浏览器访问-正常显示了"><a href="#测试浏览器访问-正常显示了" class="headerlink" title="测试浏览器访问,正常显示了."></a>测试浏览器访问,正常显示了.</h1><pre><code># Portainer可视化面板安装Portainer介绍: Docker图形化界面管理工具,提供一个后台面板来进行操作.安装与运行:(8088是提供的让外网访问的端口号)```shelldocker run -d -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre><p>访问测试:<br>通过地址进入网站以后注册账号后得到的界面:<br><img src="/.com//image-2.png" alt="Alt text"></p><h1 id="镜像原理之联合文件系统"><a href="#镜像原理之联合文件系统" class="headerlink" title="镜像原理之联合文件系统"></a>镜像原理之联合文件系统</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><blockquote><p>镜像是一种轻量级,可执行的独立软件包,用来打包软件运行环境和基于运行环境开发的软件,它包含运行某个软件所需的所有内容,包括代码,运行时,库,环境变量和配置文件.<br>所有的应用,直接打包docker镜像,就可以直接跑起来.<br><strong>如何得到镜像</strong>:</p><ul><li>从远程仓库下载</li><li>朋友拷贝给你</li><li>自己制作一个镜像DockerFile<h2 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS(联合文件系统)"></a>UnionFS(联合文件系统)</h2>我们下载的时候看到的一层层就是这个!<br>UnionFS(联合文件系统):Union文件系统(UnionFS)是一种分层、轻量级并目高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several diretories into a single virtualfilesystem)。Union 文件系统是 Docker 像的基础。镜像可以通过分层来进行继承，基于基础像(没有像 )可以制作各种具体的应用镜像。<br>特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2>docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统叫UnionFS.<br>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。<br>rootfs (root file system),在bootfs之上。包含的就是典型 Linux 系统中的 /dev,/proc,/bin,/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br><img src="/.com//image-3.png" alt="Alt text"><br>对于一个精简的OS,rootfs可以很小,只需要包含最基本的命令,工具和程序库就可以了,因为底层直接用Host的kernel,自己只需要提供rootfs就可以了.由此可见对于不同的linux发行版,bootfs基本是一致的<h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2>当下载一个镜像的时候,通过下载时的日志输出可以看到是一层一层的在下载.<br>由下图可以看到,当下载一个镜像时,这里下载了六层,其中第一层已经存在了就过滤,然后会只下载后面的五层.<br><img src="/.com//image-4.png" alt="Alt text"><br>所有的Docker镜像都起始于一个基础镜像层,当进行修改或添加新的内容时,就会在当前镜像层之上,创建新的镜像层.<br>Docker镜像都是只读的,当容器启动时,一个新的可写层被加载到镜像的顶部,这一层是叫容器层.<h1 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h1>commit的作用举例:<br>例如之前部署的tomcat镜像,默认的tomcat的webapps文件夹下没有文件,将webapps.dist中的文件复制到webapps文件夹后才能正常使用.因此可以将经过修改的tomcat进行commit来创建一个属于自己的镜像.<pre><code class="lang-shell">docker commit # 提交容器成为一个新的镜像# 命令和git原理类似docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[版本号]</code></pre><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1>数据都在容器中,如果容器删除那么数据也会跟着丢失.需要将数据持久化,所以有了容器数据卷这个技术,将Docker容器中产生的数据同步到本地,将容器内的目录挂载到linux上面.还有一个好处就是其他容器也都能访问到这个本地的地址.<pre><code class="lang-shell"># 创建一个容器并且设置容器数据卷docker run -it -v 主机目录:容器目录 镜像名字 /bin/bash# 查看容器是否挂载docker inspect 容器id # 查看容器元数据,查看其中是否有Mounts</code></pre><h2 id="部署MySQL并实现数据挂载"><a href="#部署MySQL并实现数据挂载" class="headerlink" title="部署MySQL并实现数据挂载"></a>部署MySQL并实现数据挂载</h2><pre><code class="lang-shell"># -d 后台启动# -p 端口映射# -v 卷挂载# -e 环境配置,这里是设置mysql的密码# --name 容器别名docker run -d -p 3310:3306 -v /home/mysql:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql</code></pre>创建好名字叫mysql01的容器之后,通过DBeaver与数据库进行连接.<br><img src="/.com//image-5.png" alt="Alt text"><h2 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h2>```shell<h1 id="匿名挂载-当使用docker-run-的-v时不指定主机内路径"><a href="#匿名挂载-当使用docker-run-的-v时不指定主机内路径" class="headerlink" title="匿名挂载:当使用docker run 的-v时不指定主机内路径"></a>匿名挂载:当使用docker run 的-v时不指定主机内路径</h1>docker run -d -P —name nginx01 -v /etc/nginx nginx<h1 id="查看所有的卷的情况"><a href="#查看所有的卷的情况" class="headerlink" title="查看所有的卷的情况"></a>查看所有的卷的情况</h1>docker volume ls<h1 id="输出的像这种的都属于匿名挂载-local-04e6ed9f31af8dc6768989d7d1c8db41d5ff61400a6d28d673db9aff5d2b396d"><a href="#输出的像这种的都属于匿名挂载-local-04e6ed9f31af8dc6768989d7d1c8db41d5ff61400a6d28d673db9aff5d2b396d" class="headerlink" title="输出的像这种的都属于匿名挂载:local     04e6ed9f31af8dc6768989d7d1c8db41d5ff61400a6d28d673db9aff5d2b396d"></a>输出的像这种的都属于匿名挂载:local     04e6ed9f31af8dc6768989d7d1c8db41d5ff61400a6d28d673db9aff5d2b396d</h1></li></ul></blockquote><h1 id="具名挂载-v时使用卷名-容器路径-而不是-主机路径-容器路径"><a href="#具名挂载-v时使用卷名-容器路径-而不是-主机路径-容器路径" class="headerlink" title="具名挂载:-v时使用卷名:容器路径 而不是 主机路径:容器路径"></a>具名挂载:-v时使用卷名:容器路径 而不是 主机路径:容器路径</h1><p>docker run -d -P —name nginx02 -v juming-nginx:/etc/nginx nginx</p><h1 id="所有的docker容器内的卷-没有指定目录的情况下都是再-‘-var-lib-docker-volumes-卷名-data下’"><a href="#所有的docker容器内的卷-没有指定目录的情况下都是再-‘-var-lib-docker-volumes-卷名-data下’" class="headerlink" title="所有的docker容器内的卷,没有指定目录的情况下都是再 ‘/var/lib/docker/volumes/卷名/_data下’"></a>所有的docker容器内的卷,没有指定目录的情况下都是再 ‘/var/lib/docker/volumes/卷名/_data下’</h1><h1 id="通过具名挂载可以方便的找到我们的一个卷-大多数情况在使用具名挂载"><a href="#通过具名挂载可以方便的找到我们的一个卷-大多数情况在使用具名挂载" class="headerlink" title="通过具名挂载可以方便的找到我们的一个卷,大多数情况在使用具名挂载"></a>通过具名挂载可以方便的找到我们的一个卷,大多数情况在使用具名挂载</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>-v 容器内路径 # 匿名挂载<br>-v 卷名:容器内路径 # 具名挂载<br>-v /宿主机路径:容器内路径 # 指定路径挂载</p><pre><code>扩展:```shell# 通过 -v 容器内路径: ro rw 改变读写权限ro :readonlyrw :readwrite docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx# ro 意思是说明这个路径只能通过宿主机来操作,容器内部是无法操作的.</code></pre><h2 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h2><p>Dockerfile就是用来构建docker镜像的构建文件</p><pre><code class="lang-shell"># 去home目录下创建一个docker=test-volume文件夹并创建一个dockerfile文件cd /homemkdir docker-test-volumevim dockerfile1# 进入vim编辑文本按i进入写入操作FROM centos # 镜像名VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 挂载卷,这里是匿名挂载两个CMD echo&quot;----end-----&quot; # 命令,打印CMD /bin/bash # 进入命令行操作模式# 写完以后按esc然后:wq完成写入保存与退出# 通过dockerfile构建镜像# -f 是指dockerfile文件的路径, -t 内容填 镜像名:镜像版本号 最后填个&quot;.&quot;意思是在当前目录下生成镜像docker build -f dockerfile1 -t mycentos:1.0 .# 查看所有镜像,查看自己构建的镜像是否成功docker images# 通过自己的镜像创建容器docker run -it mycentos:1.0 /bin/bash# 查看通过镜像构建的容器里是否执行了dockfile文件中的命令,通过ls -l 可以发现随着创建容器的同时实现了挂载volume01和volume02ls -l</code></pre><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p> 数据卷容器:可以让一个容器专门用来管理volume,然后其他需要使用这个volume的容器就通过—volumes-from 容器名,来访问volume.<br> 也就是说,多个容器之间可以共享volume.</p><pre><code class="lang-shell"> # 创建一个容器,这个容器可以共享另一个容器挂载的volume docker run -it --volumes-from 有挂载volume的容器名 镜像名</code></pre><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>dockerfile是用来构建docker镜像的文件,命令参数脚本<br>构建步骤:</p><ol><li>编写一个dockerfile文件</li><li>docker build 构建成为一个镜像</li><li>docker run 运行镜像</li><li>docker push 发布镜像(DockerHub)</li></ol><h2 id="DockerFile的构建过程"><a href="#DockerFile的构建过程" class="headerlink" title="DockerFile的构建过程"></a>DockerFile的构建过程</h2><p>基础知识:</p><ol><li>每个保留关键字(指令)都是必须是大写字母</li><li>执行从上到下顺序执行</li><li><h1 id="表示注释"><a href="#表示注释" class="headerlink" title="表示注释"></a>表示注释</h1></li><li>每一个指令都会创建提交一个新的镜像层并提交.<br><img src="/.com//image-6.png" alt="Alt text"></li><li>dockerfile是面向开发的,以后要发布项目,做镜像,就需要编写dockerfile文件,这个文件十分简单.</li></ol><h2 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h2><pre><code class="lang-shell">FROM                   # 基础镜像MAINTAINER             # 镜像是谁写的,姓名＋邮箱RUN                    # 镜像构建的时候需要运行的命令ADD                    # 除基础镜像外额外添加的镜像内容WORKDIR                # 镜像的工作目录,也就是说通过镜像创建容器后进入的目录VOLUME                 # 挂载的目录EXPOSE                 # 暴露的端口CMD                    # 通过镜像创建容器时执行的命令,如果创建容器的同时指定了命令则CMD不生效ENTRYPOINT             # 通过镜像创建容器时执行的命令,如果创建容器的同时指定了命令,ENTRYPOINT仍然生效ONBUILD                # ONBUILD中的内容只有当被FROM时才会执行,其他时候不会执行,ONBUILD指令对应的内容是其他指令以及内容.COPY                   # 类似ADD,将文件拷贝到镜像中ENV                    # 构建的时候设置环境变量</code></pre><h2 id="测试-构建自己的centos镜像"><a href="#测试-构建自己的centos镜像" class="headerlink" title="测试:构建自己的centos镜像"></a>测试:构建自己的centos镜像</h2><pre><code class="lang-shell"># 前往/home目录创建一个my_dockerfiles目录,然后通过vim创建一个my_dockerfile_centos文件并写内容cd /homemkdir my_dockerfilesvim my_dockerfile_centos# 写dockerfile内容:FROM centos:7   # 之所以使用centos:7是因为centos最新版默认不支持网络不能直接使用yum -y install vim来进行安装了.MAINTAINER ruichen&lt;1505291171@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;-----end-----&quot;CMD /bin/bash# 写完内容以后构建镜像文件:-f意思是dockerfile文件的路径,我这里是相对路径直接填写名字也行,-t的意思是生成的镜像的镜像名和版本号docker -f my_dockerfile_centos -t mycentos:1.0 .# 查看镜像的构建信息docker history 镜像id# 以自己构建的centos镜像举例,内容如下:IMAGE          CREATED          CREATED BY                                       SIZE      COMMENTf6ed0ba1956f   10 minutes ago   CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin/bash&quot;]                 0B        buildkit.dockerfile.v0&lt;missing&gt;      10 minutes ago   CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo \&quot;-----end-----\&quot;&quot;]    0B        buildkit.dockerfile.v0&lt;missing&gt;      10 minutes ago   CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo $MYPATH&quot;]              0B        buildkit.dockerfile.v0&lt;missing&gt;      10 minutes ago   EXPOSE map[80/tcp:&#123;&#125;]                            0B        buildkit.dockerfile.v0&lt;missing&gt;      10 minutes ago   RUN /bin/sh -c yum -y install net-tools # bu…   198MB     buildkit.dockerfile.v0&lt;missing&gt;      10 minutes ago   RUN /bin/sh -c yum -y install vim # buildkit     285MB     buildkit.dockerfile.v0&lt;missing&gt;      12 minutes ago   WORKDIR /usr/local                               0B        buildkit.dockerfile.v0&lt;missing&gt;      12 minutes ago   ENV MYPATH=/usr/local                            0B        buildkit.dockerfile.v0&lt;missing&gt;      12 minutes ago   MAINTAINER ruichen&lt;1505291171@qq.com&gt;            0B        buildkit.dockerfile.v0&lt;missing&gt;      2 years ago      /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]             0B        &lt;missing&gt;      2 years ago      /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        &lt;missing&gt;      2 years ago      /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d4…   204MB</code></pre><h2 id="测试-Dockerfile制作tomcat镜像"><a href="#测试-Dockerfile制作tomcat镜像" class="headerlink" title="测试:Dockerfile制作tomcat镜像"></a>测试:Dockerfile制作tomcat镜像</h2><p>前提:<br>需要准备两个压缩包<br>1.<a href="https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.22/bin/apache-tomcat-9.0.22.tar.gz">apache-tomcat-9.0.22.tar.gz</a><br>2.<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html#license-lightbox">jdk-8u11-linux-x64.tar.gz</a><br>我是在windows上面下载的,因为本地有WinSCP这个远程传输文件的软件就直接用这个传到linux虚拟机上面的home目录下新建的文件夹上了,下载xshell的网站软件旁边有个叫Xftp 7的也可以用来传输文件</p><pre><code class="lang-shell"># 在自定义的目录下编写Dockerfile文件,命名dockerfile文件为&quot;Dockerfile&quot;好处是在build的时候会自动寻找这个名字叫&quot;Dockerfile&quot;的文件,就不需要-f来指定了.mkdir /home/my_tomcattouch readme.txtvim Dockerfile# Dockerfile内容:FROM centos:7MAINTAINER ruichen&lt;1505291171@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u11-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.22.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tail -f /usr/local/apache-tomcat-9.0.22/logs/catalina.out# 构建镜像: docker build -t my_tomcat .# 创建容器docker run -d -p 9090:8080 --name mytomcat_container -v /home/my_tomcat/test:/usr/local/apache-tomcat-9.0.22/webapps/test -v /home/my_tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.22/logs my_tomcat# 进入容器docker exec -it 容器id /bin/bash# ctrl+p+q退出容器,访问域名curl localhost:9090# 没问题后,那么在浏览器上输入主机名然后:9090即可进入tomcat# 发布项目(由于做了卷挂载,直接在本地编写项目就可以发布了)# 在本地进入my_tomcat的test目录(这个test目录是挂载的目录)cd test# 创建一个WEB_INF目录并进入mkdir WEB_INFcd WEB_INF# 写一个web.xmlvim web.xml# 内容:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;&lt;/web-app&gt;# 再去test目录写一个index.jspcd ..vim index.jsp# 内容:&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Welcome to My Website&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello, this is the index.jsp page!&lt;/h1&gt;    &lt;p&gt;Current time: &lt;%= new java.util.Date() %&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;# 内容写好以后,当前浏览器地址是主机号:9090,接下来输入/test回车,也就是主机号:9090/test,回车后如果跳转网页正常跳转并显示即可证明成功</code></pre><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><p>ens33的话就是虚拟机的地址<br><img src="/.com//image-7.png" alt="Alt text"><br>两个容器通过Docker0可以进行连接</p><p><font color="red">注:如果这两个容器如果没有进行link,那么不可以直接通过容器名进行ping通,需要一个容器名对应ip地址才行</font><br><img src="/.com//image-8.png" alt="Alt text"><br>所有容器不指定网络的情况下,都是docker0路由的,docker会给容器分配一个默认的可用IP<br><img src="/.com//image-9.png" alt="Alt text"></p><pre><code class="lang-shell"># 下载tomcat镜像并创建容器docker run -d -P --name tomcat01 tomcat# 查看容器内部网络地址docker exec -it tomcat01 ip addr# 查看到以后,使用ping 网络地址 的命令,发现linux可以ping通容器内部# 每启动一个docker容器,docker就会给docker容器分配一个ip,我们只要安装了docker,就会有一个网关docker0# 桥接模式,使用的技术是veth-pair技术# veth-pair充当一个桥梁,连接各种虚拟设备.# 容器与容器之间是可以互相ping通的</code></pre><h1 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h1><p>通过自定义网络可以实现容器互联,可以令不同的集群使用不同的网络,保证集群是安全和健康的.<br>查看所有docker网络:<br>docker network ls<br><img src="/.com//image-10.png" alt="Alt text"><br>网络模式:<br>bridge: 桥接 docker默认<br>none : 不配置网络<br>host: 和宿主机共享网络<br>container: 容器网络联通(用的少,局限很大)<br>测试:</p><pre><code class="lang-shell"># 使用docker run -d -P --name tomcat01 tomcat命令是会有个默认参数 --net bridge也就是docker0 # docker0特点: 默认,域名不能访问docker run -d -P --name tomcat01 --net bridge tomcat# 自定义网络: 网络模式为桥接模式,子网为192.168.0.0/16(这里的16意思是指开头的16个二进制数字固定),网关为192.168.0.1docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet# 通过自己的自定义网络创建两个容器docker run -d -P --name tomcat-net-01 --net 自定义网络名字 tomcatdocker run -d -P --name tomcat-net-02 --net 自定义网络名字 tomcat# 令通过自定义网络创建的容器01去ping通过自定义网络创建的容器02是成功的docker exec -it 容器01 ping 容器02</code></pre><h1 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h1><p>举例,这里使用默认网关创建两个容器tomcat-01与tomcat-02,使用自定义网络创建两个容器tomcat-net-01与tomcat-net-02,如果想要让tomcat-01与tomcat-net-01之间相互访问是需要先将tomcat-01与mynet网关进行联通的<br><img src="/.com//image-11.png" alt="Alt text"><br>创建redis集群命令的解释:<br><img src="/.com//image-13.png" alt="Alt text"></p><pre><code class="lang-shell"># 让mynet网关与tomcat01容器进行连通,将tomcat01放到了mynet网络下,一个容器两个ip地址docker network connect mynet tomcat01</code></pre><h1 id="部署Redis集群"><a href="#部署Redis集群" class="headerlink" title="部署Redis集群"></a>部署Redis集群</h1><p>部署一个这样的集群:当r-m死掉的话,会有对应的r-s去进行替代<br><img src="/.com//image-12.png" alt="Alt text"></p><pre><code class="lang-shell"># 清理所有容器docker rm -f &amp;(docker ps -aq)# 创建名字叫做redis的自定义网络docker network create redis --subnet 172.38.0.0/16# 通过脚本创建6个redis配置for port in $(seq 1 6); \do \mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379 bind 0.0.0.0cluster-enabled yes cluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone# cd到/mydata查看redis是否创建出来cd /mydata/ls# 启动redis-1服务docker run -p 6371:6379 -p 16371:16379 --name redis-1 \-v /mydata/redis/node-1/data:/data \-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf# 启动redis-2服务,仿照redis-1,修改端口号,容器名,映射,ipdocker run -p 6372:6379 -p 16372:16379 --name redis-2 \-v /mydata/redis/node-2/data:/data \-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf# 依次顺序启动redis-3,4,5,6服务...# 进入redis-1容器,redis容器只能使用sh解释器docker exec -it redis-1 /bin/sh# 创建一个Redis集群redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1# 连接到redis集群模式redis-cli -c# 获取redis集群状态信息cluster info# 获取集群所有系欸但的详细信息cluster nodes# 设置键值对,a关联b,系统会自动分配一个主机器来进行这个配置,我这里显示的是ip为172.38.0.13的节点set a b# ctrl+p+q退出容器,停掉redis-3docker stop redis-3# 进入集群,去获取adocker exec -it redis-1 /bin/shredis-cli -cget a# 最终可以看到返回结果是从14ip的节点中找到了b# 检查所有节点,从返回中可以发现,13节点故障,14节点变成了主节点cluster nodes</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些网站&quot;&gt;&lt;a href=&quot;#一些网站&quot; class=&quot;headerlink&quot; title=&quot;一些网站&quot;&gt;&lt;/a&gt;一些网站&lt;/h1&gt;&lt;p&gt;教程网站:&lt;a href=&quot;https://www.bilibili.com/video/BV1og4y1q7M4/?p=1</summary>
      
    
    
    
    <category term="Geek" scheme="http://example.com/categories/Geek/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI插件</title>
    <link href="http://example.com/2023/11/28/AI-ComfyUI%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2023/11/28/AI-ComfyUI%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-28T01:31:00.000Z</published>
    <updated>2024-07-27T18:58:06.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作流参考"><a href="#工作流参考" class="headerlink" title="工作流参考"></a>工作流参考</h1><p><a href="https://comfyanonymous.github.io/ComfyUI_examples/">https://comfyanonymous.github.io/ComfyUI_examples/</a></p><h1 id="将工作流保存到png图像中"><a href="#将工作流保存到png图像中" class="headerlink" title="将工作流保存到png图像中"></a>将工作流保存到png图像中</h1><p>方法一:</p><ol><li>下载插件<a href="https://github.com/pythongosssss/ComfyUI-Custom-Scripts">https://github.com/pythongosssss/ComfyUI-Custom-Scripts</a></li><li>生成图片后,界面中会显示生成的图片的队列,将队列中的图片保存即可<br>方法二:<br>代码:<br>```python<h1 id="title-Add-Workflow-to-PNG"><a href="#title-Add-Workflow-to-PNG" class="headerlink" title="@title Add Workflow to PNG"></a>@title Add Workflow to PNG</h1></li></ol><p>from PIL import Image, PngImagePlugin<br>import os</p><p>def make_workflow_png(image_path, workflow_path):<br>    if not os.path.exists(image_path):<br>        ValueError(f”Invalid image path <code>&#123;image_path&#125;</code>“)<br>    if not os.path.exists(workflow_path):<br>        ValueError(f”Invalid workflow path <code>&#123;workflow_path&#125;</code>“)<br>    path = os.path.dirname(image_path)<br>    filename = os.path.basename(image_path).rsplit(‘.’, 1)[0]<br>    try:<br>        with open(workflow_path, “r”) as file:<br>            data = file.read()<br>    except OSError as e:<br>        Exception(“There was an error reading the workflow JSON:”, e)<br>    image = Image.open(image_path)<br>    info = PngImagePlugin.PngInfo()<br>    info.add_text(“workflow”, data)<br>    new_path = os.path.join(path, filename+’_workflow.png’)<br>    image.save(new_path, “PNG”, pnginfo=info)<br>    return new_path</p><h1 id="Create-the-workflow-PNG"><a href="#Create-the-workflow-PNG" class="headerlink" title="Create the workflow PNG"></a>Create the workflow PNG</h1><p>image = ‘/content/Comparison_Workflow.png’ # 在这里填写工作流生成的图片的路径<br>workflow = ‘/content/PPF_Workflow.json’ # 在这里填写工作流的Json文件路径</p><p>workflow_png_path = make_workflow_png(image, workflow)</p><p>img = Image.open(image)</p><p>print(“Workflow added to image:”, workflow_png_path)<br>```<br>使用方法:</p><ol><li>准备ComfyUI的工作流文件:workflow.json (名字任意)</li><li>工作流生成的图片:image.png  (名字任意)</li><li>在提供的代码中填写图片和工作流的文件路径</li><li>运行代码</li><li>在图片的路径下得到后缀为_workflow.png的携带工作流的图片</li><li>将携带工作流的图片拖入到ComfyUI中即可生成对应的工作流</li></ol><h1 id="ComfyUI-Manager"><a href="#ComfyUI-Manager" class="headerlink" title="ComfyUI Manager"></a>ComfyUI Manager</h1><p>网站:<a href="https://github.com/ltdrdata/ComfyUI-Manager">https://github.com/ltdrdata/ComfyUI-Manager</a><br>作用:方便插件的安装,识别工作流中有哪些未安装的模型和插件<br>推荐的设置:<br><img src="/.com//image-4.png" alt="Alt text"><br>设置好这些以后,comfyui上能够显示节点对应的插件名,如果是🦊图标就是原生的,如果是不带🦊图标并且没有插件名的就是识别不出来的.<br><img src="/.com//image-5.png" alt="Alt text"></p><h1 id="AnimateDiff-Evolved-生成动画的工作流相关"><a href="#AnimateDiff-Evolved-生成动画的工作流相关" class="headerlink" title="AnimateDiff Evolved(生成动画的工作流相关)"></a>AnimateDiff Evolved(生成动画的工作流相关)</h1><p>网站:<a href="https://github.com/Kosinkadink/ComfyUI-AnimateDiff-Evolved">https://github.com/Kosinkadink/ComfyUI-AnimateDiff-Evolved</a><br>额外需要的模型:参考github说明,有lora,有model.<br>作用:生成带动作的视频<br><img src="/.com//image-2.png" alt="Alt text"></p><h1 id="FizzNodes-生成动画的工作流相关"><a href="#FizzNodes-生成动画的工作流相关" class="headerlink" title="FizzNodes(生成动画的工作流相关)"></a>FizzNodes(生成动画的工作流相关)</h1><p>网站:<a href="https://github.com/FizzleDorf/ComfyUI_FizzNodes">https://github.com/FizzleDorf/ComfyUI_FizzNodes</a><br><img src="/.com//image-3.png" alt="Alt text"><br>作用:</p><blockquote><p>Scheduled prompts, scheduled float/int values and wave function nodes for animations and utility. compatable with framesync and keyframe-string-generator for audio synced animations in Comfyui.<br>用于动画和实用程序的预定提示、预定浮点/整数值和波函数节点。与 Comfyui 中的音频同步动画的帧同步和关键帧字符串生成器兼容。</p></blockquote><h1 id="ComfyUI-VideoHelperSuite-生成动画的工作流相关"><a href="#ComfyUI-VideoHelperSuite-生成动画的工作流相关" class="headerlink" title="ComfyUI-VideoHelperSuite(生成动画的工作流相关)"></a>ComfyUI-VideoHelperSuite(生成动画的工作流相关)</h1><p>网站:<a href="https://github.com/Kosinkadink/ComfyUI-VideoHelperSuite">https://github.com/Kosinkadink/ComfyUI-VideoHelperSuite</a><br><img src="/.com//image.png" alt="Alt text"><br>作用:视频工作流相关节点</p><h1 id="ComfyUI-Custom-Nodes-AlekPet-实时绘画的工作流相关"><a href="#ComfyUI-Custom-Nodes-AlekPet-实时绘画的工作流相关" class="headerlink" title="ComfyUI_Custom_Nodes_AlekPet(实时绘画的工作流相关)"></a>ComfyUI_Custom_Nodes_AlekPet(实时绘画的工作流相关)</h1><p>网站:<a href="https://github.com/AlekPet/ComfyUI_Custom_Nodes_AlekPet">https://github.com/AlekPet/ComfyUI_Custom_Nodes_AlekPet</a></p><h1 id="ComfyUI-IPAdapter-plus"><a href="#ComfyUI-IPAdapter-plus" class="headerlink" title="ComfyUI_IPAdapter_plus"></a>ComfyUI_IPAdapter_plus</h1><p>网站:<a href="https://github.com/cubiq/ComfyUI_IPAdapter_plus">https://github.com/cubiq/ComfyUI_IPAdapter_plus</a><br>注意:<font color="red">这个需要下载对应的需要模型,因此需要前往github查看需要的内容</font><br>作用:</p><blockquote><pre><code>The IPAdapter are very powerful models for image-to-image conditioning. Given a reference image you can do variations augmented by text prompt, controlnets and masks. Think of it as a 1-image lora.</code></pre><p>IPAdapter 是非常强大的图像到图像调节模型。给定参考图像，您可以通过文本提示、控制网和遮罩进行增强的变化。将其视为单幅图像 lora。</p></blockquote><h1 id="ComfyUI-Custom-Scripts"><a href="#ComfyUI-Custom-Scripts" class="headerlink" title="ComfyUI-Custom-Scripts"></a>ComfyUI-Custom-Scripts</h1><p>网站:<a href="https://github.com/pythongosssss/ComfyUI-Custom-Scripts">https://github.com/pythongosssss/ComfyUI-Custom-Scripts</a><br>作用举例:可以扩展comfyUI的界面,令生成的图片都显示在界面上,然后可以拖拽复现工作流.<br>像这种带蟒蛇图标的都属于这个插件<br><img src="/.com//image-1.png" alt="Alt text"></p><h1 id="comfyui-controlnet-aux"><a href="#comfyui-controlnet-aux" class="headerlink" title="comfyui_controlnet_aux"></a>comfyui_controlnet_aux</h1><p>网站:<a href="https://github.com/Fannovel16/comfyui_controlnet_aux">https://github.com/Fannovel16/comfyui_controlnet_aux</a><br>注意:<font color="red">此自定义节点与comfyui_controlnet_preprocessors相冲突</font><br>作用:可以将图片进行预处理,生成ControlNet模型需要的图片.</p><h1 id="Masquerade-Nodes"><a href="#Masquerade-Nodes" class="headerlink" title="Masquerade Nodes"></a>Masquerade Nodes</h1><p>网站:<a href="https://github.com/BadCafeCode/masquerade-nodes-comfyui">https://github.com/BadCafeCode/masquerade-nodes-comfyui</a><br>作用: 提供了很多与mask处理有关的节点</p><h1 id="Allor"><a href="#Allor" class="headerlink" title="Allor"></a>Allor</h1><p>网站:<a href="https://github.com/Nourepide/ComfyUI-Allor?tab=readme-ov-file">https://github.com/Nourepide/ComfyUI-Allor?tab=readme-ov-file</a><br>作用: 提供了很多调节图像的节点<br>使用文档:<a href="https://nourepide.github.io/ComfyUI-Allor-Doc/image-text.html">https://nourepide.github.io/ComfyUI-Allor-Doc/image-text.html</a></p><h2 id="ImageTransformCropAbsolute"><a href="#ImageTransformCropAbsolute" class="headerlink" title="ImageTransformCropAbsolute"></a>ImageTransformCropAbsolute</h2><p>可以将图片进行裁切<br><img src="/.com//image-7.png" alt="Alt text"></p><h1 id="ComfyUI-Segment-Anything"><a href="#ComfyUI-Segment-Anything" class="headerlink" title="ComfyUI Segment Anything"></a>ComfyUI Segment Anything</h1><p>网站:<a href="https://github.com/storyicon/comfyui_segment_anything">https://github.com/storyicon/comfyui_segment_anything</a><br>作用: 通过算法进行生成遮罩与图像</p><h1 id="efficiency-nodes-comfyui"><a href="#efficiency-nodes-comfyui" class="headerlink" title="efficiency-nodes-comfyui"></a>efficiency-nodes-comfyui</h1><p>网站:<a href="https://github.com/LucianoCirino/efficiency-nodes-comfyui?tab=readme-ov-file">https://github.com/LucianoCirino/efficiency-nodes-comfyui?tab=readme-ov-file</a><br>作用:提供了一些自定义节点,例如xyplot.然后提供了一些用于简化工作流程而减少节点总数的节点,将一些流程汇总到了一个节点上面.</p><h1 id="ComfyUI-tinyterraNodes"><a href="#ComfyUI-tinyterraNodes" class="headerlink" title="ComfyUI_tinyterraNodes"></a>ComfyUI_tinyterraNodes</h1><p>网站:<a href="https://github.com/TinyTerra/ComfyUI_tinyterraNodes">https://github.com/TinyTerra/ComfyUI_tinyterraNodes</a><br>作用:这个也有xyplot,也提供了一些精简工作流的节点.<br>实测:通过自定义节点实现只需要一个节点就能够添加多个lora的效果.并实测跟原生工作流生成图片相同.<br>将此图片拖入comfyui复刻工作流<br><img src="/.com//comfyui_ttn.png" alt="Alt text"></p><h1 id="ComfyUI-ADV-CLIP-emb"><a href="#ComfyUI-ADV-CLIP-emb" class="headerlink" title="ComfyUI_ADV_CLIP_emb"></a>ComfyUI_ADV_CLIP_emb</h1><p>网站:<a href="https://github.com/BlenderNeko/ComfyUI_ADV_CLIP_emb">https://github.com/BlenderNeko/ComfyUI_ADV_CLIP_emb</a><br>作用:让comfyui的提示词的跟webui的提示词对于权重分配的方式一样.</p><h2 id="BNK-CLIPTextEncodeAdvanced"><a href="#BNK-CLIPTextEncodeAdvanced" class="headerlink" title="BNK_CLIPTextEncodeAdvanced"></a>BNK_CLIPTextEncodeAdvanced</h2><p><img src="/.com//image-6.png" alt="Alt text"></p><h1 id="ComfyUI-Inspire-Pack"><a href="#ComfyUI-Inspire-Pack" class="headerlink" title="ComfyUI-Inspire-Pack"></a>ComfyUI-Inspire-Pack</h1><p>网站:<a href="https://github.com/ltdrdata/ComfyUI-Inspire-Pack">https://github.com/ltdrdata/ComfyUI-Inspire-Pack</a><br>作用:这也有A1111 兼容性支持有助于在 ComfyUI 中精确复制 A1111 的创建。</p><h2 id="KSampler-Inspire"><a href="#KSampler-Inspire" class="headerlink" title="KSampler //Inspire"></a>KSampler //Inspire</h2><p><img src="/.com//image-8.png" alt="Alt text"></p><h1 id="ComfyUI-Dave-CustomNode-manage中搜索Davemane42"><a href="#ComfyUI-Dave-CustomNode-manage中搜索Davemane42" class="headerlink" title="ComfyUI_Dave_CustomNode(manage中搜索Davemane42)"></a>ComfyUI_Dave_CustomNode(manage中搜索Davemane42)</h1><p>网站:<a href="https://github.com/Davemane42/ComfyUI_Dave_CustomNode">https://github.com/Davemane42/ComfyUI_Dave_CustomNode</a><br>作用:线稿上色latent couple(sdwebui上面叫latent couple),注:这个不能够通过api进行调用</p><h1 id="ComfyUI-Impact-Pack"><a href="#ComfyUI-Impact-Pack" class="headerlink" title="ComfyUI-Impact-Pack"></a>ComfyUI-Impact-Pack</h1><p>网站:<a href="https://github.com/ltdrdata/ComfyUI-Impact-Pack">https://github.com/ltdrdata/ComfyUI-Impact-Pack</a><br>作用:脸部修复</p><h1 id="was-node-suite-comfyui-manage中搜索WAS-Node-Suite"><a href="#was-node-suite-comfyui-manage中搜索WAS-Node-Suite" class="headerlink" title="was-node-suite-comfyui(manage中搜索WAS_Node_Suite)"></a>was-node-suite-comfyui(manage中搜索WAS_Node_Suite)</h1><p>网站:<a href="https://github.com/WASasquatch/was-node-suite-comfyui">https://github.com/WASasquatch/was-node-suite-comfyui</a><br>作用:提供了很多不同类型的节点,个人主要用到的:各种switch节点.方便一个工作流来实现不同需求.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作流参考&quot;&gt;&lt;a href=&quot;#工作流参考&quot; class=&quot;headerlink&quot; title=&quot;工作流参考&quot;&gt;&lt;/a&gt;工作流参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://comfyanonymous.github.io/ComfyUI_examples</summary>
      
    
    
    
    <category term="AI" scheme="http://example.com/categories/AI/"/>
    
    
    <category term="ComfyUI" scheme="http://example.com/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>UE_工具蓝图</title>
    <link href="http://example.com/2023/11/21/UE%E5%BC%80%E5%8F%91-UE%E5%B7%A5%E5%85%B7%E8%93%9D%E5%9B%BE/"/>
    <id>http://example.com/2023/11/21/UE%E5%BC%80%E5%8F%91-UE%E5%B7%A5%E5%85%B7%E8%93%9D%E5%9B%BE/</id>
    <published>2023-11-21T12:41:00.000Z</published>
    <updated>2024-07-27T18:58:06.876Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="好用的快捷键"><a href="#好用的快捷键" class="headerlink" title="好用的快捷键"></a>好用的快捷键</h1><p>q ：选中蓝图按Q一键排列<br>shift+鼠标点击：<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661931418121-555dc6c5-d667-4f57-921f-b5f58d49c9af.png#averageHue=%234c4639&amp;clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=425&amp;id=u5c67b221&amp;originHeight=425&amp;originWidth=415&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145631&amp;status=error&amp;style=none&amp;taskId=ueae8edeb-bbdf-4fcb-bc98-12718067ad3&amp;title=&amp;width=415" alt="image.png">当制作好一个工具蓝图之后通过shift加鼠标点击可以跳转到蓝图界面。</p><h1 id="UI界面制作"><a href="#UI界面制作" class="headerlink" title="UI界面制作"></a>UI界面制作</h1><h2 id="使用UE自带的界面嵌入到自己的UI里面"><a href="#使用UE自带的界面嵌入到自己的UI里面" class="headerlink" title="使用UE自带的界面嵌入到自己的UI里面"></a>使用UE自带的界面嵌入到自己的UI里面</h2><p><a href="https://filipsivak.medium.com/unreal-how-to-use-details-view-and-single-property-view-in-editor-utility-widget-38c47ba8dfe5">https://filipsivak.medium.com/unreal-how-to-use-details-view-and-single-property-view-in-editor-utility-widget-38c47ba8dfe5</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663578872293-443eac28-c118-41df-97bc-65e0ec0de268.png#averageHue=%234e4e4e&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;id=u20327ccf&amp;originHeight=545&amp;originWidth=593&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=52455&amp;status=done&amp;style=none&amp;taskId=uff11847c-a6f0-4067-8fbe-22c5c917da6&amp;title=" alt="image.png"><br><strong>Details view</strong><br>这个是可以折叠的<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663578904714-d722fb8e-f0de-4200-8505-de0c3a868d17.png#averageHue=%235c5b5b&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=186&amp;id=u2b66c50e&amp;originHeight=186&amp;originWidth=514&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11567&amp;status=done&amp;style=none&amp;taskId=u05d00600-bff2-419f-9549-2805956803b&amp;title=&amp;width=514" alt="image.png">，并且可以创建多个可以折叠的控件。<br><strong>SinglePropertyView</strong><br>这个是单个的，当只需要一个，并且不需要折叠时使用。<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663579003446-98d1b919-8d19-418b-ad31-ee4a82b65b38.png#averageHue=%23515151&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=81&amp;id=ue551f0fa&amp;originHeight=81&amp;originWidth=589&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8283&amp;status=done&amp;style=none&amp;taskId=u0e75b50f-a9ff-4c9f-9a76-0a9d21b7dda&amp;title=&amp;width=589" alt="image.png">。<br><strong>如何创建</strong><br>首先介绍一下singlePropertyView：<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663579088716-a09dffc9-9cff-40fc-901e-261e4955dbb1.png#averageHue=%233f3c3b&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=86&amp;id=ufb7650a0&amp;originHeight=86&amp;originWidth=600&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5439&amp;status=done&amp;style=none&amp;taskId=uc2fc1768-f2bf-42f1-b5c2-8241bf30ef9&amp;title=&amp;width=600" alt="image.png">在控件属性中决定开头的名字<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663579192780-01df89db-c659-4077-bf05-a075c3de450b.png#averageHue=%232c2828&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=130&amp;id=ub4ef9b01&amp;originHeight=130&amp;originWidth=471&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=8507&amp;status=done&amp;style=none&amp;taskId=u04224dea-6c31-4ddd-899f-7e16caf93cb&amp;title=&amp;width=471" alt="image.png">，然后在蓝图中创建相同名字的变量，并指定类型<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663579221908-1928b458-d948-4204-a3bf-6ace5afe8ce2.png#averageHue=%232b2625&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=161&amp;id=ua3ac6f7a&amp;originHeight=161&amp;originWidth=550&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14669&amp;status=done&amp;style=none&amp;taskId=u0bcb3376-9fc8-48d5-bf6f-0aca150d5a4&amp;title=&amp;width=550" alt="image.png">。指定类型之后在蓝图中设置object使其显示<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663579270140-82b1da43-d6e5-49cb-b4fd-1050b81c5699.png#averageHue=%232b2929&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=241&amp;id=u11d0a447&amp;originHeight=241&amp;originWidth=842&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=55077&amp;status=done&amp;style=none&amp;taskId=u1475fc4a-2e07-4b7a-990a-c2af5633450&amp;title=&amp;width=842" alt="image.png">。<br>再介绍一下detailsView：在categories to show控件中设置要显示的组<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663579355405-23b5bd82-c3a3-40a5-bf61-993f6b736250.png#averageHue=%23272626&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=408&amp;id=ucb23b0e7&amp;originHeight=408&amp;originWidth=621&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=32705&amp;status=done&amp;style=none&amp;taskId=u418a60c9-a3a6-48d6-bd75-0eee3986e52&amp;title=&amp;width=621" alt="image.png">设置完以后，在事件图表中设置变量并分配组<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663580122614-cbdf7483-39a1-4b08-b277-285a34257d20.png#averageHue=%23252323&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=834&amp;id=u536c492a&amp;originHeight=834&amp;originWidth=627&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=62036&amp;status=done&amp;style=none&amp;taskId=uaac31b5d-b093-468a-a1b8-df664cc0a67&amp;title=&amp;width=627" alt="image.png">，然后依然设置object<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663580194430-2ce6b6df-e95f-4aee-b331-f02d9b41155b.png#averageHue=%232a2828&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=335&amp;id=u8dbc32c0&amp;originHeight=335&amp;originWidth=949&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=68356&amp;status=done&amp;style=none&amp;taskId=u40d4ec96-935f-4ee7-a403-901ca52732e&amp;title=&amp;width=949" alt="image.png">最后显示效果：<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1663580016690-683c5e19-1611-4294-b412-b63695cb6388.png#averageHue=%23252323&amp;clientId=u82361329-ec78-4&amp;from=paste&amp;height=311&amp;id=uuGog&amp;originHeight=311&amp;originWidth=968&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14527&amp;status=done&amp;style=none&amp;taskId=u7e1dd347-d2e7-4f97-8e51-fc1d554220c&amp;title=&amp;width=968" alt="image.png"></p><h1 id="官方教育直播"><a href="#官方教育直播" class="headerlink" title="官方教育直播"></a>官方教育直播</h1><p>官方教育直播链接：<a href="https://www.bilibili.com/video/BV1Kg411M7o3?spm_id_from=333.880.my_history.page.click&amp;vd_source=b1de3fe38e887eb40fc55a5485724480">https://www.bilibili.com/video/BV1Kg411M7o3?spm_id_from=333.880.my_history.page.click&amp;vd_source=b1de3fe38e887eb40fc55a5485724480</a></p><h2 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h2><p>需要打开的插件：这个插件包含了制作UE工具所需要的函数。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661911833222-fb075e80-c9cc-43a2-8514-2e13e2a3da77.png#averageHue=%233f3c3c&amp;clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=183&amp;id=u58dbd09f&amp;originHeight=183&amp;originWidth=830&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19675&amp;status=error&amp;style=none&amp;taskId=ue1fd311f-f772-416c-9a4b-4facd10386b&amp;title=&amp;width=830" alt="image.png"></p><h2 id="批量设置资产的LOD"><a href="#批量设置资产的LOD" class="headerlink" title="批量设置资产的LOD"></a>批量设置资产的LOD</h2><h3 id="工具蓝图的制作"><a href="#工具蓝图的制作" class="headerlink" title="工具蓝图的制作"></a>工具蓝图的制作</h3><p>虽然是制作这个功能的工具蓝图，但是其实ue官方有自带的方法可以设置，可以通过这个来批量设置LOD<img src="https://cdn.nlark.com/yuque/0/2021/png/2623605/1635070283740-8ae8d579-81c3-4672-87d2-da6cfcda9a19.png?x-oss-process=image%2Fresize%2Cw_458%2Climit_0#averageHue=%233e3a33&amp;from=url&amp;id=imwbV&amp;originHeight=395&amp;originWidth=458&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt><br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661912602844-2a7618f6-6860-4175-9320-b8c4c197416e.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=264&amp;id=ucfae7bad&amp;originHeight=264&amp;originWidth=365&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22929&amp;status=error&amp;style=none&amp;taskId=u671b5b41-ce14-4f57-9113-dd712bf81dd&amp;title=&amp;width=365" alt="image.png">右键创建工具蓝图<img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661913305895-a9544bb7-7604-445a-82c8-9a37a2fb0f71.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=461&amp;id=u25184aa4&amp;originHeight=461&amp;originWidth=544&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54357&amp;status=error&amp;style=none&amp;taskId=ube79177a-5988-456d-ba08-4ff9b6ae623&amp;title=&amp;width=544" alt="image.png">Acotor是关卡中的所有物体，Asset是内容管理器（资产）中的所有物体。</p><p>蓝图介绍：其中setlods是一个函数，逻辑：获得选中的资产，遍历这些资产，指向资产的staticmesh，设置资产的Lod，设置lod的细节由结构体指定。   蓝图链接中的这个红线（布尔值）连接以后可以在调用工具蓝图时询问是否勾选（是否根据屏幕大小自动设置LOD距离）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940223846-8f7823ad-d1b2-4d47-9cf8-cc4cd6326f3b.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=624&amp;id=u3358132b&amp;originHeight=624&amp;originWidth=1539&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=213407&amp;status=error&amp;style=none&amp;taskId=u4dad998c-9ae4-4a54-94c8-a8deb1c4ab8&amp;title=&amp;width=1539" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661941175787-13dada01-a24d-498c-8cb9-d53a3a0c796a.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=234&amp;id=uca55f7a7&amp;originHeight=234&amp;originWidth=410&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=30892&amp;status=error&amp;style=none&amp;taskId=u5869f8a1-b4cf-4199-a898-51ba276ffe2&amp;title=&amp;width=410" alt="image.png"></p><h3 id="创建好后的使用方法："><a href="#创建好后的使用方法：" class="headerlink" title="创建好后的使用方法："></a>创建好后的使用方法：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940452299-ed118ce1-5822-4451-a4be-518ae9be1e9e.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=425&amp;id=uaa91e175&amp;originHeight=425&amp;originWidth=708&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=285822&amp;status=error&amp;style=none&amp;taskId=u7601f935-c485-432a-b9e4-18804b6f693&amp;title=&amp;width=708" alt="image.png"></p><h3 id="设置工具蓝图中的函数针对的类型"><a href="#设置工具蓝图中的函数针对的类型" class="headerlink" title="设置工具蓝图中的函数针对的类型"></a>设置工具蓝图中的函数针对的类型</h3><p>例如这里我们只需要设置staticmesh类型的LOD，不是staticmesh类型的就不需要显示这个工具，因此我们可以重载函数来达到这个目的：<br>选择函数，override<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940652571-a291adb9-22eb-4dc3-bde2-e0bf2e13f047.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=132&amp;id=u80fa3ce5&amp;originHeight=132&amp;originWidth=661&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25489&amp;status=error&amp;style=none&amp;taskId=u2fb60fdc-7e58-47a9-8eec-314daba2ad6&amp;title=&amp;width=661" alt="image.png"><br>设置返回类型为staticmesh<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940697865-5a4b48c0-85d9-419c-a693-1c81d8ae9f01.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=471&amp;id=ue1af49e2&amp;originHeight=471&amp;originWidth=1016&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80279&amp;status=error&amp;style=none&amp;taskId=u7b040ff4-5c8d-415a-9bcb-d8274266ffd&amp;title=&amp;width=1016" alt="image.png"></p><h2 id="随机设置关卡中选中物体的缩放和旋转"><a href="#随机设置关卡中选中物体的缩放和旋转" class="headerlink" title="随机设置关卡中选中物体的缩放和旋转"></a>随机设置关卡中选中物体的缩放和旋转</h2><h3 id="带UI控件的工具蓝图"><a href="#带UI控件的工具蓝图" class="headerlink" title="带UI控件的工具蓝图"></a>带UI控件的工具蓝图</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940800911-5edc3fec-220b-414d-8a44-9fd7e2a44d5a.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=313&amp;id=u77679664&amp;originHeight=313&amp;originWidth=725&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=58489&amp;status=error&amp;style=none&amp;taskId=u77ec5849-92a2-4160-9c59-1e10643e2fc&amp;title=&amp;width=725" alt="image.png"><br>设计好UI以后前往图表<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940829480-23cc7ab3-e4b8-40b1-b1ae-53eff5d92585.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=875&amp;id=u4c452c32&amp;originHeight=875&amp;originWidth=3440&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=193890&amp;status=error&amp;style=none&amp;taskId=u55fdec6b-a2aa-4e8e-b5ea-1294818191e&amp;title=&amp;width=3440" alt="image.png"></p><p>通过选择UI生成对应事件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940876656-bf79896f-0062-42a4-93c3-03469a5ac474.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=821&amp;id=u20c984c7&amp;originHeight=821&amp;originWidth=608&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54983&amp;status=error&amp;style=none&amp;taskId=u4ca80c03-7654-483f-9e13-4072a2453ec&amp;title=&amp;width=608" alt="image.png"></p><p>其中transact 的作用是使蓝图的操作可以撤回，这里就是当点击按钮时开始记录事件，每经过一次循环记录一次，最后循环完毕之后结束记录，然后就可以一键撤销这些记录的事件了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1661940907849-ad57c55e-0854-4b80-9eec-5693ee79f848.png#clientId=ue7509f0e-1736-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=1201&amp;id=u266ca0a2&amp;originHeight=1201&amp;originWidth=2077&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=364072&amp;status=error&amp;style=none&amp;taskId=u5eb5b0d0-8d20-42ad-8213-098cadc038b&amp;title=&amp;width=2077" alt="image.png"></p><h1 id="沿样条生成网格体"><a href="#沿样条生成网格体" class="headerlink" title="沿样条生成网格体"></a>沿样条生成网格体</h1><p>蓝图名字：BP_SplineLayoutTool<br>构造函数：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662354387305-a1cc6f8b-f3df-4cd1-9fe1-47a19a315e78.png#clientId=ub167d71c-7bdb-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=731&amp;id=u2fbfecc1&amp;originHeight=731&amp;originWidth=4283&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=415024&amp;status=error&amp;style=none&amp;taskId=ub33dce84-8110-4082-af4d-54ef422a5b5&amp;title=&amp;width=4283" alt="image.png"><br>自定义函数：LoacationAtIndex<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662354434038-51adf46a-b7ee-4105-8648-2912fee03ea2.png#clientId=ub167d71c-7bdb-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=431&amp;id=u6569d9dc&amp;originHeight=431&amp;originWidth=1413&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=94131&amp;status=error&amp;style=none&amp;taskId=u343d5834-5cd6-4f47-a172-cbde9f37d23&amp;title=&amp;width=1413" alt="image.png"><br>因为自定义函数不会改变关于蓝图的任何东西也不会调用其他函数，因此选择函数勾选Pure将函数设置为纯函数。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662354468655-8b368362-3dad-47c3-a133-9df4a1431cb3.png#clientId=ub167d71c-7bdb-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=245&amp;id=fXfeU&amp;originHeight=245&amp;originWidth=579&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14991&amp;status=error&amp;style=none&amp;taskId=u5dbe9501-5b06-40d3-be10-abea6ca4ee3&amp;title=&amp;width=579" alt="image.png"></p><h1 id="将选择的物体沿坐标轴复制粘贴"><a href="#将选择的物体沿坐标轴复制粘贴" class="headerlink" title="将选择的物体沿坐标轴复制粘贴"></a>将选择的物体沿坐标轴复制粘贴</h1><p>注意：这个工具只针对蓝图类型的，不支持staticMeshActor<br>一个小知识点：宏和函数的区别是宏可以有多个输出执行引脚<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662539901115-da92c353-8786-43d5-bea3-45152277067e.png#clientId=u9c96ba5d-7280-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=314&amp;id=uedff2ff7&amp;originHeight=314&amp;originWidth=402&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25028&amp;status=error&amp;style=none&amp;taskId=u0f7b091b-cd4d-475e-8fe9-178071b46dc&amp;title=&amp;width=402" alt="image.png"><br>事件图表：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662539915505-834516d2-8115-4bb3-9845-7129c4faa3b1.png#clientId=u9c96ba5d-7280-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=2050&amp;id=u1c0df55a&amp;originHeight=2050&amp;originWidth=1529&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=535266&amp;status=error&amp;style=none&amp;taskId=u9a8b82b5-1616-4317-bc97-35aaf0522af&amp;title=&amp;width=1529" alt="image.png"><br>宏：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662539928697-86058214-efe7-4f97-ac27-60d8ccf494cd.png#clientId=u9c96ba5d-7280-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=366&amp;id=ufb05fc5c&amp;originHeight=366&amp;originWidth=1016&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=62645&amp;status=error&amp;style=none&amp;taskId=uca1554cc-feb8-4bff-9418-ec41f96acc7&amp;title=&amp;width=1016" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662539937636-bbc9b977-5ade-4733-978e-a58b7ed22971.png#clientId=u9c96ba5d-7280-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=400&amp;id=ub0918bfa&amp;originHeight=400&amp;originWidth=1096&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66514&amp;status=error&amp;style=none&amp;taskId=u0b1e7a96-bae5-4693-8466-a41362f3516&amp;title=&amp;width=1096" alt="image.png"><br>自定义函数：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662539946786-b48fd023-9d68-4574-90aa-8ac0f33bc803.png#clientId=u9c96ba5d-7280-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=606&amp;id=u98ff73f0&amp;originHeight=606&amp;originWidth=2804&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=289212&amp;status=error&amp;style=none&amp;taskId=ufc3aa8bd-53ca-49ff-916d-451b8c01e03&amp;title=&amp;width=2804" alt="image.png"></p><h2 id="将函数改为能够复制staticMeshActor"><a href="#将函数改为能够复制staticMeshActor" class="headerlink" title="将函数改为能够复制staticMeshActor"></a>将函数改为能够复制staticMeshActor</h2><p>因为spawn actor from object 生成的actor是空的，除非object是蓝图类型的才可以，然后我改了一下使其能够复制生成staticMeshActor并且设置staticMeshComponent的内容了。<br>很简单，前面的不变就是改了下后面的，就是生成actor后使用staticMeshActor中的设置静态网格体和设置actor的缩放功能。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2623605/1662714796161-6e086a23-a1fb-43ac-91da-e31175574dc3.png#clientId=u0dfe74d5-8808-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=646&amp;id=uf397176d&amp;originHeight=646&amp;originWidth=3635&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=417968&amp;status=error&amp;style=none&amp;taskId=udc323732-7e31-414c-83fa-9a3e03cb895&amp;title=&amp;width=3635" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;好用的快捷键&quot;&gt;&lt;a href=&quot;#好用的快捷键&quot; class=&quot;headerlink&quot; title=&quot;好用的快捷键&quot;&gt;&lt;/a&gt;好用的快捷键&lt;/h1&gt;&lt;p&gt;q ：选中蓝图按</summary>
      
    
    
    
    <category term="UE开发" scheme="http://example.com/categories/UE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UE蓝图" scheme="http://example.com/tags/UE%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>UE开发总结</title>
    <link href="http://example.com/2023/10/20/UE%E5%BC%80%E5%8F%91-UE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-UE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/10/20/UE%E5%BC%80%E5%8F%91-UE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-UE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-20T06:30:00.000Z</published>
    <updated>2024-07-27T18:58:06.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些名词解释"><a href="#一些名词解释" class="headerlink" title="一些名词解释"></a>一些名词解释</h1><p>actor: level中的所有物体都可以称为actor<br>asset: contentBrowser中的所有物体都可以称为asset<br>assetName:     SM_Ramp<br>objectPath:    /Game/LevelPrototyping/Meshes/SM_Ramp.SM_Ramp<br>packageName:   /Game/LevelPrototyping/Meshes/SM_Ramp<br>packagePath:   /Game/LevelPrototyping/Meshes/<br>referencePath: /Script/Engine.StaticMesh’/Game/LevelPrototyping/Meshes/SM_Ramp.SM_Ramp’ (左边是Class,右边是objectPath)<br>property: 对象的属性名,pythonAPI的文档中凡是带有property提示的属性都可以直接通过obj.propertyName的形式来读取,不带的就只能通过get_editor_property方法来读了.<br>staticMesh对应的lod所对应的sections: sections是静态网格体对应的lod对应的网格体组成数量,因为静态网格体可能会是由多个网格组成的,因此有了sections这个名词.通常和id数相同.</p><h1 id="各个对象通用的方法"><a href="#各个对象通用的方法" class="headerlink" title="各个对象通用的方法"></a>各个对象通用的方法</h1><p>get_calss: 得到对应类<br>get_name: 得到AssetName<br>get_editor_property: 提供属性名,得到编辑器上显示的属性值<br>get_path_name: 得到objectPath</p><h1 id="unreal自身的方法"><a href="#unreal自身的方法" class="headerlink" title="unreal自身的方法"></a>unreal自身的方法</h1><p>load_asset: 提供Asset的objectPath或者packageName,然后将得到对应Asset类型的对象.<br>get_editor_subsystem: 提供EditorActorSubsystem的引用(就像这样:unreal.EditorActorSubsystem),然后就能得到EditorActorSubsystem的对象.<br>log:将给定的参数作为信息记录在LogPython类别中<br>log_error:将给定的参数记录为LogPython类别中的错误<br>log_warning: 将给定的参数作为警告记录在LogPython类别中</p><h1 id="没有模块"><a href="#没有模块" class="headerlink" title="没有模块"></a>没有模块</h1><p>ScopedSlowTask: 用于制作进度条.</p><pre><code class="lang-python">import unrealtotalFrames = 1000000textDisplay = &quot;i love python, an i guess i&#39;ll be using this for a while!&quot;with unreal.ScopedSlowTask(totalFrames, textDisplay) as ST:    ST.make_dialog(True)    for i in range(totalFrames):        if ST.should_cancel():            break        unreal.log(&quot;one step!!!!&quot;)        ST.enter_progress_frame(1)</code></pre><h1 id="ToolMenus模块"><a href="#ToolMenus模块" class="headerlink" title="ToolMenus模块"></a>ToolMenus模块</h1><h2 id="ToolMenus"><a href="#ToolMenus" class="headerlink" title="ToolMenus"></a>ToolMenus</h2><p>get: 得到ToolMenus类型的对象</p><h1 id="CoreUObject模块"><a href="#CoreUObject模块" class="headerlink" title="CoreUObject模块"></a>CoreUObject模块</h1><h2 id="AssetData"><a href="#AssetData" class="headerlink" title="AssetData"></a>AssetData</h2><p><strong>属性:</strong><br>asset_class: assetData对象所对应的类名,举例:StaticMesh(已知UE5.3已经弃用)<br>asset_class_path: 返回的类型为TopLevelAssetPath,这个类型有一个asset_name属性可以得到类名(作为asset_class的替代)</p><p><strong>方法:</strong><br>get_asset: 得到assetData对应的Asset对象</p><h1 id="Engine模块"><a href="#Engine模块" class="headerlink" title="Engine模块"></a>Engine模块</h1><h2 id="StaticMeshActor"><a href="#StaticMeshActor" class="headerlink" title="StaticMeshActor"></a>StaticMeshActor</h2><p><strong>属性:</strong><br>static_mesh_component: 得到staticMesh组件,类型为StaticMeshComponent</p><h2 id="StaticMeshComponent"><a href="#StaticMeshComponent" class="headerlink" title="StaticMeshComponent"></a>StaticMeshComponent</h2><p><strong>属性:</strong><br>static_mesh 得到静态网格体对象,类型为StaticMesh</p><p><strong>方法:</strong><br>get_num_materials: 得到材质的数量(这个方法是PrimitiveComponent的方法,但是StaticMeshComponent继承自它,因此可以使用)<br>set_material: 设置材质,需要提供序号(int)和材质实例的对象(MaterialInterface),这个方法同样是PrimitiveComponent的方法</p><h2 id="StaticMesh"><a href="#StaticMesh" class="headerlink" title="StaticMesh"></a>StaticMesh</h2><p><strong>属性:</strong><br>asset_import_data: 导入网格体时的数据和选项,返回对象类型为AssetImportData<br>lod_group: 网格体的lod组,返回类型为Name</p><p><strong>方法:</strong><br>get_num_lods: 得到静态网个体的lod数量,返回类型为int<br>get_num_sections: 提供lod序号(int值),得到网格体对应lod的对应分段数,分段数是指网格对应lod对应的</p><h2 id="AssetImportData"><a href="#AssetImportData" class="headerlink" title="AssetImportData"></a>AssetImportData</h2><p><strong>属性:</strong><br>extract_filenames: 得到资产导入时的路径,类型为字符串数组</p><p><strong>方法:</strong><br>get_export_text_name: 提供packageName得到其所对应的referencePath<br>get_asset: 得到assetData对应的asset对象</p><h1 id="EditorScriptingUtilities模块"><a href="#EditorScriptingUtilities模块" class="headerlink" title="EditorScriptingUtilities模块"></a>EditorScriptingUtilities模块</h1><h2 id="EditorAssetLibrary"><a href="#EditorAssetLibrary" class="headerlink" title="EditorAssetLibrary"></a>EditorAssetLibrary</h2><blockquote><p>此类提供针对内容浏览器的资产的相关方法</p></blockquote><p><strong>方法:</strong><br>list_assets: 提供文件夹路径然后得到文件夹路径下的所有objectPath<br>find_asset_data: 接收资产路径得到assetData(这个资产路径需要是packageName而不是objectPath)<br>duplicate_directory:接收两个packagePath,将第一个文件夹复制一份来得到第二个文件夹<br>delete_directory: 接收一个packagePath,删除文件夹<br>rename_directory: 接收两个packagePath,重命名文件夹<br>duplicate_asset: 接收两个packageName,将第一个Asset复制一份来得到第二个Asset<br>delete_asset: 接收一个packageName,删除对应asset<br>does_asset_exist: 接收一个packageName,检测对应Asset是否存在,返回布尔值<br>rename_asset: 接收两个packageName,重命名Asset<br>save_loaded_asset: 接收一个asset对象,用于保存<br>find_package_referencers_for_asset: 提供一个asset的packageName,然后得到其引用项的packageName的数组</p><h2 id="EditorLevelLibrary"><a href="#EditorLevelLibrary" class="headerlink" title="EditorLevelLibrary"></a>EditorLevelLibrary</h2><blockquote><p>此模块在4.27中可以使用,但是在UE5以后将要废弃,改用EditorActorSubsystem</p></blockquote><p><strong>方法:</strong><br>get_all_level_actors : 获取关卡中的所有Actor<br>spawn_actor_from_object: 生成一个Actor到关卡中,需要提供Object,Vector,Rotator.</p><h1 id="MaterialEditor模块"><a href="#MaterialEditor模块" class="headerlink" title="MaterialEditor模块"></a>MaterialEditor模块</h1><h2 id="MaterialEditingLibrary"><a href="#MaterialEditingLibrary" class="headerlink" title="MaterialEditingLibrary"></a>MaterialEditingLibrary</h2><p>set_material_instance_texture_parameter_value:设置材质实例的贴图纹理参数,需提供MaterialInstanceConstant类型的材质实例,Name类型的材质参数的名字,Texture类型的值.<strong>注意:通过代码设置参数不能够在编辑器中实时看到,需要关闭编辑器然后打开才行.</strong><br>set_material_instance_static_switch_parameter_value: 设置材质实例的贴图纹理参数是否启用,需提供MaterialInstanceConstant类型的材质实例,Name类型的材质参数的名字,Texture类型的值.</p><h1 id="Blutility模块"><a href="#Blutility模块" class="headerlink" title="Blutility模块"></a>Blutility模块</h1><h2 id="EditorUtilityLibrary"><a href="#EditorUtilityLibrary" class="headerlink" title="EditorUtilityLibrary"></a>EditorUtilityLibrary</h2><blockquote><p>此类提供针对内容浏览器的相关方法</p></blockquote><p><strong>方法:</strong><br>get_selected_assets: 得到内容浏览器种所选择的资产</p><h1 id="UnrealEd模块"><a href="#UnrealEd模块" class="headerlink" title="UnrealEd模块"></a>UnrealEd模块</h1><h2 id="EditorActorSubsystem"><a href="#EditorActorSubsystem" class="headerlink" title="EditorActorSubsystem"></a>EditorActorSubsystem</h2><blockquote><p>此类提供针对关卡中的Actor的方法,在UE5.3中更改了得到EditorActorSubsystem对象的方法,需要通过unreal.get_editor_subsystem(unreal.EditorActorSubsystem)来得到<br>举例:<br>EAS = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)<br>all_actors = EAS.get_all_level_actors()</p></blockquote><p><strong>方法:</strong><br>get_all_level_actors: 获取关卡中的所有Actor</p><h2 id="AssetImportTask"><a href="#AssetImportTask" class="headerlink" title="AssetImportTask"></a>AssetImportTask</h2><blockquote><p>资产导入的任务,包含了资产导入时的相关数据设置,<strong>只有属性,没有方法</strong></p></blockquote><p><strong>属性:</strong><br>automated: 布尔类型,设置为True时,不会弹出对话框<br>destination_name: 字符串类型,用来定义资产导入时的名称,当为空字符串时导入的资产以文件名称命名<br>destination_path: 字符串类型,用于设置导入的资产在引擎中的路径<br>filename: 字符串类型,导入的资产在本地硬盘上的的<strong>路径</strong><br>replace_existing: 布尔类型,导入的资产是否强制覆盖引擎已有资产<br>save: 布尔类型,导入资产后是否自动保存<br>imported_object_paths: 字符串数组类型,导入后的路径</p><h2 id="FbxImportUI"><a href="#FbxImportUI" class="headerlink" title="FbxImportUI"></a>FbxImportUI</h2><p><strong>属性:</strong><br>import_mesh: 布尔类型,是否导入mesh<br>import_textures : 布尔类型,是否导入贴图<br>import_materials: 布尔类型,如果没有找到对应的相关材质,是否自动创建材质球<br>import_as_skeletal: 布尔类型,是否将FBX作为骨架对象导入<br>import_animations: 布尔类型,是否导入动画<br>static_mesh_import_data:  FbxStaticMeshImportData类型,导入静态网格体时使用的数据<br>skeletal_mesh_import_data: FbxSkeletalMeshImportData类型,导入骨架网格体时使用的数据<br>anim_sequence_import_data: FbxAnimSequenceImportData类型,导入动画时使用的数据<br>skeleton: Skeleton类型,导入动画时,需要指定骨架</p><h2 id="FbxStaticMeshImportData"><a href="#FbxStaticMeshImportData" class="headerlink" title="FbxStaticMeshImportData"></a>FbxStaticMeshImportData</h2><p><strong>属性:</strong><br>import_translation: Vector类型,导入时的位移<br>import_rotation: Rotator类型,导入时的旋转<br>import_uniform_scale: float类型,导入时的统一缩放值<br>combine_meshes: 布尔类型,导入时是否将多个mesh合并成一个mesh<br>generate_lightmap_u_vs: 布尔类型,是否生成用于光照贴图的UV<br>auto_generate_collision: 布尔类型,是否自动生成碰撞</p><h2 id="FbxSkeletalMeshImportData"><a href="#FbxSkeletalMeshImportData" class="headerlink" title="FbxSkeletalMeshImportData"></a>FbxSkeletalMeshImportData</h2><p><strong>属性:</strong><br>import_translation: Vector类型,导入时的位移<br>import_rotation: Rotator类型,导入时的旋转<br>import_uniform_scale: float类型,导入时的统一缩放值<br>import_morph_targets: 布尔类型,是否导入变形目标(blendshape)<br>update_skeleton_reference_pose: 布尔类型,是否导入的时候更新骨架参考姿势</p><h2 id="anim-sequence-import-data"><a href="#anim-sequence-import-data" class="headerlink" title="anim_sequence_import_data"></a>anim_sequence_import_data</h2><p><strong>属性:</strong><br>import_translation: Vector类型,导入时的位移<br>import_rotation: Rotator类型,导入时的旋转<br>import_uniform_scale: float类型,导入时的统一缩放值<br>animation_length: FBXAnimationLengthImportType类型,导入动画的长度,有FBXALIT_ANIMATED_KEY,FBXALIT_EXPORTED_TIME,FBXALIT_SET_RANGE三种长度类型,具体见:<a href="https://docs.unrealengine.com/5.3/en-US/PythonAPI/class/FBXAnimationLengthImportType.html#unreal.FBXAnimationLengthImportType">FBXAnimationLengthImportType</a><br>remove_redundant_keys: 布尔类型,是否删除冗余帧</p><h2 id="MaterialFactoryNew"><a href="#MaterialFactoryNew" class="headerlink" title="MaterialFactoryNew"></a>MaterialFactoryNew</h2><p>用于创建一个用于Material工厂对象,用在assetTool的createAsset上面</p><h2 id="WorldFactory"><a href="#WorldFactory" class="headerlink" title="WorldFactory"></a>WorldFactory</h2><p>用于创建一个World工厂对象,用在assetTool的createAsset上面</p><h2 id="ParticleSystemFactoryNew"><a href="#ParticleSystemFactoryNew" class="headerlink" title="ParticleSystemFactoryNew"></a>ParticleSystemFactoryNew</h2><p>用于创建一个Particle System工厂对象,用在assetTool的createAsset上面</p><h2 id="BlueprintFactory"><a href="#BlueprintFactory" class="headerlink" title="BlueprintFactory"></a>BlueprintFactory</h2><p>用于创建一个Blueprint工厂对象,用在assetTool的createAsset上面</p><h2 id="MaterialInstanceConstantFactoryNew"><a href="#MaterialInstanceConstantFactoryNew" class="headerlink" title="MaterialInstanceConstantFactoryNew"></a>MaterialInstanceConstantFactoryNew</h2><p>用于创建一个材质实例工厂对象</p><h1 id="ProceduralMeshComponent模块"><a href="#ProceduralMeshComponent模块" class="headerlink" title="ProceduralMeshComponent模块"></a>ProceduralMeshComponent模块</h1><h2 id="ProceduralMeshLibrary"><a href="#ProceduralMeshLibrary" class="headerlink" title="ProceduralMeshLibrary"></a>ProceduralMeshLibrary</h2><p><strong>方法:</strong><br>get_section_from_static_mesh: 提供StaticMesh对象,lod索引,section索引得到对应的section的几何数据(vertices,triangles,normals,u_vs,tangents).</p><h1 id="AssetTools模块"><a href="#AssetTools模块" class="headerlink" title="AssetTools模块"></a>AssetTools模块</h1><h2 id="AssetToolsHelpers"><a href="#AssetToolsHelpers" class="headerlink" title="AssetToolsHelpers"></a>AssetToolsHelpers</h2><blockquote><p>只有一个作用,就是通过get_asset_tools方法得到AssetTools</p></blockquote><p>get_asset_tools: 得到AssetTools类型对象</p><h2 id="AssetTools"><a href="#AssetTools" class="headerlink" title="AssetTools"></a>AssetTools</h2><blockquote><p>AssetTools模块提供了针对Asset的一些功能,例如导入,导出,创建,复制,打开</p></blockquote><p><strong>方法:</strong><br>import_asset_tasks: 根据提供的AssetImportTask类型的对象的数组,进行导入资产操作.<br>duplicate_asset_with_dialog: 复制资产并带有对话框,提供三个参数,第一个是新复制出来的资产的AssetName,第二个是新复制出来的资产的PackageName,第三个是源资产的<strong>object</strong>,可以通过unreal.load_asset来得到对应Asset对象.<br>duplicate_asset: 复制资产但不带有对话框,参数跟duplicate_asset_with_dialog相同<br>rename_assets_with_dialog: 提供AssetRenameData类型的数据,批量对AssetRenameData中的数据进行重命名.<br>rename_assets: 不显示对话框的情况下重命名一组资产,与rename_assets_with_dialog使用方法相同<br>open_editor_for_assets: 提供Asset对象,从编辑器中打开对应资产<br>create_asset: 提供asset_name,package_path,asset_class,factory,创建Asset</p><h2 id="AssetRenameData"><a href="#AssetRenameData" class="headerlink" title="AssetRenameData"></a>AssetRenameData</h2><p>在使用AssetTools类中的rename_assets_with_dialog与rename_assets时需要.<br>通过unreal.AssetRenameData(source_object,new_package_path,new_asset_name)来创建一个AssetRenameData对象.<br>source_object为原资产的对象,new_package_path为新资产的文件夹路径,new_asset_name为新资产的名字.</p><h1 id="LevelSequenceEditor模块"><a href="#LevelSequenceEditor模块" class="headerlink" title="LevelSequenceEditor模块"></a>LevelSequenceEditor模块</h1><h2 id="LevelSequenceFactoryNew"><a href="#LevelSequenceFactoryNew" class="headerlink" title="LevelSequenceFactoryNew"></a>LevelSequenceFactoryNew</h2><p>用于创建一个用于ULevelSequence的工厂对象,用在assetTool的createAsset上面</p><h1 id="Paper2DEditor模块"><a href="#Paper2DEditor模块" class="headerlink" title="Paper2DEditor模块"></a>Paper2DEditor模块</h1><h2 id="PaperFlipbookFactory"><a href="#PaperFlipbookFactory" class="headerlink" title="PaperFlipbookFactory"></a>PaperFlipbookFactory</h2><p>用于创建flipbooks的工厂对象,用在assetTool的createAsset上面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些名词解释&quot;&gt;&lt;a href=&quot;#一些名词解释&quot; class=&quot;headerlink&quot; title=&quot;一些名词解释&quot;&gt;&lt;/a&gt;一些名词解释&lt;/h1&gt;&lt;p&gt;actor: level中的所有物体都可以称为actor&lt;br&gt;asset: contentBrowser中</summary>
      
    
    
    
    <category term="UE开发" scheme="http://example.com/categories/UE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UE开发" scheme="http://example.com/tags/UE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Maya后台执行脚本</title>
    <link href="http://example.com/2023/10/09/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-MayaPy-Maya%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    <id>http://example.com/2023/10/09/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-MayaPy-Maya%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/</id>
    <published>2023-10-09T08:09:00.000Z</published>
    <updated>2024-07-27T18:58:06.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不带界面的后台执行脚本方法"><a href="#不带界面的后台执行脚本方法" class="headerlink" title="不带界面的后台执行脚本方法"></a>不带界面的后台执行脚本方法</h1><p>这里提供一下后台执行python脚本的脚本模板<br>使用方法: </p><ol><li>将想要对maya后台执行的操作的命令写到模板文件的 # TODO:function content下面</li><li>win+r然后输入cmd打开命令行窗口</li><li>找到maya程序文件夹下的mayapy.exe文件,拖入到命令行窗口</li><li>打个空格,将后台执行的python脚本拖入到命令行窗口</li><li>因为模板里有通过sys.argv[1]来得到参数,模板的main函数中想要得到的参数是存放maya文件的文件夹路径,因此打个空格让后把文件夹拖入到命令行窗口中</li><li>按下回车,就可以遍历文件夹下的所有maya文件,然后执行你写的操作命令.</li><li>成功打开maya的列表信息会放到存放maya文件夹下的successful_open_files.json中,没有后台打开的maya文件信息会放到unsuccessful_open_files.json中.</li></ol><pre><code class="lang-python">#!/usr/bin/python# -*- coding: utf-8 -*-import osimport sysimport loggingimport reimport maya.standaloneimport maya.cmds as cmdsimport jsonmaya.standalone.initialize()logging.basicConfig(format=&quot;%(asctime)s %(levelname)-8s %(message)s&quot;,                    level=logging.WARNING, datefmt=&quot;%Y-%m-%d %H:%M:%S&quot;)def main(maya_file_dir_path):    # create json file.    successful_json_info = &#123;&#125;    unsuccessful_json_info = &#123;&#125;    successful_json_path = os.path.join(maya_file_dir_path,&quot;successful_open_files.json&quot;).replace(&quot;\\&quot;,&quot;/&quot;)    unsuccessful_json_path = os.path.join(maya_file_dir_path,&quot;unsuccessful_open_files.json&quot;).replace(&quot;\\&quot;,&quot;/&quot;)    load_successful_files = []    load_unsuccessful_files = []    # get maya file path list.    maya_file_path_list = []    maya_file_name_list = os.listdir(maya_file_dir_path)    if maya_file_name_list:        for file_name in maya_file_name_list:            if file_name.endswith(&quot;.ma&quot;):                maya_file_path = os.path.join(maya_file_dir_path,file_name).replace(&quot;\\&quot;,&quot;/&quot;)                maya_file_path_list.append(maya_file_path)    for maya_file_path in maya_file_path_list:        try:            cmds.file(maya_file_path, open=True, pmt=False)            logging.info(&quot;load file:&#123;&#125;&quot;.format(maya_file_path))            load_successful_files.append(maya_file_path)        except:            load_unsuccessful_files.append(maya_file_path)            continue        # TODO:function content    successful_json_info[&quot;load_file&quot;] = load_successful_files    unsuccessful_json_info[&quot;unload_file&quot;] = load_unsuccessful_files    with open(successful_json_path,&#39;w&#39;) as f:        json.dump(successful_json_info,f,indent=4)    with open(unsuccessful_json_path,&#39;w&#39;) as f:        json.dump(unsuccessful_json_info,f,indent=4)# maya.standalone.uninitialize()if __name__ == &quot;__main__&quot;:    main(sys.argv[1])</code></pre><hr><h1 id="带界面的后台执行脚本方法"><a href="#带界面的后台执行脚本方法" class="headerlink" title="带界面的后台执行脚本方法"></a>带界面的后台执行脚本方法</h1><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点:"></a>需要注意的点:</h2><ol><li>不能直接在脚本文件的顶部导入maya的模块(导入的其他模块中也不能包含maya的模块)</li><li>需要通过mayapy来执行窗口的建立，不然用其他解释器没有maya的模块</li><li>不能通过多线程的start功能来进行后台任务具体的步骤</li><li>通过窗口类来创建启动任务的子线程（可以用start），然后通过启动任务的子线程来执行后台操作（不可以用start，需要用run）</li><li>在用于启动后台操作的类中导入 maya.standalone 并执行 maya.standalone.initialize()</li><li>后台打开文件需要用pymel模块的openFile方法并且加上force=True，例如：pm.openFile(file_path,open=True,force=True)</li></ol><h2 id="大概步骤"><a href="#大概步骤" class="headerlink" title="大概步骤"></a>大概步骤</h2><ol><li>先正常通过pyside2写窗口的代码.</li><li>当需要调用后台执行操作的时候,就通过多线程来进行.</li><li>所有东西写完以后可以将所用东西进行打包成程序即可使用了.</li></ol><h2 id="子线程的类的定义"><a href="#子线程的类的定义" class="headerlink" title="子线程的类的定义:"></a>子线程的类的定义:</h2><p>这里的import MainWork as mainWork 是自定义的执行后台操作内容的脚本模块</p><pre><code class="lang-python">class StartWork(threading.Thread):    def __init__(self,path_item_dict,thread_lock):        threading.Thread.__init__(self)        self.path_item_dict = path_item_dict        self.thread_lock = thread_lock    def run(self):        self.thread_lock.acquire()        self.startWork()        self.thread_lock.release()    def startWork(self):        import maya.standalone        maya.standalone.initialize()        import MainWork as mainWork        for path,item in self.path_item_dict.items():            thread_lock = threading.Lock()            work_thread = mainWork.MainWork(path,thread_lock,item,my_signals)            work_thread.run()</code></pre><h2 id="调用子线程"><a href="#调用子线程" class="headerlink" title="调用子线程"></a>调用子线程</h2><p>这里的StartWork就是刚才定义的线程类</p><p>thread_lock = threading.Lock()<br>work_th = StartWork(path_item_dict, thread_lock)<br>work_th.start()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;不带界面的后台执行脚本方法&quot;&gt;&lt;a href=&quot;#不带界面的后台执行脚本方法&quot; class=&quot;headerlink&quot; title=&quot;不带界面的后台执行脚本方法&quot;&gt;&lt;/a&gt;不带界面的后台执行脚本方法&lt;/h1&gt;&lt;p&gt;这里提供一下后台执行python脚本的脚本模板&lt;br</summary>
      
    
    
    
    <category term="DCC工具开发" scheme="http://example.com/categories/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="MayaPy" scheme="http://example.com/tags/MayaPy/"/>
    
  </entry>
  
  <entry>
    <title>pyside2的一些归纳</title>
    <link href="http://example.com/2023/10/07/PySide2-PySide2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BD%92%E7%BA%B3/"/>
    <id>http://example.com/2023/10/07/PySide2-PySide2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BD%92%E7%BA%B3/</id>
    <published>2023-10-07T03:45:00.000Z</published>
    <updated>2024-07-27T18:58:06.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种文件对话框"><a href="#各种文件对话框" class="headerlink" title="各种文件对话框"></a>各种文件对话框</h1><p><strong>选择文件:</strong></p><pre><code class="lang-python">file_name,filetype = QFileDialog.getOpenFileName(self,&quot;这里是对话框的标题&quot;,&quot;这里文件对话框的起始路径&quot;,&quot;所有文件(*);;文本文件(*.txt);;maya文件(*.ma)&quot;)if not file_name:    return</code></pre><p><strong>选择多个文件:</strong></p><pre><code class="lang-python">files,filetype = QFileDialog.getOpenFileNames(self,&quot;对话框标题&quot;,&quot;对话框起始路径&quot;,&quot;所有文件(*);;文本文件(*.txt);;maya文件(*.ma)&quot;)if len(files) == 0:    return</code></pre><p><strong>保存文件:</strong></p><pre><code class="lang-python">file_name,filetype = QFileDialog.getSaveFileName(self,&quot;对话框标题&quot;,&quot;对话框起始路径&quot;,&quot;所有文件(*);;文本文件(*.txt);;maya文件(*.ma)&quot;)if not file_name:    return</code></pre><p><strong>选择文件夹:</strong></p><pre><code class="lang-python">folder_name = QFileDialog.getExistingDirectory(self,&quot;对话框标题&quot;,&quot;对话框起始路径&quot;)if not folder_name:    return</code></pre><hr><h1 id="各种信息对话框"><a href="#各种信息对话框" class="headerlink" title="各种信息对话框"></a>各种信息对话框</h1><p><strong>提示对话框:</strong></p><pre><code class="lang-python">reply = QMessageBox.infomation(self,&quot;对话框标题&quot;,&quot;对话框内容&quot;,QMessageBox.Ok | QMessageBox.Close, QMessageBox.Close)if reply == QMessageBox.Ok:    print(&quot;选择了Ok&quot;)else:    print(&quot;选择了Close&quot;)</code></pre><p><strong>询问对话框:</strong></p><pre><code class="lang-python">reply = QMessageBox.question(self,&quot;对话框标题&quot;,&quot;对话框内容&quot;,QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.No)</code></pre><p><strong>警告对话框:</strong></p><pre><code class="lang-python">reply = QMessageBox.warning(self,&quot;对话框标题&quot;,&quot;对话框内容&quot;,QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel, QMessageBox.Save)</code></pre><p><strong>错误对话框:</strong></p><pre><code class="lang-python">reply = QMessageBox.critical(self,&quot;对话框标题&quot;,&quot;对话框内容&quot;,QMessageBox.Retry | QMessageBox.About | QMessageBox.Ignore, QMessageBox.Retry)</code></pre><p><strong>自定义对话框</strong></p><pre><code class="lang-python">message_box = QMessageBox(QMessageBox.NoIcon,&quot;对话框标题&quot;,&quot;对话框内容&quot;)message_box.setIconPixmap(QPixmap(&quot;这里填图片路径&quot;))save_btn = message_box.addButton(&quot;保存&quot;,QMessageBox.AcceptRole)cancel_btn = message_box.addButton(&quot;取消&quot;,QMessageBox.RejectRole)no_save_btn = message_box.addButton(&quot;不保存&quot;,QMessageBox.DestructiveRole)cb = QCheckBox(&quot;自定义的控件&quot;)message_box.setCheckBox(cb)message_box.setDetailedText(&#39;通过点击ShowDetails按钮可以展开的详细信息&#39;)reply = message_box.exec()</code></pre><hr><h1 id="添加分割线"><a href="#添加分割线" class="headerlink" title="添加分割线"></a>添加分割线</h1><p><img src="/.com//image.png" alt="Alt text"></p><pre><code class="lang-python">self.line1 = QFrame()self.line1.setFrameShape(QFrame.HLine) # 横线，竖线是QFrame.VLineself.line1.setFrameShadow(QFrame.Sunken) # 设置阴影</code></pre><hr><h1 id="添加GroupBox-将不同模块区分开"><a href="#添加GroupBox-将不同模块区分开" class="headerlink" title="添加GroupBox(将不同模块区分开)"></a>添加GroupBox(将不同模块区分开)</h1><p><img src="/.com//image-1.png" alt="Alt text"></p><hr><h1 id="设置ListWidget的选择模式"><a href="#设置ListWidget的选择模式" class="headerlink" title="设置ListWidget的选择模式"></a>设置ListWidget的选择模式</h1><p>单选模式：setSelectionMode(QAbstractItemView.SingleSelection)<br>多选模式：setSelectionMode(QAbstractItemView.ExtendedSelection)</p><h1 id="给QListWidget的item添加自定义右键上下文菜单并支持往里面拖入文件添加item的例子"><a href="#给QListWidget的item添加自定义右键上下文菜单并支持往里面拖入文件添加item的例子" class="headerlink" title="给QListWidget的item添加自定义右键上下文菜单并支持往里面拖入文件添加item的例子"></a>给QListWidget的item添加自定义右键上下文菜单并支持往里面拖入文件添加item的例子</h1><p>代码解析:</p><ol><li>self.customContextMenuRequested.connect(self.show_context_menu)定义了item右键时显示的上下文菜单,在调用show_context_menu方法时会自动传入一个参数,这个参数是item的位置信息,因此就可以通过这个位置信息定义上下文菜单的位置</li><li>set_drop_enabled,dragEnterEvent,dragMoveEvent,dropEvent通过重写父类的方法来支持拖拽,并设置了拖入时执行的方法,其中dragMoveEvent函数内容虽然是pass,但是不能够不写,不然不行.</li><li>show_error_log函数之所以这样写,是因为我在使用item的同时我会通过item的setData的方法来对item写数据,其中error_role = Qt.UserRole + 1中的Qt.UserRole可以理解为Qt提供的一个固定的数值,它是一个整数值,方便用在使用item的setData方法时将数据放到item的哪个地方,因为放入item的数据不一定就放一个,可能会放很多个.因此我这里就以Qt.UserRole + 1当作起始点,然后通过while循环找到item对应的所有数据,有了数据以后就可以显示出来数据内容了.</li></ol><pre><code class="lang-python">class DropListWidget(QListWidget):    WIDGET_ITEMS = []    def __init__(self, parent=None):        super(DropListWidget, self).__init__(parent)        self.setContextMenuPolicy(Qt.CustomContextMenu)        self.customContextMenuRequested.connect(self.show_context_menu)            def set_drop_enabled(self, enabled):        self.setAcceptDrops(enabled)    def dragEnterEvent(self, drag_event):        mime_data = drag_event.mimeData()        if mime_data.hasText() or mime_data.hasUrls():            drag_event.acceptProposedAction()    def dragMoveEvent(self, drag_event):        pass    def dropEvent(self, drop_event):        mime_data = drop_event.mimeData()        urls = mime_data.urls()        paths = [url.toLocalFile() for url in urls if (url.toLocalFile().endswith(&quot;.ma&quot;) or os.path.isdir(url.toLocalFile()))]        paths.sort()        icon = QIcon(os.path.join(SCRIPT_DIR,&quot;icons&quot;,&quot;add.png&quot;))        for path in paths:            item = QListWidgetItem(icon,path)            self.addItem(item)            self.WIDGET_ITEMS.append(item)        drop_event.acceptProposedAction()    def show_context_menu(self, pos):        &quot;&quot;&quot; 让列表项能够右键显示菜单的内容 &quot;&quot;&quot;        selected_item = self.itemAt(pos)        if selected_item:            load_location_action = QAction(u&quot;进入本地路径&quot;,self)            load_location_action.triggered.connect(lambda:self.enter_local_path(selected_item))            error_log_action = QAction(u&quot;列出检查错误原因&quot;,self)            error_log_action.triggered.connect(lambda: self.show_error_log(selected_item))            context_menu = QMenu()            context_menu.addAction(load_location_action)            context_menu.addSeparator()  # 分割线            context_menu.addAction(error_log_action)            context_menu.exec_(self.mapToGlobal(pos))  # 右键显示菜单    def show_error_log(self,item):        &quot;&quot;&quot; 显示检查发现的错误项 &quot;&quot;&quot;        error_roles = []        error_role = Qt.UserRole + 1        while error_role:            if item.data(error_role):                error_roles.append(error_role)                error_role += 1            else:                break        if error_roles:            error_logs = []            for role in error_roles:                error_logs.append(item.data(role))            message_box = QMessageBox(self)            message_box.setWindowTitle(u&#39;错误项&#39;)            err_log = &quot;\n&quot;.join(error_logs)            message_box.setText(err_log)            message_box.show()    def enter_local_path(self,item):        &quot;&quot;&quot; 如果item对应路径是文件夹就进入文件夹,如果是路径就进入路径对应的文件目录 &quot;&quot;&quot;        item_path = item.text()        if os.path.isfile(item_path):            local_path = os.path.dirname(item_path)        else:            local_path = item_path        QDesktopServices.openUrl(QUrl.fromLocalFile(local_path))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;各种文件对话框&quot;&gt;&lt;a href=&quot;#各种文件对话框&quot; class=&quot;headerlink&quot; title=&quot;各种文件对话框&quot;&gt;&lt;/a&gt;各种文件对话框&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;选择文件:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-</summary>
      
    
    
    
    <category term="PySide2" scheme="http://example.com/categories/PySide2/"/>
    
    
    <category term="PySide2" scheme="http://example.com/tags/PySide2/"/>
    
  </entry>
  
  <entry>
    <title>MayaPy的一些补充(积累)</title>
    <link href="http://example.com/2023/09/26/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-MayaPy-MayaPy%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85-%E7%A7%AF%E7%B4%AF/"/>
    <id>http://example.com/2023/09/26/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-MayaPy-MayaPy%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85-%E7%A7%AF%E7%B4%AF/</id>
    <published>2023-09-25T16:09:00.000Z</published>
    <updated>2024-07-27T18:58:06.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获得需要的内容"><a href="#获得需要的内容" class="headerlink" title="获得需要的内容"></a>获得需要的内容</h1><h2 id="列举场景中的所有材质还有SG名称"><a href="#列举场景中的所有材质还有SG名称" class="headerlink" title="列举场景中的所有材质还有SG名称"></a>列举场景中的所有材质还有SG名称</h2><p>mats = cmds.lsThroughFilter( ‘DefaultMaterialsAndShaderGlowFilter’, na=True, sort=’byName’, reverse=True )<br>sgs = cmds.lsThroughFilter(‘DefaultShadingGroupsFilter’, na=True, sort=’byName’, reverse=True )</p><h2 id="获取时间滑块的最大最小值"><a href="#获取时间滑块的最大最小值" class="headerlink" title="获取时间滑块的最大最小值"></a>获取时间滑块的最大最小值</h2><p>max_time = cmds.playbackOptions(maxTime=True,q=True)<br>min_time = cmds.playbackOptions(minTime=True,q=True)</p><h2 id="查询当前场景的引用的资产的路径"><a href="#查询当前场景的引用的资产的路径" class="headerlink" title="查询当前场景的引用的资产的路径"></a>查询当前场景的引用的资产的路径</h2><pre><code class="lang-python">for ref_node in cmds.ls(type=&quot;reference&quot;):    try:                                                                 ref_path = cmds.referenceQuery(ref_node, f=True, un=True)    except:                                                              ref_path = &#39;&#39;                                                if ref_path:                                                         print(ref_path)</code></pre><h2 id="通过命令得到Maya的一些目录-应用程序目录-脚本目录-布局目录等"><a href="#通过命令得到Maya的一些目录-应用程序目录-脚本目录-布局目录等" class="headerlink" title="通过命令得到Maya的一些目录(应用程序目录,脚本目录,布局目录等)"></a>通过命令得到Maya的一些目录(应用程序目录,脚本目录,布局目录等)</h2><p>internalVar</p><h2 id="输出maya自带的所有png图片的名称"><a href="#输出maya自带的所有png图片的名称" class="headerlink" title="输出maya自带的所有png图片的名称"></a>输出maya自带的所有png图片的名称</h2><p>for item in cmds.resourceManager(nameFilter=”*png”): print(item)<br>知道了png图片的名字以后就可以通过这两个语句设置控件的图片:<br>select_file_path_btn = QtWidgets.QPushButton()<br>select_file_path_btn.setIcon(QtGui.QIcon(‘:fileOpen.png’))</p><h2 id="得到当前使用的摄像机名字"><a href="#得到当前使用的摄像机名字" class="headerlink" title="得到当前使用的摄像机名字"></a>得到当前使用的摄像机名字</h2><p>cmds.lookThru(q=True)</p><h2 id="得到当前maya文件使用的声音文件的名字与路径"><a href="#得到当前maya文件使用的声音文件的名字与路径" class="headerlink" title="得到当前maya文件使用的声音文件的名字与路径"></a>得到当前maya文件使用的声音文件的名字与路径</h2><pre><code class="lang-python">gPlayBackSlider = mel.eval(&#39;$tmpVar=$gPlayBackSlider&#39;)sound_name = cmds.timeControl(gPlayBackSlider, q=True, sound=True) # 声音文件的名字sound_path = cmds.sound(sound, q=True, file=True) # 声音文件的路径</code></pre><h2 id="得到maya插件的路径"><a href="#得到maya插件的路径" class="headerlink" title="得到maya插件的路径"></a>得到maya插件的路径</h2><p>cmds.pluginInfo(“mtoa.mll”,path=True,q=True)</p><h2 id="得到userSetup-mel的路径"><a href="#得到userSetup-mel的路径" class="headerlink" title="得到userSetup.mel的路径"></a>得到userSetup.mel的路径</h2><p>在mel里面运行 whatIs “userSetup.mel”</p><h2 id="列出场景中所有的灯光-包括arnold和redshift的灯光"><a href="#列出场景中所有的灯光-包括arnold和redshift的灯光" class="headerlink" title="列出场景中所有的灯光(包括arnold和redshift的灯光)"></a>列出场景中所有的灯光(包括arnold和redshift的灯光)</h2><p><strong>defaultNavigation这个命令也可以用来连接节点后面会有举例</strong><br>cmds.defaultNavigation(dtv=True,d=”defaultLightSet.dagSetMembers”)</p><h2 id="获取灯光链接的信息"><a href="#获取灯光链接的信息" class="headerlink" title="获取灯光链接的信息"></a>获取灯光链接的信息</h2><pre><code class="lang-python">all_lighting_list = cmds.defaultNavigation(dtv=True, d=&quot;defaultLightSet.dagSetMembers&quot;)cmds.editRenderLayerGlobals(currentRenderLayer=&#39;defaultRenderLayer&#39;)link_dic = &#123;&#125;all_shapes = [s for s in cmds.ls(type=&#39;geometryShape&#39;, ni=1) if             not s in all_lighting_list]use_lighting_list = []for lgt in all_lighting_list:    try:        cmds.referenceQuery(lgt, rfn=True)    except:        use_lighting_list.append(lgt)for lgt in use_lighting_list:    light_link_shapes = cmds.lightlink(query=True, light=lgt, shp=1, t=0, set=0, h=0)</code></pre><h2 id="得到所有非默认摄像机的摄像机名字"><a href="#得到所有非默认摄像机的摄像机名字" class="headerlink" title="得到所有非默认摄像机的摄像机名字"></a>得到所有非默认摄像机的摄像机名字</h2><pre><code class="lang-python">cameras = cmds.ls(type=(&#39;camera&#39;), l=True)startup_cameras = [cam for cam in cameras if cmds.camera(cmds.listRelatives(cam,p=True), startupCamera=True, q=True)]non_startup_cameras = [cmds.listRelatives(cam,p=True,f=True)[0] for cam in list(set(cameras)-set(startup_cameras))]</code></pre><hr><h1 id="maya渲染相关设置"><a href="#maya渲染相关设置" class="headerlink" title="maya渲染相关设置"></a>maya渲染相关设置</h1><h2 id="设置场景的渲染摄像机"><a href="#设置场景的渲染摄像机" class="headerlink" title="设置场景的渲染摄像机"></a>设置场景的渲染摄像机</h2><pre><code class="lang-python">cmds.setAttr(&#39;perspShape.renderable&#39;,0) # 先将原来的渲染摄像机对应属性设置为0cmds.setAttr(&#39;cameraShape1.renderable&#39;,1)</code></pre><h2 id="设置场景的渲染分辨率"><a href="#设置场景的渲染分辨率" class="headerlink" title="设置场景的渲染分辨率"></a>设置场景的渲染分辨率</h2><p>cmds.setAttr(“defaultResolution.width”, 1920)<br>cmds.setAttr(“defaultResolution.height”, 1080)</p><h2 id="设置场景的渲染文件输出路径"><a href="#设置场景的渲染文件输出路径" class="headerlink" title="设置场景的渲染文件输出路径"></a>设置场景的渲染文件输出路径</h2><p>cmds.setAttr(‘defaultRenderGlobals.imageFilePrefix’)</p><h2 id="设置redshift的aov"><a href="#设置redshift的aov" class="headerlink" title="设置redshift的aov"></a>设置redshift的aov</h2><pre><code class="lang-python"># 删除所有AOVsall_aovs = cmds.ls(type=&#39;RedshiftAOV&#39;)for aov in all_aovs:    enabled = cmds.getAttr(&#39;%s.enabled&#39; % aov)    if enabled:        cmds.delete(aov)# 新增AOV的过程：        ## 新增一个 Beauty 通道 mel.eval(&#39;redshiftCreateAov &quot;Beauty&quot;&#39;)## 刷新Aov显示的列表mel.eval(&quot;redshiftUpdateActiveAovList&quot;)</code></pre><h2 id="列举材质编辑器中的节点的所有上游节点"><a href="#列举材质编辑器中的节点的所有上游节点" class="headerlink" title="列举材质编辑器中的节点的所有上游节点"></a>列举材质编辑器中的节点的所有上游节点</h2><p>cmds.hyperShade(lun=’lambert1’)</p><h2 id="切换渲染层"><a href="#切换渲染层" class="headerlink" title="切换渲染层"></a>切换渲染层</h2><p>cmds.editRenderLayerGlobals(currentRenderLayer)</p><h2 id="得到渲染层下的所有对象"><a href="#得到渲染层下的所有对象" class="headerlink" title="得到渲染层下的所有对象"></a>得到渲染层下的所有对象</h2><p>cmds.editRenderLayerMembers(render_layer,q=True,fn=True)</p><h2 id="得到渲染层的所有渲染属性覆盖"><a href="#得到渲染层的所有渲染属性覆盖" class="headerlink" title="得到渲染层的所有渲染属性覆盖"></a>得到渲染层的所有渲染属性覆盖</h2><pre><code class="lang-python">overrides = cmds.listConnections(render_layer + &#39;.adjustments&#39;,p=True, c=True)if overrides:    attr_value = []    for i in range(0,len(overrides), 2):        conn = overrides[i] # returns &#39;layer.adjustments[#].plug&#39;        attr_name = overrides[i+1]        override_index = conn.split(&#39;]&#39;)[0].split(&#39;[&#39;)[-1]        override_value = cmds.getAttr(render_layer + &#39;.adjustments[&#123;&#125;].value&#39;.format(override_index))        attr_value.append([attr_name,override_value])          render_layer_info_dic[render_layer][&quot;attrOverride&quot;] = attr_valueelse:    render_layer_info_dic[render_layer][&quot;attrOverride&quot;] = []</code></pre><h2 id="设置当前渲染器的使用"><a href="#设置当前渲染器的使用" class="headerlink" title="设置当前渲染器的使用"></a>设置当前渲染器的使用</h2><p>cmds.setAttr(“defalutRenderGlobals.currentRenderer”,”redshift”,typ=”string”)</p><hr><h1 id="Maya的节点操作"><a href="#Maya的节点操作" class="headerlink" title="Maya的节点操作"></a>Maya的节点操作</h1><h2 id="锁定和解锁节点"><a href="#锁定和解锁节点" class="headerlink" title="锁定和解锁节点"></a>锁定和解锁节点</h2><p>lockNode</p><h2 id="清理场景中未使用的节点"><a href="#清理场景中未使用的节点" class="headerlink" title="清理场景中未使用的节点"></a>清理场景中未使用的节点</h2><p>mel.eval(‘hyperShadePanelMenuCommand(“hyperShadePanel1”,”deleteUnusedNodes”);’)</p><h2 id="清理未知节点"><a href="#清理未知节点" class="headerlink" title="清理未知节点"></a>清理未知节点</h2><pre><code class="lang-python">unknownNodes = cmds.ls(typ=&#39;unknown&#39;)if unknownNodes:    for node in unknownNodes:        if cmds.objExists(node):            lockState = cmds.lockNode(node, q=True, l=True)            if lockState[0] == 1:                cmds.lockNode(node, l=False)            cmds.delete(node)</code></pre><hr><h1 id="Maya材质编辑器中的相关操作"><a href="#Maya材质编辑器中的相关操作" class="headerlink" title="Maya材质编辑器中的相关操作"></a>Maya材质编辑器中的相关操作</h1><h2 id="通过命令创建aiStandardSurface材质"><a href="#通过命令创建aiStandardSurface材质" class="headerlink" title="通过命令创建aiStandardSurface材质"></a>通过命令创建aiStandardSurface材质</h2><pre><code class="lang-python">import maya.cmds as cmdsaiStandardSurfaceMat = cmds.shadingNode(&#39;aiStandardSurface&#39;, asShader=True)aiStandardSurfaceSG  = cmds.sets(renderable=True, noSurfaceShader=True, empty=True, name=aiStandardSurfaceMat + &quot;SG&quot;)cmds.connectAttr(aiStandardSurfaceMat+&#39;.outColor&#39;, aiStandardSurfaceSG+&#39;.surfaceShader&#39; )</code></pre><h2 id="通过SG节点的名字找到它对应的材质名字"><a href="#通过SG节点的名字找到它对应的材质名字" class="headerlink" title="通过SG节点的名字找到它对应的材质名字"></a>通过SG节点的名字找到它对应的材质名字</h2><p>mat = cmds.listConnections(sg节点的名字 + ‘.surfaceShader’)[0]  </p><h2 id="通过材质名字找到它上游所有类型为file的节点"><a href="#通过材质名字找到它上游所有类型为file的节点" class="headerlink" title="通过材质名字找到它上游所有类型为file的节点"></a>通过材质名字找到它上游所有类型为file的节点</h2><p>fileNodes = [x for x in cmds.hyperShade(lun=材质名字) if cmds.nodeType(x) == ‘file’] </p><h2 id="让maya判断节点类型并自动进行连接"><a href="#让maya判断节点类型并自动进行连接" class="headerlink" title="让maya判断节点类型并自动进行连接"></a>让maya判断节点类型并自动进行连接</h2><p>例如创建两个节点,一个文件节点,一个纹理节点,让它们两个进行连接.以此来复现将图片拖入到材质编辑器的操作.<br>file_node = cmds.shadingNode(“file”,asTexture=True,isColorManaged=True)<br>tex_node = cmds.shadingNode(“place2dTexture”,asUtility=True)<br>cmds.defaultNavigation(connectToExisting=True, source=tex_node, destination=file_node)<br>通过使用这个命令就可以一个命令就将需要连接的属性连好.不需要一个个通过属性名字连接</p><hr><h1 id="Maya文件操作"><a href="#Maya文件操作" class="headerlink" title="Maya文件操作"></a>Maya文件操作</h1><h2 id="abc缓存导入导出"><a href="#abc缓存导入导出" class="headerlink" title="abc缓存导入导出"></a>abc缓存导入导出</h2><p>AbcImport与AbcExport，这两个命令无法在帮助文档中找到，但是可以在maya脚本编辑器中通过命令中的help方法来得到命令的帮助信息。</p><hr><h1 id="Maya模型相关"><a href="#Maya模型相关" class="headerlink" title="Maya模型相关"></a>Maya模型相关</h1><h2 id="模型细分的命令"><a href="#模型细分的命令" class="headerlink" title="模型细分的命令"></a>模型细分的命令</h2><p>这里的smthRes不是细分后的模型名字而是细分的命令节点，mesh_name是要细分的模型:<br>smthRes = cmds.polySmooth(mesh_name, mth=0, sdt=2, ovb=1, ofb=3, ofc=0, ost=0, ocr=0, dv=1, bnr=1, c=1, kb=1,<br>ksb=1, khe=0, kt=1, kmb=1, suv=1, peh=0, sl=1, dpe=1, ps=0.1, ro=1, ch=1)[0]</p><hr><h1 id="Maya本身的设置"><a href="#Maya本身的设置" class="headerlink" title="Maya本身的设置"></a>Maya本身的设置</h1><h2 id="接触引用的锁定"><a href="#接触引用的锁定" class="headerlink" title="接触引用的锁定"></a>接触引用的锁定</h2><p>mel.eval(“referenceEdUnlockCB”)</p><h2 id="无法切换渲染层时使用的命令"><a href="#无法切换渲染层时使用的命令" class="headerlink" title="无法切换渲染层时使用的命令"></a>无法切换渲染层时使用的命令</h2><p>mel.eval(“fixRenderLayerOutAdjustmentErrors”)</p><h2 id="设置maya的场景单位和轴向"><a href="#设置maya的场景单位和轴向" class="headerlink" title="设置maya的场景单位和轴向"></a>设置maya的场景单位和轴向</h2><p>(<a href="https://blog.csdn.net/weixin_30908707/article/details/96321064">https://blog.csdn.net/weixin_30908707/article/details/96321064</a>)<br>cmds.currentUnit( linear=’in’ )  </p><hr><h1 id="其他代码编写相关"><a href="#其他代码编写相关" class="headerlink" title="其他代码编写相关"></a>其他代码编写相关</h1><h2 id="通过命令将一连串的命令执行只需要一次ctrl-z就可以全部返回到未进行命令过程的状态"><a href="#通过命令将一连串的命令执行只需要一次ctrl-z就可以全部返回到未进行命令过程的状态" class="headerlink" title="通过命令将一连串的命令执行只需要一次ctrl+z就可以全部返回到未进行命令过程的状态"></a>通过命令将一连串的命令执行只需要一次ctrl+z就可以全部返回到未进行命令过程的状态</h2><p>cmds.undoInfo(ock=1, cn=’test’)<br>执行的代码<br>cmds.undoInfo(cck=1, cn=’test’)</p><h2 id="解决搜索不到当前文件路径的问题"><a href="#解决搜索不到当前文件路径的问题" class="headerlink" title="解决搜索不到当前文件路径的问题"></a>解决搜索不到当前文件路径的问题</h2><p>有时候通过cmds.file(q=True,sn=True)得到的是个空的路径，为了解决这个问题可以通过这个命令替代：<br>cmds.file(query=True, l=True)[0]<br>但是这个命令也不是最优解,有遇到一使用这个命令就崩溃的情况所以获取文件路径推荐两个一起用:</p><pre><code class="lang-python">current_file_path = cmds.file(q=True,sn=True)if not current_file_path:    current_file_path = cmds.file(q=True,l=True)[0]</code></pre><h2 id="确保加载对应的插件的命令"><a href="#确保加载对应的插件的命令" class="headerlink" title="确保加载对应的插件的命令"></a>确保加载对应的插件的命令</h2><p>cmds.loadPlugin(“animImportExport.mll”, qt=True)</p><hr><h1 id="Maya界面UI相关命令"><a href="#Maya界面UI相关命令" class="headerlink" title="Maya界面UI相关命令"></a>Maya界面UI相关命令</h1><h2 id="创建一个显示一段时间后消失的弹窗-方便用于提示信息"><a href="#创建一个显示一段时间后消失的弹窗-方便用于提示信息" class="headerlink" title="创建一个显示一段时间后消失的弹窗(方便用于提示信息)"></a>创建一个显示一段时间后消失的弹窗(方便用于提示信息)</h2><p>cmds.inViewMessage( amg=”不高亮的部分: <hl style="color: red;">“ + “内容内容内容内容内容内容” +  “</hl>.”, pos=’midCenter’, fade=True )</p><h2 id="通过menuItem的名字找到对应menu"><a href="#通过menuItem的名字找到对应menu" class="headerlink" title="通过menuItem的名字找到对应menu"></a>通过menuItem的名字找到对应menu</h2><p>主要方法: cmds.menuItem(_menuItem, query=True,label=True)<br>也可以直接找menu的名字: cmds.menu(menu_name, query=True,label=True)</p><pre><code class="lang-python">def getParentMenu(menuItemName):    menuBars = cmds.lsUI(menus=True)    for _menu in menuBars:        menuItemList = cmds.menu(_menu,query=True,itemArray=True)        if menuItemList:            for _menuItem in menuItemList:                 if menuItemName == cmds.menuItem(_menuItem, query=True,label=True):                    return _menu    return None# 通过Wireframe找到对应menu的名字shading_menu = getParentMenu(&quot;Wireframe&quot;)# 在menu下创建新的menuItemcmds.menuItem(parent=shading_menu,label=&#39;my_menu&#39;)</code></pre><h2 id="创建自定义菜单"><a href="#创建自定义菜单" class="headerlink" title="创建自定义菜单"></a>创建自定义菜单</h2><pre><code class="lang-python">if cmds.menu(&#39;myMenu&#39;, exists=True):    cmds.deleteUI(&#39;myMenu&#39;)my_menu = cmds.menu(&#39;myMenu&#39;,parent=&quot;MayaWindow&quot;,tearOff=True,label=&quot;MyCustomMenu&quot;)cmds.menuItem(parent=my_menu,subMenu=True,label=&#39;menu1&#39;)cmds.menuItem(label=&#39;submenu1&#39;,command=&#39;print(&quot;submenu1&quot;)&#39;)cmds.menuItem(label=&#39;submenu2&#39;,command=&#39;print(&quot;submenu2&quot;)&#39;)cmds.menuItem(parent=my_menu,label=&#39;menu2&#39;)cmds.menuItem(parent=my_menu,subMenu=True,label=&#39;menu3&#39;)cmds.menuItem(label=&#39;submenu3&#39;,command=&#39;print(&quot;submenu3&quot;)&#39;)</code></pre><h2 id="兼容maya低版本和高版本的UI一些设置"><a href="#兼容maya低版本和高版本的UI一些设置" class="headerlink" title="兼容maya低版本和高版本的UI一些设置"></a>兼容maya低版本和高版本的UI一些设置</h2><pre><code class="lang-python">if sys.version_info.major &lt; 3:    maya_main_window = wrapInstance(long(omui.MQtUtil.mainWindow()), QtWidgets.QWidget)else:    maya_main_window = wrapInstance(int(omui.MQtUtil.mainWindow()), QtWidgets.QWidget)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;获得需要的内容&quot;&gt;&lt;a href=&quot;#获得需要的内容&quot; class=&quot;headerlink&quot; title=&quot;获得需要的内容&quot;&gt;&lt;/a&gt;获得需要的内容&lt;/h1&gt;&lt;h2 id=&quot;列举场景中的所有材质还有SG名称&quot;&gt;&lt;a href=&quot;#列举场景中的所有材质还有SG名称&quot;</summary>
      
    
    
    
    <category term="DCC工具开发" scheme="http://example.com/categories/DCC%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="MayaPy" scheme="http://example.com/tags/MayaPy/"/>
    
  </entry>
  
  <entry>
    <title>UEC++Plugin</title>
    <link href="http://example.com/2023/09/19/UE%E5%BC%80%E5%8F%91-UEC-Plugin/"/>
    <id>http://example.com/2023/09/19/UE%E5%BC%80%E5%8F%91-UEC-Plugin/</id>
    <published>2023-09-19T02:23:00.000Z</published>
    <updated>2024-07-27T18:58:06.875Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="关于有讨论的UE5-2右键不显示脚本化资本行为的解决办法"><a href="#关于有讨论的UE5-2右键不显示脚本化资本行为的解决办法" class="headerlink" title="关于有讨论的UE5.2右键不显示脚本化资本行为的解决办法"></a>关于有讨论的UE5.2右键不显示脚本化资本行为的解决办法</h1><p><img src="/.com//image-16.png" alt="Alt text"><br><strong>解决办法:</strong><br>首先在内容管理器里创建两个蓝图类,分别继承的父类选择AssetActionUtility,和自己创建的继承AssetActionUtility的C++类,然后再创建一个编辑器工具蓝图继承AssetActionUtility(如果不行就继承自己创建的类)<br>然后自己创建的C++类就会出现在脚本化资本行为里面了.<br><strong>过程截图:</strong><br><img src="/.com//image-19.png" alt="Alt text"></p><hr><h1 id="VS与UE进行实时编码的过程"><a href="#VS与UE进行实时编码的过程" class="headerlink" title="VS与UE进行实时编码的过程"></a>VS与UE进行实时编码的过程</h1><p>在VS里面敲好代码以后,运行调试后会弹出UE编辑器,然后通过UE编辑器可以进行代码功能的验证,但是如果验证过程中发现了需要修改代码的情况时,不需要关闭UE编辑器再进行代码修改然后再次调试.<strong>VS与UE是可以进行实时编码的</strong><br>例如当调试代码发现有问题时,可以直接在VS里面进行代码修改,修改完成以后按ctrl+shift+s保存代码的修改,然后按ctrl+alt+F11即可完成代码修改与UE编辑器的实时连接.然后再次对功能进行调试即可.</p><hr><h1 id="module模块的介绍"><a href="#module模块的介绍" class="headerlink" title="module模块的介绍"></a>module模块的介绍</h1><blockquote><p>官网的解释:<br><a href="https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-modules/">https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-modules/</a><br><a href="https://docs.unrealengine.com/5.3/zh-CN/module-properties-in-unreal-engine/">https://docs.unrealengine.com/5.3/zh-CN/module-properties-in-unreal-engine/</a></p></blockquote><p>总结而讲就是:</p><ul><li>模块实现了良好的代码分离</li><li>模块都需要一个[模块名]Build.cs的构建文件.</li><li>外部的模块的包含是通过加入到Build.cs文件来实现的,加入到Build.cs后就可以通过头文件来包含.</li></ul><hr><h1 id="创建一个空的针对editor的plugin"><a href="#创建一个空的针对editor的plugin" class="headerlink" title="创建一个空的针对editor的plugin"></a>创建一个空的针对editor的plugin</h1><p>点击创建后即可在VS里面创建相关plugin文件.<br><img src="/.com//image.png" alt="Alt text"><br><img src="/.com//image-1.png" alt="Alt text"></p><hr><p>修改Plugin的设置:<br>双击进入SuperManager.uplugin文件<br><img src="/.com//image-2.png" alt="Alt text"></p><hr><p>修改其中的模块的类型和加载阶段<br>修改类型为Editor意思是它不会对游戏模块产生影响,它是针对编辑器的.<br>修改加载阶段为PreDefault意思是它会在游戏模块之前加载.<br><img src="/.com//image-3.png" alt="Alt text"></p><hr><h1 id="plugin内容的简介"><a href="#plugin内容的简介" class="headerlink" title="plugin内容的简介"></a>plugin内容的简介</h1><p><strong>plugin类型:</strong><br>plugin分为针对Asset的和针对Acotr的.<br>Asset意思是在(Content Browser)内容浏览器里面的资产<br>Actor意思是在关卡里面放置的资产<br>要创建针对Asset的插件就需要继承AssetActionUtility类<br>要创建针对Actor的插件就需要继承ActorActionUtility类<br><strong>plugin相关的宏:</strong><br>UFUNCTION(CallInEditor),加入这个宏以后,当我们右键单击资产时,将添加一个按钮,我们可以使用这个按钮来触发自定义编辑器的功能.通过这个宏可以节省自己注册所有菜单项的所有时间和麻烦.</p><hr><h1 id="为刚才的Plugin添加一个向屏幕打印debug信息的功能"><a href="#为刚才的Plugin添加一个向屏幕打印debug信息的功能" class="headerlink" title="为刚才的Plugin添加一个向屏幕打印debug信息的功能"></a>为刚才的Plugin添加一个向屏幕打印debug信息的功能</h1><p>首先为刚才创建的空Plugin(自定义的名字叫SuperManager)创建一个类,并且选择继承AssetActionUtility<br><img src="/.com//image-4.png" alt="Alt text"><br><img src="/.com//image-5.png" alt="Alt text"><br><img src="/.com//image-6.png" alt="Alt text"></p><hr><p>创建好以后在VS中会生成如下结构:<br><img src="/.com//image-7.png" alt="Alt text"><br>QuickAssetAction本身具备一定量的初始代码,在其基础上添加新的功能.<br>由于是继承UAssetActionUtility,因此包含了头文件,需要知道其位置在哪里,不然无法编译.</p><h2 id="寻找UAssetActionUtility头文件的位置"><a href="#寻找UAssetActionUtility头文件的位置" class="headerlink" title="寻找UAssetActionUtility头文件的位置"></a>寻找UAssetActionUtility头文件的位置</h2><p>首先在解决方案资源管理器中搜索AssetActionUtility的位置,由下图可以得知它是属于Blutility模块的,在PublicDependencyModuleNames中添加Blutility进行生成,生成时发现依然不成功,那么就代表它是一个私有的路径,因此需要在PrivateIncludePaths中添加它的详细路径<br><img src="/.com//image-9.png" alt="Alt text"><br>也可以通过番茄助手使用alt+shift+o来进行搜索得到路径.<br><img src="/.com//image-11.png" alt="Alt text"><br>因此在SuperManager.Build.cs文件中的PrivateIncludePaths与PublicDependencyModuleNames添加一些代码:</p><h2 id="SuperManager-Build-cs"><a href="#SuperManager-Build-cs" class="headerlink" title="SuperManager.Build.cs"></a>SuperManager.Build.cs</h2><pre><code class="lang-cpp">PrivateIncludePaths.AddRange(    new string[] &#123;        System.IO.Path.GetFullPath(Target.RelativeEnginePath) + &quot;/Source/Editor/Blutility/Private&quot;        // ... add other private include paths required here ...    &#125;    );PublicDependencyModuleNames.AddRange(    new string[]    &#123;        &quot;Core&quot;,&quot;Blutility&quot;        // ... add other public dependencies that you statically link with here ...    &#125;    );</code></pre><h2 id="QuickAssetAction-h"><a href="#QuickAssetAction-h" class="headerlink" title="QuickAssetAction.h"></a>QuickAssetAction.h</h2><pre><code class="lang-cpp">// Fill out your copyright notice in the Description page of Project Settings.#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;AssetActionUtility.h&quot;#include &quot;QuickAssetAction.generated.h&quot;/** *  */UCLASS()class SUPERMANAGER_API UQuickAssetAction : public UAssetActionUtility&#123;    GENERATED_BODY()public:    UFUNCTION(CallInEditor) //使用这个宏来让此函数能够在编辑器中访问    void TestFunc();&#125;;</code></pre><h2 id="QuickAssetAction-cpp"><a href="#QuickAssetAction-cpp" class="headerlink" title="QuickAssetAction.cpp"></a>QuickAssetAction.cpp</h2><pre><code class="lang-cpp">// Fill out your copyright notice in the Description page of Project Settings.#include &quot;AssetActions/QuickAssetAction.h&quot;void UQuickAssetAction::TestFunc()&#123;    if(GEngine)    &#123;        GEngine-&gt;AddOnScreenDebugMessage(-1, 8.0f, FColor::Cyan, TEXT(&quot;Working&quot;)); // 向屏幕打印信息    &#125;&#125;</code></pre><hr><h1 id="创建负责方便调试的头文件"><a href="#创建负责方便调试的头文件" class="headerlink" title="创建负责方便调试的头文件"></a>创建负责方便调试的头文件</h1><p>在plugin的新建的SuperManager功能的public文件夹下新建一个头文件<br><img src="/.com//image-8.png" alt="Alt text"></p><hr><p>新建头文件并写好代码以后,include这个头文件就可以使用头文件里定义的方法.<br>头文件代码如下:</p><pre><code class="lang-cpp">#pragma oncevoid Print(const FString&amp; Message, const FColor&amp; Color)&#123;    if (GEngine)    &#123;        GEngine-&gt;AddOnScreenDebugMessage(-1, 8.0f, Color, Message); // 向屏幕打印信息    &#125;&#125;void PrintLog(const FString&amp; Message)&#123;    UE_LOG(LogTemp, Warning, TEXT(&quot;%s&quot;), *Message); // 向日志打印信息&#125;</code></pre><hr><h1 id="资产批量复制"><a href="#资产批量复制" class="headerlink" title="资产批量复制"></a>资产批量复制</h1><p><strong>实现效果:</strong><br><img src="/.com//image-13.png" alt="Alt text"><br><strong>用到的两个库以及对应的常用的函数:</strong><br>通过代码能够得知这几个静态函数的作用以及类型,其中FAssetData类型的数据比UObject*类型的数据包含的内容更多.<br><img src="/.com//image-10.png" alt="Alt text"></p><hr><p><strong>UE数据的一些名词解释:</strong></p><p>由图可知ObjectPath的结尾是BP_NewBlueprint.BP_NewBlueprint,是需要在AssetName的基础上多加一个AssetName的格式<br>除了AssetName和ObjectPath和PackagePath以外还有个叫PackageName<br>PackageName:/Game/MyFolder/BP_NewBlueprint<br><img src="/.com//image-12.png" alt="Alt text"></p><hr><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>首先由于要使用UEditorUtilityLibrary和UEditorAssetLibrary,所以要包含这两个头文件,然后通过查询头文件路径可以得知需要额外包含的模块为EditorScriptingUtilities,因此在build.cs里面的PublicDependencyModuleNames中进行添加.<br>然后开始实现功能,从UE编辑器中接收一个int32类型的值,然后通过值的大小进行asset的复制粘贴,命名和保存.</p><pre><code class="lang-cpp">void UQuickAssetAction::DuplicateAssets(int32 NumOfDuplicates)&#123;    if (NumOfDuplicates &lt;= 0)    &#123;        Print(TEXT(&quot;Please enter a VALID number&quot;), FColor::Red);        return;    &#125;    const TArray&lt;FAssetData&gt; SelectedAssetsData = UEditorUtilityLibrary::GetSelectedAssetData();    uint32 Counter = 0;    for (const FAssetData&amp; SelectedAssetData: SelectedAssetsData)    &#123;        for (int32 i = 0; i &lt; NumOfDuplicates; i++)        &#123;            const FString SourceAssetPath = SelectedAssetData.ObjectPath.ToString();            const FString NewDuplicatedAssetName = SelectedAssetData.AssetName.ToString() + TEXT(&quot;_&quot;) + FString::FromInt(i + 1);            const FString NewPathName = FPaths::Combine(SelectedAssetData.PackagePath.ToString(), NewDuplicatedAssetName);            if (UEditorAssetLibrary::DuplicateAsset(SourceAssetPath, NewPathName))            &#123;                UEditorAssetLibrary::SaveAsset(NewPathName,false); // 保存复制的资产,false是指无论是否对资产进行了修改都保存                ++Counter;            &#125;        &#125;    &#125;    if (Counter &gt; 0)    &#123;        Print(TEXT(&quot;Successfully duplicated &quot; + FString::FromInt(Counter) + &quot; files&quot;), FColor::Green);    &#125;&#125;</code></pre><hr><h1 id="消息框与通知框"><a href="#消息框与通知框" class="headerlink" title="消息框与通知框"></a>消息框与通知框</h1><h2 id="消息框"><a href="#消息框" class="headerlink" title="消息框:"></a>消息框:</h2><p><strong>需要包含头文件:</strong> “Misc/MessageDialog.h”</p><pre><code class="lang-cpp">FText MsgTitle = FText::FromString(TEXT(&quot;Warning&quot;));FText WarningMsg = FText::FromString(TEXT(&quot;Please enter a VALID number&quot;));FMessageDialog::Open(EAppMsgType::Ok,WarningMsg, &amp;MsgTitle);</code></pre><p><img src="/.com//image-14.png" alt="Alt text"><br><strong>可以把它写成函数:</strong></p><pre><code class="lang-cpp">EAppReturnType::Type ShowMsgDialog(EAppMsgType::Type MsgType, const FString&amp; Message, bool bShowMsgAsWarning = true)&#123;    if (bShowMsgAsWarning)    &#123;        FText MsgTitle = FText::FromString(TEXT(&quot;Warning&quot;));        return FMessageDialog::Open(MsgType, FText::FromString(Message), &amp;MsgTitle);    &#125;    else    &#123;        return FMessageDialog::Open(MsgType, FText::FromString(Message));    &#125;&#125;</code></pre><p><strong>使用:</strong><br>ShowMsgDialog(EAppMsgType::Ok, TEXT(“Please enter a VALID number”));</p><hr><h2 id="通知框-右下角弹出"><a href="#通知框-右下角弹出" class="headerlink" title="通知框(右下角弹出):"></a>通知框(右下角弹出):</h2><p><strong>用到的头文件:</strong><br>“Widgets/Notifications/SNotificationList.h”<br>“Framework/Notifications/NotificationManager.h”<br><strong>写成自定义函数:</strong></p><pre><code class="lang-cpp">void ShowNotifyInfo(const FString&amp; Message)&#123;    FNotificationInfo NotifyInfo(FText::FromString(Message));    NotifyInfo.bUseLargeFont = true;    NotifyInfo.FadeOutDuration = 7.f;    FSlateNotificationManager::Get().AddNotification(NotifyInfo);&#125;</code></pre><p><strong>使用:</strong><br>ShowNotifyInfo(TEXT(“Successfully duplicated “ + FString::FromInt(Counter) + “ files”));<br>结果:<br><img src="/.com//image-15.png" alt="Alt text"></p><hr><h1 id="自动判断资产类型并添加命名前缀"><a href="#自动判断资产类型并添加命名前缀" class="headerlink" title="自动判断资产类型并添加命名前缀"></a>自动判断资产类型并添加命名前缀</h1><blockquote><p>命名规范参考:<a href="https://docs.unrealengine.com/5.2/zh-CN/recommended-asset-naming-conventions-in-unreal-engine-projects/">资产命名规范</a><br>资产类型与前缀的对应的数据结构主要靠TMap进行存取<br>举例:</p><pre><code class="lang-cpp">TMap&lt;UClass*, FString&gt;PrefixMap =&#123;    &#123;UBlueprint::StaticClass(),TEXT(&quot;BP_&quot;)&#125;,    &#123;UStaticMesh::StaticClass(),TEXT(&quot;SM_&quot;)&#125;,    &#123;UMaterial::StaticClass(),TEXT(&quot;M_&quot;)&#125;,    &#123;UMaterialInstanceConstant::StaticClass(),TEXT(&quot;MI&quot;)&#125;,    &#123;UMaterialFunctionInterface::StaticClass(),TEXT(&quot;MF_&quot;)&#125;,    &#123;UParticleSystem::StaticClass(),TEXT(&quot;PS_&quot;)&#125;,    &#123;USoundCue::StaticClass(),TEXT(&quot;SC_&quot;)&#125;,    &#123;USoundWave::StaticClass(),TEXT(&quot;SW_&quot;)&#125;,    &#123;UTexture::StaticClass(),TEXT(&quot;T_&quot;)&#125;,    &#123;UTexture2D::StaticClass(),TEXT(&quot;T_&quot;)&#125;,    &#123;UUserWidget::StaticClass(),TEXT(&quot;WBP_&quot;)&#125;,    &#123;USkeletalMeshComponent::StaticClass(),TEXT(&quot;SK_&quot;)&#125;,    &#123;UNiagaraSystem::StaticClass(),TEXT(&quot;NS_&quot;)&#125;,    &#123;UNiagaraEmitter::StaticClass(),TEXT(&quot;NE_&quot;)&#125;&#125;;</code></pre></blockquote><hr><p><strong>添加前缀的思路:</strong><br>获得选择的资产的object,然后遍历这些object,通过TMap的Find方法找TMap里面是否有object对应的前缀,如果有就通过UEditorUtilityLibrary的RenameAsset方法来修改object的名字.<br><strong>后来添加的补充:</strong><br>老师有提到材质球创建材质示例时会自动地在后面添加<em>inst名字,现在有个需求时,碰到材质实例时要更改一下添加前缀地步骤,添加前缀前需要先去除掉开头的M</em>和结尾的<em>inst,然后再添加前缀MI</em><br>我个人是通过这个代码来判断选择的资产是否是材质实例类型:<br>SelectedObject-&gt;GetClass() == UMaterialInstanceConstant::StaticClass()<br>老师给的代码是object有一个自己的方法用来判断object是否是某一种类型:<br>SelectedObject-&gt;IsA\<UMaterialInstanceConstant>()<br><strong>添加前缀的代码:</strong></UMaterialInstanceConstant></p><pre><code class="lang-cpp">void UQuickAssetAction::AddPrefixName()&#123;    TArray&lt;UObject*&gt; SelectedObjects = UEditorUtilityLibrary::GetSelectedAssets();    uint32 Counter = 0;    for (UObject* SelectedObject : SelectedObjects)    &#123;        if (!SelectedObject) continue;        FString* PrefixFound = PrefixMap.Find(SelectedObject-&gt;GetClass());        if (!PrefixFound || PrefixFound-&gt;IsEmpty())        &#123;            Print(TEXT(&quot;Failed to find prefix for class &quot;) + SelectedObject-&gt;GetClass()-&gt;GetName(), FColor::Red);        &#125;        FString OldName = SelectedObject-&gt;GetName();        if (OldName.StartsWith(*PrefixFound))        &#123;            Print(OldName + TEXT(&quot; already has prefix added&quot;), FColor::Red);            continue;        &#125;        if (SelectedObject-&gt;IsA&lt;UMaterialInstanceConstant&gt;())        &#123;            OldName.RemoveFromStart(TEXT(&quot;M_&quot;));            OldName.RemoveFromEnd(TEXT(&quot;_inst&quot;));        &#125;        FString NewNameWithPrefix = *PrefixFound + OldName;        UEditorUtilityLibrary::RenameAsset(SelectedObject, NewNameWithPrefix);        ++Counter;    &#125;    if (Counter &gt; 0)    &#123;        ShowNotifyInfo(TEXT(&quot;Successfully renamed &quot;) + FString::FromInt(Counter) + &quot; assets&quot;);    &#125;&#125;</code></pre><hr><h1 id="移除未放置在关卡里的资产"><a href="#移除未放置在关卡里的资产" class="headerlink" title="移除未放置在关卡里的资产"></a>移除未放置在关卡里的资产</h1><p>修复重定向器的思路:<br>首先修复重定向器使用的是AssetTools模块的FixupReferencers方法,它需要接收的是UObjectRedirectors<em>的数组,也就是重定向器的指针的数组.为了得到UObjectRedirectors</em>的数组可以通过AssetRegistry模块的GetAssets方法得到重定向器的FAssetData(需要借助FARFilter过滤器),得到FAssetData以后再使用FAssetData的GetAsset()来得到UObject<em>,然后通过Cast将其转换为UObjectRedirectors</em>,最后使用AssetTools模块的FixupReferencers方法来修复重定向器.<br><strong>有一个需要提到的是:</strong> 在定义过滤器时教程中使用的是Filter.ClassNames.Emplace(“ObjectRedirector”);但是这个方法在UE5.1中就不能用了,替代方法是使用:Filter.ClassPaths.Emplace(FTopLevelAssetPath(UObjectRedirector::StaticClass()));或者Filter.ClassPaths.Emplace(TEXT(“/Script/Engine.ObjectRedirector”))</p><pre><code class="lang-cpp">void UQuickAssetAction::RemoveUnusedAssets()&#123;    TArray&lt;FAssetData&gt; SelectedAssetsData = UEditorUtilityLibrary::GetSelectedAssetData();    TArray&lt;FAssetData&gt; UnusedAssetsData;    FixUpRedirectors(); // 修复重定向器    for (const FAssetData&amp; SelectedAssetData : SelectedAssetsData)    &#123;        // 先找资产的所有引用        TArray&lt;FString&gt; AssetReferencers =            UEditorAssetLibrary::FindPackageReferencersForAsset(SelectedAssetData.GetObjectPathString());        // 如果此资产没有引用就放到UnusedAssetsData数组中        if (AssetReferencers.Num() == 0)        &#123;            UnusedAssetsData.Add(SelectedAssetData);        &#125;    &#125;    // 如果UnusedAssetsData数组数量为0    if (UnusedAssetsData.Num() == 0)    &#123;        ShowMsgDialog(EAppMsgType::Ok, TEXT(&quot;No unused asset found among selected assets&quot;), false);        return;    &#125;    // 如果UnusedAssetsData数组数量不为0就尝试删除里面的所有内容    // ObjectTools::DeleteAssets不是强制删除,而是弹窗交给用户自己确定是否删除    const int32 NumOfAssetsDeleted = ObjectTools::DeleteAssets(UnusedAssetsData);    /*由于最终删除选择权在用户手上, 因此如果用户不选择删除那就不执行后面的*/    if (NumOfAssetsDeleted == 0) return;    ShowNotifyInfo(TEXT(&quot;Successfully deleted&quot;) + FString::FromInt(NumOfAssetsDeleted) + TEXT(&quot; unused assets&quot;));&#125;void UQuickAssetAction::FixUpRedirectors()&#123;    TArray&lt;UObjectRedirector*&gt; RedirectorsToFixArray; // 定义用来修复的重定向器的数组    // 加载并获取AssetRegistry模块,用于操作资产注册信息    FAssetRegistryModule&amp; AssetRegistryModule =        FModuleManager::Get().LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(&quot;AssetRegistry&quot;));     // 创建过滤器    FARFilter Filter;    Filter.bRecursivePaths = true; // 设定过滤器为递归查找资产    Filter.PackagePaths.Emplace(&quot;/Game&quot;); // 设定过滤器寻找的包的路径    Filter.ClassPaths.Emplace(FTopLevelAssetPath(UObjectRedirector::StaticClass()));// 设定过滤器只需要类名为ObjectRedirector(重定向器)的    // 或者这样:Filter.ClassPaths.Emplace(TEXT(&quot;/Script/Engine.ObjectRedirector&quot;));    TArray&lt;FAssetData&gt; OutRedirectors;    // 通过AssetRegistry模块的GetAssets方法配合过滤器得到所有重定向器的FAssetData    AssetRegistryModule.Get().GetAssets(Filter, OutRedirectors);    // 遍历所有重定向器的FAssetData得到FAssetData所表示的UObjectRedirector*    for (const FAssetData&amp; RedirectorData:OutRedirectors)    &#123;        // Cast是强制类型转换,通过FAssetData对象的GetAsset方法得到UObject*,然后通过Cast得到UObjectRedirector*        if (UObjectRedirector* RedirectorToFix = Cast&lt;UObjectRedirector&gt;(RedirectorData.GetAsset()))        &#123;            RedirectorsToFixArray.Add(RedirectorToFix);        &#125;    &#125;    // 加载AssetToos模块,用来修复引用关系    FAssetToolsModule&amp; AssetToolsModule =        FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;(TEXT(&quot;AssetTools&quot;));    // 调用AssetTools模块的FixupReferencers函数来修复引用关系    AssetToolsModule.Get().FixupReferencers(RedirectorsToFixArray);&#125;</code></pre><hr><h1 id="delegate-委托"><a href="#delegate-委托" class="headerlink" title="delegate(委托)"></a>delegate(委托)</h1><p><strong>委托的介绍:</strong></p><ul><li>委托可以调用C++对象上的成员函数</li><li>一旦绑定到函数,函数就可以在以后的时间被调用</li><li>如果想要实现例如点击按钮触发函数就需要将委托与成员函数进行绑定</li><li>虚幻引擎支持三种委托: 单播委托,多播委托,动态委托</li></ul><p><strong>定义委托:</strong><br>定义委托可以使用虚幻引擎提供的宏,这里介绍三种定义委托的方式(<strong>图片中的蓝色为名字或类型举例</strong>)<br>第一种是定义一个委托,它调用的是一个没有返回值的名字叫Function的函数<br>第二种是定义一个委托,它调用的函数没有返回值并且需要接收一个参数,参数类型为自定义的.<br>第三种是定义一个委托,它调用的函数有返回值并且需要接收一个参数,参数类型与返回类型为自定义的.<br><img src="/.com//image-20.png" alt="Alt text"></p><hr><h1 id="创建自定义菜单项"><a href="#创建自定义菜单项" class="headerlink" title="创建自定义菜单项"></a>创建自定义菜单项</h1><blockquote><p>在这篇内容中,教程中导入之前为了调试而创建的头文件(DebugHeader.h)后再编译会出错,因此把DebugHeader.h的函数前面都加上了static,然后把所有函数都放在了一个命名空间里面.<br>但是我自己在使用过程中,并没有出现编译报错的情况,因此没有添加static.<br><strong>但是在后面的使用过程中,没有添加static遇到的编译错误,因此还是加上static吧.最好再把它们放到命名空间里面</strong><br><strong>如果不加的话可能会遇到:找到一个或多个多重定义的符号的问题,也就是说名字重复了.</strong></p><h2 id="创建自定义菜单项的思路"><a href="#创建自定义菜单项的思路" class="headerlink" title="创建自定义菜单项的思路"></a>创建自定义菜单项的思路</h2><p>目前创建的功能都是需要在资产里面右键然后在点击脚本化资产行为中的功能来使用的.<br>这里介绍一下将功能放到对文件夹右键显示的创建自定义菜单项的思路:</p><ol><li>首先在Visual Studio找到以我们创建的插件命名的头文件(也就是前面的SuperManager),在其中可以看到虚幻为它创建了两个纯虚函数:<strong>StartupModule</strong>和<strong>ShutdownModule</strong>.<br>进入其定义可以看到注释:<br><strong>StartupModule</strong>中的代码将在模块加载到内存后执行;确切的时间在每个模块的.uplugin文件中指定(也就是前面创建plugin时首先做的设置PreDefault<img src="/.com//image-3.png" alt="Alt text">).<br><strong>ShutdownModule</strong>中的代码对于支持动态重载的模块可以在关闭期间被调用来清理模块,以及卸载模块之前会进行调用.</li><li>将创建自定义菜单项的代码放到StartupModule函数里面.</li><li>加载ContentBrowser模块:FContentBrowserModule&amp; ContentBrowserModule = FModuleManager::LoadModuleChecked<FContentBrowserModule>(TEXT(“ContentBrowser”));</FContentBrowserModule></li><li>通过ContentBrowser模块的GetAllPathViewContextMenuExtenders得到UE的用于路径视图内容的扩展的所有委托数组</li><li>在得到的UE的委托数组里添加自己的委托</li><li>将委托与自己的函数进行绑定</li></ol></blockquote><hr><h2 id="一键删除未使用的资产"><a href="#一键删除未使用的资产" class="headerlink" title="一键删除未使用的资产"></a>一键删除未使用的资产</h2><h3 id="头文件代码"><a href="#头文件代码" class="headerlink" title="头文件代码"></a>头文件代码</h3><p><strong>插件的头文件SuperManager.h:</strong><br>其中#pragma region ContentBrowserMenuExtension和#pragma endregion的意思是将这两行之间的内容包裹起来,加了这两行以后,就可以把这两行之内的代码进行压缩和展开,方便整理代码,其中ContentBrowserMenuExtension是自定义的内容的概况名字.<br>压缩之后的样子:<img src="/.com//image-21.png" alt="Alt text"></p><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;Modules/ModuleManager.h&quot;class FSuperManagerModule : public IModuleInterface&#123;public:    /** IModuleInterface implementation */    virtual void StartupModule() override;    virtual void ShutdownModule() override;private:#pragma region ContentBrowserMenuExtension    void InitCBMenuExtension();    TSharedRef&lt;FExtender&gt; CustomCBMenuExtender(const TArray&lt;FString&gt;&amp; SelectedPaths);    void AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder);    void OnDeleteUnusedAssetButtonClicked();#pragma endregion &#125;;</code></pre><hr><h3 id="委托的创建和绑定"><a href="#委托的创建和绑定" class="headerlink" title="委托的创建和绑定"></a>委托的创建和绑定</h3><p>这里代码展示的委托类型有:FContentBrowserMenuExtender_SelectedPaths,FMenuExtensionDelegate,FExecuteAction,这三种是虚幻自己定义的委托类型,可以通过源码看到其定义,以及委托类型是否有返回值,绑定的函数是否需要接收参数.<br>快速创建某委托类型的委托,并且将这个委托与某个函数进行绑定的例子:<br>这里创建了一个FContentBrowserMenuExtender_SelectedPaths类型的委托,只是并没有给创建的委托定义名字,然后把这个委托跟FSuperManagerModule::CustomCBMenuExtender函数进行了绑定.<br>FContentBrowserMenuExtender_SelectedPaths::CreateRaw(this, &amp;FSuperManagerModule::CustomCBMenuExtender)<br><strong>三个绑定函数:</strong><br><strong>FSuperManagerModule::CustomCBMenuExtender:</strong> 这个函数负责定义菜单的位置,这里是放在了Delete的后面,Delete这个名字可以通过在编辑器偏好设置中开启显示UI扩展点来看到<br><img src="/.com//image-22.png" alt="Alt text"><img src="/.com//image-23.png" alt="Alt text"><br><strong>FSuperManagerModule::AddCBMenuEntry:</strong> 这个函数负责定义菜单的名字的提示条和图标和当点击时对应的委托.<br><strong>FSuperManagerModule::OnDeleteUnusedAssetButtonClicked:</strong> 这个函数负责定义当点击菜单时对应的执行内容.<br><strong>void FSuperManagerModule::FixUpRedirectors:</strong> 修复重定向器,跟前面的教程内容一样的.<br><strong>代码详情:</strong></p><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#include &quot;SuperManager.h&quot;#include &quot;ContentBrowserModule.h&quot;#include &quot;DebugHeader.h&quot;#include &quot;EditorAssetLibrary.h&quot;#include &quot;ObjectTools.h&quot;#include &quot;AssetRegistryModule.h&quot;#include &quot;AssetToolsModule.h&quot;#define LOCTEXT_NAMESPACE &quot;FSuperManagerModule&quot;void FSuperManagerModule::StartupModule()&#123;    InitCBMenuExtension();&#125;#pragma region ContentBrowserMenuExtensionvoid FSuperManagerModule::InitCBMenuExtension()&#123;    // 加载模块并取别名    FContentBrowserModule&amp; ContentBrowserModule =        FModuleManager::LoadModuleChecked&lt;FContentBrowserModule&gt;(TEXT(&quot;ContentBrowser&quot;));    // 得到UE的用于路径视图内容的扩展的所有委托    TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; ContentBrowserModuleMenuExtenders =        ContentBrowserModule.GetAllPathViewContextMenuExtenders();    /* 这是第一种创建委托并绑定函数的方法:    // 创建一个委托(FContentBrowserMenuExtender_SelectedPaths是一个委托类型,用于在路径上右键单击时请求菜单)    FContentBrowserMenuExtender_SelectedPaths CustomCBMenuDelegate;    // 将委托与自己创建的成员函数进行绑定    // 通过查看FContentBrowserMenuExtender_SelectedPaths类型可以得知    // 它需要绑定函数的返回类型是TSharedRef&lt;FExtender&gt;,接收参数类型是const TArray&lt;FString&gt;&amp;    CustomCBMenuDelegate.BindRaw(this, &amp;FSuperManagerModule::CustomCBMenuExtender);    // 在UE的用于路径视图内容的委托中加入自己的委托    ContentBrowserModuleMenuExtenders.Add(CustomCBMenuDelegate);    */    // 第二种创建委托并绑定函数的方法,好处是不需要定义委托的名字    ContentBrowserModuleMenuExtenders.Add(FContentBrowserMenuExtender_SelectedPaths::        CreateRaw(this, &amp;FSuperManagerModule::CustomCBMenuExtender));&#125;// 定义菜单的位置TSharedRef&lt;FExtender&gt; FSuperManagerModule::CustomCBMenuExtender(const TArray&lt;FString&gt;&amp; SelectedPaths)&#123;    TSharedRef&lt;FExtender&gt; MenuExtender(new FExtender());    if (SelectedPaths.Num() &gt; 0)    &#123;        MenuExtender-&gt;AddMenuExtension(            FName(&quot;Delete&quot;), // 找到已经存在的Delete菜单            EExtensionHook::After, // 把自定义的菜单放到Delete菜单后面            TSharedPtr&lt;FUICommandList&gt;(), // 定义快捷键,这里为空            FMenuExtensionDelegate::CreateRaw(this, &amp;FSuperManagerModule::AddCBMenuEntry) // 创建委托并绑定成员函数        );        FolderPathsSelected = SelectedPaths;    &#125;    return MenuExtender;&#125;// 定义菜单的名字的提示条和图标和当点击时对应的委托void FSuperManagerModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder)&#123;    MenuBuilder.AddMenuEntry(        FText::FromString(TEXT(&quot;Delete Unused Assets&quot;)), // 自定义的菜单名字        FText::FromString(TEXT(&quot;Safely delete all unused assets under folder&quot;)), // 菜单的提示条        FSlateIcon(), // 菜单的图标        FExecuteAction::CreateRaw(this, &amp;FSuperManagerModule::OnDeleteUnusedAssetButtonClicked) // 创建点击时触发的委托并与成员函数进行绑定    );&#125;// 删除未使用的资产void FSuperManagerModule::OnDeleteUnusedAssetButtonClicked()&#123;    if (FolderPathsSelected.Num() &gt; 1)    &#123;        ShowMsgDialog(EAppMsgType::Ok, TEXT(&quot;You can only do this to one folder&quot;));        return;    &#125;    TArray&lt;FString&gt; AssetPathNames = UEditorAssetLibrary::ListAssets(FolderPathsSelected[0]);    if (AssetPathNames.Num() == 0)    &#123;        ShowMsgDialog(EAppMsgType::Ok, TEXT(&quot;No asset found under selected folder&quot;, false));    &#125;    EAppReturnType::Type ConfirmResult = ShowMsgDialog(EAppMsgType::YesNo, TEXT(&quot;A total of &quot;) + FString::FromInt(AssetPathNames.Num()) + TEXT(&quot; found.\nWoudle you like to procceed?&quot;));    if (ConfirmResult == EAppReturnType::No) return;    FixUpRedirectors();    TArray&lt;FAssetData&gt; UnusedAssetDataArray;    for (const FString&amp; AssetPathName : AssetPathNames)    &#123;        // 如果选择的文件夹内容包含这些,那么就不进行处理,因为这些文件夹是不能改变的        if (AssetPathName.Contains(TEXT(&quot;Developers&quot;))        || AssetPathName.Contains(TEXT(&quot;Collections&quot;))        || AssetPathName.Contains(TEXT(&quot;__ExternalActors__&quot;))        || AssetPathName.Contains(TEXT(&quot;__ExternalObjects__&quot;)))         &#123;            continue;        &#125;        TArray&lt;FString&gt; AssetReferencers = UEditorAssetLibrary::FindPackageReferencersForAsset(AssetPathName);        if (AssetReferencers.Num() == 0)        &#123;            FAssetData UnusedAssetData = UEditorAssetLibrary::FindAssetData(AssetPathName);            UnusedAssetDataArray.Add(UnusedAssetData);        &#125;    &#125;    if (UnusedAssetDataArray.Num() &gt; 0)    &#123;        ObjectTools::DeleteAssets(UnusedAssetDataArray);    &#125;    else    &#123;        ShowMsgDialog(EAppMsgType::Ok, TEXT(&quot;No unused asset found under selected folder&quot;),false);    &#125;&#125;// 修复重定向器void FSuperManagerModule::FixUpRedirectors()&#123;    TArray&lt;UObjectRedirector*&gt; RedirectorsToFixArray;    FAssetRegistryModule&amp; AssetRegistryModule =        FModuleManager::Get().LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(&quot;AssetRegistry&quot;));    FARFilter Filter;    Filter.bRecursivePaths = true;    Filter.PackagePaths.Emplace(&quot;/Game&quot;);    // Filter.ClassNames.Emplace(&quot;ObjectRedirector&quot;); // UE5.0版本用这个还可以,UE5.1版本就不可以了,需要用ClassPaths来代替    Filter.ClassPaths.Add(FTopLevelAssetPath(UObjectRedirector::StaticClass()));    TArray&lt;FAssetData&gt; OutRedirectors;    AssetRegistryModule.Get().GetAssets(Filter, OutRedirectors);    for (const FAssetData&amp; RedirectorData : OutRedirectors)    &#123;        if (UObjectRedirector* RedirectorToFix = Cast&lt;UObjectRedirector&gt;(RedirectorData.GetAsset()))        &#123;            RedirectorsToFixArray.Add(RedirectorToFix);        &#125;    &#125;    FAssetToolsModule&amp; AssetToolsModule =        FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;(TEXT(&quot;AssetTools&quot;));    AssetToolsModule.Get().FixupReferencers(RedirectorsToFixArray);&#125;#pragma endregion void FSuperManagerModule::ShutdownModule()&#123;    // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,    // we call this function before unloading the module.&#125;#undef LOCTEXT_NAMESPACEIMPLEMENT_MODULE(FSuperManagerModule, SuperManager)</code></pre><h2 id="一键删除空的文件夹"><a href="#一键删除空的文件夹" class="headerlink" title="一键删除空的文件夹"></a>一键删除空的文件夹</h2><p>在已经做好了一个自定义菜单项的情况下,可以在那个的基础上添加新的菜单,只需要在之前创建的FSuperManagerModule::AddCBMenuEntry函数中添加第二个菜单,然后再创建委托绑定函数即可.<br>代码举例:<br><strong>添加新的菜单</strong></p><pre><code class="lang-cpp">// 定义菜单的名字的提示条和图标和当点击时对应的委托void FSuperManagerModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder)&#123;    // 添加第一个菜单    MenuBuilder.AddMenuEntry(        FText::FromString(TEXT(&quot;Delete Unused Assets&quot;)), // 自定义的菜单名字        FText::FromString(TEXT(&quot;Safely delete all unused assets under folder&quot;)), // 菜单的提示条        FSlateIcon(), // 菜单的图标        FExecuteAction::CreateRaw(this, &amp;FSuperManagerModule::OnDeleteUnusedAssetButtonClicked) // 创建点击时触发的委托并与成员函数进行绑定    );    // 添加第二个菜单    MenuBuilder.AddMenuEntry(        FText::FromString(TEXT(&quot;Delete Empty Folders&quot;)), // 自定义的菜单名字        FText::FromString(TEXT(&quot;Safely delete all empty folders&quot;)), // 菜单的提示条        FSlateIcon(), // 菜单的图标        FExecuteAction::CreateRaw(this, &amp;FSuperManagerModule::OnDeleteEmptyFoldersButtonClicked) // 创建点击时触发的委托并与成员函数进行绑定    );&#125;</code></pre><p><strong>删除空文件夹的函数</strong><br>思路:删除前先调用之前创建的FixUpRedirectors();来进行重定向器的修复.然后通过ListAssets得到所有文件夹下的文件与文件夹路径(ListrAssets的第三个参数为true即可得到包括文件夹路径),然后排除掉不能修改的文件内容,通过UEditorAssetLibrary::DoesDirectoryExist()判断是否为文件夹,通过UEditorAssetLibrary::DoesDirectoryHaveAssets()判断文件夹是否存在内容,通过UEditorAssetLibrary::DeleteDirectory()来删除文件夹.</p><pre><code class="lang-cpp">void FSuperManagerModule::OnDeleteEmptyFoldersButtonClicked()&#123;    FixUpRedirectors();    TArray&lt;FString&gt; FolderPathsArray = UEditorAssetLibrary::ListAssets(FolderPathsSelected[0],true,true);    uint32 Counter = 0;    FString EmptyFolderPathsNames;    TArray&lt;FString&gt; EmptyFoldersPathsArray;    for (const FString&amp; FolderPath : FolderPathsArray)    &#123;        if (FolderPath.Contains(TEXT(&quot;Developers&quot;))            || FolderPath.Contains(TEXT(&quot;Collections&quot;))            || FolderPath.Contains(TEXT(&quot;__ExternalActors__&quot;))            || FolderPath.Contains(TEXT(&quot;__ExternalObjects__&quot;))) continue;        if (!UEditorAssetLibrary::DoesDirectoryExist(FolderPath)) continue;        if (!UEditorAssetLibrary::DoesDirectoryHaveAssets(FolderPath))        &#123;            EmptyFolderPathsNames.Append(FolderPath);            EmptyFolderPathsNames.Append(&quot;\n&quot;);            EmptyFoldersPathsArray.Add(FolderPath);        &#125;    &#125;    if (EmptyFoldersPathsArray.Num() == 0)    &#123;        ShowMsgDialog(EAppMsgType::Ok, TEXT(&quot;No empty folder found under selected folder&quot;), false);        return;    &#125;    EAppReturnType::Type ConfirmResult = ShowMsgDialog(EAppMsgType::OkCancel,        TEXT(&quot;Empty folders found in:\n&quot;) + EmptyFolderPathsNames + TEXT(&quot;\nWould you like to delete all?&quot;), false);    if (ConfirmResult == EAppReturnType::Cancel) return;    for (const FString&amp; EmptyFolderPath : EmptyFoldersPathsArray)    &#123;        UEditorAssetLibrary::DeleteDirectory(EmptyFolderPath) ?            ++Counter : Print(TEXT(&quot;Failed to delete &quot;) + EmptyFolderPath, FColor::Red);    &#125;    if (Counter &gt; 0)    &#123;        ShowNotifyInfo(TEXT(&quot;Successfully deleted &quot;) + FString::FromInt(Counter) + TEXT(&quot; folders&quot;));    &#125;&#125;</code></pre><hr><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><blockquote><p><a href="https://docs.unrealengine.com/5.2/zh-CN/smart-pointers-in-unreal-engine/">UE官方文档对智能指针的介绍</a></p></blockquote><p><strong>智能指针的作用:</strong> 减轻内存分配和跟踪的负担<br><strong>UE的四种智能指针类型:</strong></p><ol><li>SharedPointers: TSharedPtr</li><li>SharedReferences: TSharedRef</li><li>WeakPointers: TWeakPtr</li><li>UniquePointers<br>TSharedPtr: 拥有其引用的对象,能防止对象被删除(通过ReferenceCounting计数,为0时自动删除),可以指向空白.<br>TSharedRef: 拥有其引用的对象,能防止对象被删除,引用的对象必须为非空.(因为必须为非空,所以Slate经常使用它)<br>TWeakPtr: 不拥有引用的对象,用于中断引用循环.(当只想保留对象的引用时有用,可以通过检查它来确定它是否有对象)</li></ol><p><strong>智能指针和垃圾回收:</strong> 智能指针无法与UObject系统同时使用。UObject系统有自己的一套内存管理系统,叫垃圾回收,使用UPROPERTY()宏来定义一个指针就能够对UObject指针进行垃圾回收.<br><strong>创建智能指针:</strong></p><pre><code class="lang-cpp">// 传统上的创建一个指针的方式:FExtender* MenuExtender = new FExtender(); // 在堆上开辟一个空间存放FExtender的对象,并创建一个MenuExtender指针指向它// 进行一系列操作delete MenuExtender; // 使用完以后必须手动删除掉,不然会造成内存泄漏// 创建智能指针方法一TSharedRef&lt;FExtender&gt; MenuExtender (new FExtender());// 创建智能指针方法二TSharedRef&lt;FExtender&gt; MenuExtender = MakeShareable(new FExtender());// 创建智能指针方法三(已经有对象的情况下)const FAssetData Data = UEditorAssetLibrary::FindAssetData(AssetPathName);TSharedPtr&lt;FAssetData&gt; AssetDataSharedPtr = MakeShared&lt;FAssetData&gt;(Data);</code></pre><hr><h1 id><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;关于有讨论的UE5-2右键不显示脚本化资本行为的解决办法&quot;&gt;&lt;a href=&quot;#关于有讨论的UE5-2右键不显示脚本化资本行为的解决办法&quot; class=&quot;headerlink&quot; title=&quot;关于有讨论的UE5.2右键不显示脚本化资本行为的解决办法&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="UE开发" scheme="http://example.com/categories/UE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UEC++" scheme="http://example.com/tags/UEC/"/>
    
  </entry>
  
  <entry>
    <title>UEC++</title>
    <link href="http://example.com/2023/09/13/UE%E5%BC%80%E5%8F%91-UE-C/"/>
    <id>http://example.com/2023/09/13/UE%E5%BC%80%E5%8F%91-UE-C/</id>
    <published>2023-09-13T02:25:00.000Z</published>
    <updated>2024-07-27T18:58:06.874Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里是UEC++的学习记录.<br>初次接触UEC++,特别是基础还不是太好时,首先可以看一下这个知乎文章<a href="https://zhuanlan.zhihu.com/p/458435453">虚幻引擎编译系统总结</a>.<br>其他遇到的相关知识点就可以先看C++的笔记中的记录.</p><h1 id="常见的命名约定前缀"><a href="#常见的命名约定前缀" class="headerlink" title="常见的命名约定前缀"></a>常见的命名约定前缀</h1><ul><li>U开头：通常表示继承自 UObject 的类或类的实例，它们是虚幻引擎的对象。UObject 是UE中所有对象的基类，它提供了一些通用的功能，如引用计数、反射系统等。因此，以”U”开头的类通常是虚幻引擎的核心对象。例如：UActorComponent, UStaticMeshComponent, UCharacterMovementComponent。</li><li>A开头：通常表示继承自 AActor 的类或类的实例，表示游戏中的一个实体或角色。AActor 是UE中表示游戏实体的基类。例如：ACharacter, APlayerController, AProjectile.</li><li>F开头：通常表示代理（Delegate）或结构体（Struct），用于在代码中定义事件、回调和数据结构。例如：FVector, FRotator, FOnClicked.</li><li>S开头：通常表示继承自 SWidget 的类或类的实例，表示UI小部件。SWidget 是Slate框架中用于构建用户界面的基类。例如：SButton, SImage, STextBlock.</li><li>I开头：通常表示接口（Interface），用于定义一组要被其他类实现的方法。例如：IInteractionInterface, IMovementInterface.</li><li>E开头：通常表示枚举类型（Enum），用于定义一组相关的命名常数。例如：ECharacterState, EWeaponType, EMovementDirection.</li><li>T开头：通常表示模板类（Template class），用于创建可以在多种数据类型上操作的通用代码。例如：TArray, TMap, TSharedPtr.</li><li>b开头: 布尔变量必须以b为前缀（例如 bPendingDestruction 或 bHasFadedIn）。<h1 id="常见的C-宏以及定义"><a href="#常见的C-宏以及定义" class="headerlink" title="常见的C++宏以及定义"></a>常见的C++宏以及定义</h1><h2 id="对象声明和属性"><a href="#对象声明和属性" class="headerlink" title="对象声明和属性"></a>对象声明和属性</h2></li><li>UCLASS：用于声明一个类，使其能够在Unreal Engine中使用，自动生成蓝图类的功能，并继承自UObject。</li><li>USTRUCT：用于声明一个结构体，使其能够在UE中使用，与UCLASS类似，但用于结构体。</li><li>UENUM：用于声明一个枚举类型，使其能够在UE中使用，允许在蓝图和代码中使用。</li><li>UPROPERTY：用于声明类的属性（成员变量），使其可以在编辑器中显示和编辑。</li><li>UFUNCTION：用于声明成员函数，使其能够在蓝图中调用，绑定到事件，并支持远程过程调用（RPC）。</li><li>UDELEGATE：用于声明委托类型，用于处理事件、回调和通信。</li><li>UINTERFACE：用于声明一个接口，允许类实现相应的功能。</li><li>GENERATED_BODY：用于类声明内部，表示自动生成的C++代码的开始。</li><li>GENERATED_UCLASS_BODY：类似于GENERATED_BODY，但用于旧版本的代码生成。</li><li>GENERATED_USTRUCT_BODY：类似于GENERATED_BODY，但用于结构体。<h2 id="日志和断言"><a href="#日志和断言" class="headerlink" title="日志和断言"></a>日志和断言</h2></li><li>DEFINE_LOG_CATEGORY：定义一个日志类别，用于记录日志消息。</li><li>DECLARE_LOG_CATEGORY_EXTERN：声明一个外部的日志类别，通常在不同文件中共享日志类别。</li><li>UE_LOG：用于在代码中记录日志消息。</li><li>CHECK / VERIFY：用于在运行时进行断言检查，如果条件不满足，则触发断言失败。<h2 id="模块和应用程序"><a href="#模块和应用程序" class="headerlink" title="模块和应用程序"></a>模块和应用程序</h2></li><li>IMPLEMENT_PRIMARY_GAME_MODULE：实现主游戏模块，指定游戏模块的入口点和初始化代码。</li><li>IMPLEMENT_MODULE：实现一个模块，允许扩展UE的功能。<h2 id="平台和翻译"><a href="#平台和翻译" class="headerlink" title="平台和翻译"></a>平台和翻译</h2></li><li>PLATFORM_XXX：用于在特定平台上编译代码块，如PLATFORM_WINDOWS、PLATFORM_MAC等。</li><li>WITH_EDITOR：用于在编辑器环境下编译代码块。</li><li>WITH_EDITORONLY：用于在编辑器环境下编译代码块，运行时被忽略。<h2 id="蓝图和脚本"><a href="#蓝图和脚本" class="headerlink" title="蓝图和脚本"></a>蓝图和脚本</h2></li><li>UE_DEPRECATED：标记已弃用的函数、变量或类，用于向后兼容。</li><li>TEXT：创建FText本地化字符串字面值。</li><li>NSLOCTEXT：创建本地化字符串，支持多语言。</li><li>LOCTEXT_NAMESPACE：设置本地化命名空间，用于区分不同的本地化字符串。<h2 id="Slate相关"><a href="#Slate相关" class="headerlink" title="Slate相关"></a>Slate相关</h2></li><li>SNew: 用于创建 Slate 控件的实例</li><li>SLATE_BEGIN_ARGS / SLATE_END_ARGS：用于定义 Slate 控件的构造参数，允许在构造时设置初始属性。</li><li>SLATE_ATTRIBUTE：用于创建一个属性对象，使得可以将数据源（如属性或委托）绑定到控件属性。</li><li>SLATE_ARGUMENT：用于在构造参数中定义控件的属性，使得可以在创建控件时传递值。</li><li>SLATE_NAMED_SLOT：用于在控件内部定义一个命名插槽，使得可以在使用时填充内容。</li><li>SLATE_EVENT: 用于定义委托事件，以便在控件上绑定和触发事件。</li><li>BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATION / END_SLATE_FUNCTION_BUILD_OPTIMIZATION：用于标记一段代码，以进行 Slate 控件构建优化，以提高性能。</li><li>IMPLEMENT_SIMPLE_AUTOMATION_TEST：用于实现一个简单的自动化测试，以验证 Slate 控件的行为。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这里是UEC++的学习记录.&lt;br&gt;初次接触UEC++,特别是基础还不是太好时,首先可以看一下这个知乎文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/458435453&quot;&gt;虚幻引擎编译系统总结&lt;/a&gt;.&lt;br&gt;其他遇</summary>
      
    
    
    
    <category term="UE开发" scheme="http://example.com/categories/UE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UEC++" scheme="http://example.com/tags/UEC/"/>
    
  </entry>
  
  <entry>
    <title>UE_Slate</title>
    <link href="http://example.com/2023/09/13/UE%E5%BC%80%E5%8F%91-UE-Slate/"/>
    <id>http://example.com/2023/09/13/UE%E5%BC%80%E5%8F%91-UE-Slate/</id>
    <published>2023-09-13T02:25:00.000Z</published>
    <updated>2024-07-27T18:58:06.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习的视频"><a href="#学习的视频" class="headerlink" title="学习的视频"></a>学习的视频</h1><p><a href="https://www.bilibili.com/video/BV19L411L7XA/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=b1de3fe38e887eb40fc55a5485724480">第一个独立程序_哔哩哔哩_bilibili</a></p><h1 id="对于UE编译系统总结的文章推荐："><a href="#对于UE编译系统总结的文章推荐：" class="headerlink" title="对于UE编译系统总结的文章推荐："></a>对于UE编译系统总结的文章推荐：</h1><p><a href="https://zhuanlan.zhihu.com/p/458435453">虚幻引擎编译系统总结</a></p><h1 id="下载并编译源码版UE"><a href="#下载并编译源码版UE" class="headerlink" title="下载并编译源码版UE"></a>下载并编译源码版UE</h1><p>去github下载源码版：<a href="https://github.com/EpicGames/UnrealEngine">https://github.com/EpicGames/UnrealEngine</a><br></p><h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h2 id="处理UE源码版的文件的过程中需要注意的点"><a href="#处理UE源码版的文件的过程中需要注意的点" class="headerlink" title="处理UE源码版的文件的过程中需要注意的点"></a>处理UE源码版的文件的过程中需要注意的点</h2><p><img src="/.com//image(1" alt="Alt text">.png)<br>通过文章里的这些描述得知，如果我们需要新建第一个程序就需要全程再本地资源管理器中进行操作，不能够在VS里面进行操作。<br>当进行完新建文件的操作完以后，通过双击运行GenerateProjectFiles.bat文件即可更新UE的结构，同时VS里面也会同步更新。<br>当更改build.cs文件时也需要双击运行GenerateProjectFiles.bat文件。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>去源码的Source文件夹中的Programs目录里面找到BlankProgram文件夹（这个文件夹是一个空白程序文件夹，因此可以通过这个来创建自己的程序）：UnrealEngine-release\Engine\Source\Programs\<br>选中BlankProgram文件夹ctrl+c和ctrl+v创建一个副本<br>改名为自己想要的名字<br>以FirstProgram举例：<br>改文件夹的名字以后，更改文件夹里面的文件以及文件内容的名字，把BlankProgram都改为自己的名字(FirstProgram)<br>这四个文件除了文件名，文件的内容里的BlankProgram也都改为FirstProgram</p><p><img src="/.com//image(2" alt="Alt text">.png)<br><img src="/.com//image(3" alt="Alt text">.png)<br>更改完以后运行bat文件来重新生成工程文件。<br><img src="/.com//image(4" alt="Alt text">.png)<br>生成以后打开slh文件，将我们的FirstProgram设置为启动项目并进行编译<br><img src="/.com//image(5" alt="Alt text">.png)<br>编译完成之后进入cpp文件打上断点然后进行调试，然后就得到了打印helloworld的程序。<br><img src="/.com//image(6" alt="Alt text">.png)</p><hr><h1 id="SWindow"><a href="#SWindow" class="headerlink" title="SWindow"></a>SWindow</h1><h2 id="主要参考程序：SlateViewer"><a href="#主要参考程序：SlateViewer" class="headerlink" title="主要参考程序：SlateViewer"></a>主要参考程序：SlateViewer</h2><p>首先可以参考一下自带的SlateViewer程序，将其设为启动项目然后进行调试即可查看内容结果。如下：<br><img src="/.com//image(7" alt="Alt text">.png)</p><h2 id="模块更改"><a href="#模块更改" class="headerlink" title="模块更改"></a>模块更改</h2><h3 id="两个模块的作用："><a href="#两个模块的作用：" class="headerlink" title="两个模块的作用："></a>两个模块的作用：</h3><p><img src="/.com//image(8" alt="Alt text">.png)<br>补充: 写代码时会include其他头文件,之所以不需要写全路径,只需要写public或者private后面的路径,应该就是因为在build.cs里面包括了那个模块名.如果没有就需要添加.这也就是模块由build.cs确定相互依赖关系的意思.</p><h3 id="build模块："><a href="#build模块：" class="headerlink" title="build模块："></a>build模块：</h3><p>新增三个<br><img src="/.com//image(9" alt="Alt text">.png)</p><h3 id="target模块："><a href="#target模块：" class="headerlink" title="target模块："></a>target模块：</h3><p>更改三个：<br><img src="/.com//image(10" alt="Alt text">.png)</p><h2 id="cpp文件的内容："><a href="#cpp文件的内容：" class="headerlink" title="cpp文件的内容："></a>cpp文件的内容：</h2><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#include &quot;FirstProgram.h&quot;#include &quot;RequiredProgramMainCPPInclude.h&quot;#include &quot;StandaloneRenderer.h&quot;#include &quot;Framework/Application/SlateApplication.h&quot;DEFINE_LOG_CATEGORY_STATIC(LogFirstProgram, Log, All);IMPLEMENT_APPLICATION(FirstProgram, &quot;FirstProgram&quot;);// INT32_MAIN_INT32_ARGC_TCHAR_ARGV()// &#123;//     GEngineLoop.PreInit(ArgC, ArgV);//     UE_LOG(LogFirstProgram, Display, TEXT(&quot;Hello World&quot;));//     FEngineLoop::AppExit();//     return 0;// &#125;/** * WinMain, called when the application is started */int WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR, _In_ int nCmdShow)&#123;    // start up the main loop    GEngineLoop.PreInit(GetCommandLineW());    // crank up a normal Slate application using the platform&#39;s standalone renderer    FSlateApplication::InitializeAsStandaloneApplication(GetStandardStandaloneRenderer());    // 创建一个窗口    TSharedPtr&lt;SWindow&gt; MainWindow = SNew(SWindow)    .ClientSize(FVector2D(800, 600))    [    SNullWidget::NullWidget    ];    FSlateApplication::Get().AddWindow(MainWindow.ToSharedRef());    // loop while the server does the rest    while (!IsEngineExitRequested())        &#123;            FSlateApplication::Get().PumpMessages();            FSlateApplication::Get().Tick();        &#125;    FSlateApplication::Shutdown();    return 0;&#125;</code></pre><p>其中只有下面这些是自己写的，其他的都是复制粘贴并删除部分代码的SlateViewerMainWindows.cpp和SlateViewerApp.cpp的内容<br>这里涉及到智能指针的使用<br><img src="/.com//image(11" alt="Alt text">.png)</p><hr><h1 id="SButton-按钮"><a href="#SButton-按钮" class="headerlink" title="SButton 按钮"></a>SButton 按钮</h1><blockquote><p>这节主要讲了如何给窗口添加一个按钮,并且给按钮添加一个点击事件.<br>参考的SButton路径:<strong>\UnrealEngine-release\Engine\Source\Runtime\Slate\Public\Widgets\Input\SButton.h</strong></p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>首先通过在资源管理器上在第一个新建的程序旁新建按钮的头文件和源文件(因为虚幻引擎不是靠sln来管理文件架构的,所以不要在VS里面进行文件的添加和删除).<br>创建好按钮的头文件和源文件以后使用bat文件重新生成一下项目.<br>这里我自定义文件名字叫SMybutton.</p><h2 id="SMybutton-h"><a href="#SMybutton-h" class="headerlink" title="SMybutton.h"></a>SMybutton.h</h2><p>声明了一个继承SButton的类,叫SMyButton,模仿SButton中的代码,声明一个Construct(初始化)和返回类型为FReply的按钮点击时执行的函数<br>```cpp</p><h1 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h1><h1 id="include-“Widgets-Input-SButton-h”"><a href="#include-“Widgets-Input-SButton-h”" class="headerlink" title="include “Widgets/Input/SButton.h”"></a>include “Widgets/Input/SButton.h”</h1></blockquote><p>class SMyButton : public SButton<br>{<br>public:<br>    /**</p><pre><code> * Construct this widget * * @param    InArgs    The declaration data for this widget */void Construct(const FArguments&amp; InArgs);</code></pre><p>private:<br>    FReply ButtonClicked();<br>};</p><pre><code>## SMybutton.cpp&gt; 实现初始化方法,首先调用父类的初始化的方法,然后在此基础上设置点击事件,当点击时执行SMyButton的ButtonClicked函数来返回一个信息窗口```cpp#include &quot;SMyButton.h&quot;void SMyButton::Construct(const FArguments&amp; InArgs)&#123;    SButton::Construct(InArgs);    this-&gt;SetOnClicked(FOnClicked::CreateRaw(this, &amp;SMyButton::ButtonClicked));&#125;FReply SMyButton::ButtonClicked()&#123;    FMessageDialog::Open(EAppMsgType::Ok, FText::FromString(&quot;Button is clicked!&quot;));    return FReply::Handled();&#125;</code></pre><h2 id="FirstProgram-cpp"><a href="#FirstProgram-cpp" class="headerlink" title="FirstProgram.cpp"></a>FirstProgram.cpp</h2><blockquote><p>自定义的按钮已经完成了,现在将其放到我们的第一个程序里创建的窗口里面.</p><pre><code class="lang-cpp">// 创建自定义的SButtonTSharedPtr&lt;SMyButton&gt; MyButton = SNew(SMyButton);   // 创建一个窗口TSharedPtr&lt;SWindow&gt; MainWindow = SNew(SWindow)    .ClientSize(FVector2D(800, 600))    [        // 窗口上放入自定义的SButton        MyButton.ToSharedRef()    ];</code></pre></blockquote><hr><h1 id="SCanvas-画布"><a href="#SCanvas-画布" class="headerlink" title="SCanvas 画布"></a>SCanvas 画布</h1><blockquote><p>SCanva翻译叫画布,学过UE的UMG就很好理解.</p></blockquote><p>依然在本地新建一个头文件和源文件,新建完以后构建一下.我这里命名为SMyCanvas.h与SMycanvas.cpp</p><h2 id="SMycanvas-h"><a href="#SMycanvas-h" class="headerlink" title="SMycanvas.h"></a>SMycanvas.h</h2><blockquote><p>通过继承SCanvas,和SButton一样定义一个初始化的函数<br>```cpp</p><h1 id="pragma-once-1"><a href="#pragma-once-1" class="headerlink" title="pragma once"></a>pragma once</h1><h1 id="include-“Widgets-SCanvas-h”"><a href="#include-“Widgets-SCanvas-h”" class="headerlink" title="include “Widgets/SCanvas.h”"></a>include “Widgets/SCanvas.h”</h1></blockquote><p>class SMyCanvas : public SCanvas<br>{<br>public:<br>    void Construct(const FArguments&amp; InArgs);<br>};</p><pre><code>## SMycanvas.cpp&gt; 除了执行父类的初始化函数之外,新增两个槽用来放上一章创建的SButton类.&gt; 这里的槽和Qt的槽还不是一个概念,Slate的槽是用来放控件的.```cpp#include &quot;SMyCanvas.h&quot;#include &quot;SMyButton.h&quot;void SMyCanvas::Construct(const FArguments&amp; InArgs)&#123;    SCanvas::Construct(InArgs);    AddSlot()        .Position(FVector2D(100, 100))        .Size(FVector2D(100, 40))        [            SNew(SMyButton)        ];    AddSlot()        .Position(FVector2d(300, 100))        .Size(FVector2D(100, 40))        [            SNew(SMyButton)        ];&#125;</code></pre><h2 id="FirstProgram-cpp-1"><a href="#FirstProgram-cpp-1" class="headerlink" title="FirstProgram.cpp"></a>FirstProgram.cpp</h2><blockquote><p>在窗口下放刚才定义的SCanvas</p><pre><code class="lang-cpp">// 创建自定义的ScanvasTSharedPtr&lt;SMyCanvas&gt; MyCanvas = SNew(SMyCanvas);// 创建一个窗口TSharedPtr&lt;SWindow&gt; MainWindow = SNew(SWindow)    .ClientSize(FVector2D(800, 600))    [        MyCanvas.ToSharedRef()    ];</code></pre></blockquote><hr><h1 id="SComboBox下拉框"><a href="#SComboBox下拉框" class="headerlink" title="SComboBox下拉框"></a>SComboBox下拉框</h1><blockquote><p>在画布里面添加下拉框</p></blockquote><h2 id="SMyCanvas-h"><a href="#SMyCanvas-h" class="headerlink" title="SMyCanvas.h"></a>SMyCanvas.h</h2><pre><code class="lang-cpp">#pragma once#include &quot;Widgets/SCanvas.h&quot;class SMyCanvas : public SCanvas&#123;public:    void Construct(const FArguments&amp; InArgs);    TArray&lt;TSharedPtr&lt;FString&gt;&gt; Options; // ComboBox的项    int32 CurrentSelected = -1; // ComboBox的项的索引&#125;;</code></pre><h2 id="SMycanvas-cpp"><a href="#SMycanvas-cpp" class="headerlink" title="SMycanvas.cpp"></a>SMycanvas.cpp</h2><pre><code class="lang-cpp">#include &quot;SMyCanvas.h&quot;void SMyCanvas::Construct(const FArguments&amp; InArgs)&#123;    SCanvas::Construct(InArgs);    Options.Empty();    Options.Add(MakeShareable(new FString(&quot;Apple&quot;)));    Options.Add(MakeShareable(new FString(&quot;Banana&quot;)));    Options.Add(MakeShareable(new FString(&quot;Orange&quot;)));    AddSlot()        .Position(FVector2D(500, 100))        .Size(FVector2D(100, 40))        [            SNew(SComboBox&lt;TSharedPtr&lt;FString&gt;&gt;)            // ComboBox的内容            .OptionsSource(&amp;Options)            // 当生成ComboBox时执行,作用是显示ComboBox下拉框选项值的文本块            .OnGenerateWidget_Lambda([](TSharedPtr&lt;FString&gt; InValue) &#123;                return SNew(STextBlock).Text(FText::FromString(*InValue));                &#125;)            // 当ComboBox的选择发生改变时执行            .OnSelectionChanged_Lambda([this](TSharedPtr&lt;FString&gt; NewOption,ESelectInfo::Type SelectType) &#123;                    CurrentSelected = Options.Find(NewOption);                &#125;)            // SComboBox中嵌套的显示的文本块,负责显示SComboBox中选择的内容            [                SNew(STextBlock).Text_Lambda([this]() &#123;                    if (CurrentSelected &lt; 0 || CurrentSelected &gt; Options.Num() - 1)                        return FText::FromString(&quot;&quot;);                    else                        return FText::FromString(*Options[CurrentSelected]);                    &#125;)            ]        ];&#125;</code></pre><hr><h1 id="SHorizontalBox-SVerticalBox-水平布局和垂直布局"><a href="#SHorizontalBox-SVerticalBox-水平布局和垂直布局" class="headerlink" title="SHorizontalBox,SVerticalBox 水平布局和垂直布局"></a>SHorizontalBox,SVerticalBox 水平布局和垂直布局</h1><blockquote><p>在Scanvas(画布)上面直接添加一个水平布局和一个垂直布局来举例</p></blockquote><p>最终结果:<br><img src="/.com//image.png" alt="Alt text"></p><pre><code class="lang-cpp">#include &quot;SMyCanvas.h&quot;void SMyCanvas::Construct(const FArguments&amp; InArgs)&#123;    SCanvas::Construct(InArgs);    // 添加一个水平布局    AddSlot()        .Position(FVector2D(100, 200))        .Size(FVector2D(400, 40))        [            SNew(SHorizontalBox)            +SHorizontalBox::Slot()            [                SNew(SButton)            ]            +SHorizontalBox::Slot()            // 设置这个槽宽度占两个            .FillWidth(2.0f)            [                SNew(SButton)            ]            +SHorizontalBox::Slot()            [                SNew(SButton)            ]        ];    // 添加一个垂直布局    AddSlot()        .Position(FVector2D(100, 300))        .Size(FVector2D(100, 160))        [            SNew(SVerticalBox)            +SVerticalBox::Slot()            [                SNew(SButton)            ]            +SVerticalBox::Slot()            .FillHeight(2.0)            [                SNew(SButton)            ]            +SVerticalBox::Slot()            [                SNew(SButton)            ]        ];&#125;</code></pre><hr><h1 id="STreeView"><a href="#STreeView" class="headerlink" title="STreeView"></a>STreeView</h1><blockquote><p>新建SMyTreeView.cpp和SMyTreeView.h然后重新构建一下</p></blockquote><p>生成结果:<br><img src="/.com//image-1.png" alt="Alt text"></p><h2 id="SMyTreeView-h"><a href="#SMyTreeView-h" class="headerlink" title="SMyTreeView.h"></a>SMyTreeView.h</h2><pre><code class="lang-cpp">#pragma once// 树状图的Item数据class UTreeItemData&#123;public:    // Item的内容    FString MyName;    float MyHeight = 10;    // 每个item的子项数组    TArray&lt;TSharedPtr&lt;UTreeItemData&gt;&gt; Children;&#125;;// 树状图class SMyTreeView : public STreeView&lt;TSharedPtr&lt;UTreeItemData&gt;&gt;&#123;public:    void Construct(const FArguments&amp; InArgs);    // 树状图的item的数组    TArray&lt;TSharedPtr&lt;UTreeItemData&gt;&gt; TreeItemDatas;    // 声明生成树状图的函数    TSharedRef&lt;ITableRow&gt; GenerateRowItem(TSharedPtr&lt;UTreeItemData&gt; InTreeItemData, const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable);    // 声明获取项的子项的方法    void GetChildrenForItem(TSharedPtr&lt;UTreeItemData&gt; InTreeItem, TArray&lt;TSharedPtr&lt;UTreeItemData&gt;&gt;&amp; OutChildren);&#125;;</code></pre><h2 id="SMyTreeView-cpp"><a href="#SMyTreeView-cpp" class="headerlink" title="SMyTreeView.cpp"></a>SMyTreeView.cpp</h2><pre><code class="lang-cpp">#include &quot;SMyTreeView.h&quot;void SMyTreeView::Construct(const FArguments&amp; InArgs)&#123;    FArguments Arguments = InArgs;    // 创建item与设置item与数据与子项    TSharedPtr&lt;UTreeItemData&gt; ZhangSan = MakeShareable(new UTreeItemData);    ZhangSan-&gt;MyName = FString(&quot;zhangSan&quot;);    TSharedPtr&lt;UTreeItemData&gt; ZhangSan1 = MakeShareable(new UTreeItemData);    ZhangSan1-&gt;MyName = FString(&quot;ZhangSan1&quot;);    TSharedPtr&lt;UTreeItemData&gt; ZhangSan2 = MakeShareable(new UTreeItemData);    ZhangSan2-&gt;MyName = FString(&quot;ZhangSan2&quot;);    ZhangSan-&gt;Children.Add(ZhangSan1);    ZhangSan-&gt;Children.Add(ZhangSan2);    TSharedPtr&lt;UTreeItemData&gt; LiSi = MakeShareable(new UTreeItemData);    LiSi-&gt;MyName = FString(&quot;LiSi&quot;);    TSharedPtr&lt;UTreeItemData&gt; LiSi1 = MakeShareable(new UTreeItemData);    LiSi1-&gt;MyName = FString(&quot;LiSi1&quot;);    TSharedPtr&lt;UTreeItemData&gt; LiSi2 = MakeShareable(new UTreeItemData);    LiSi2-&gt;MyName = FString(&quot;LiSi2&quot;);    TSharedPtr&lt;UTreeItemData&gt; LiSi3 = MakeShareable(new UTreeItemData);    LiSi3-&gt;MyName = FString(&quot;LiSi3&quot;);    LiSi-&gt;Children.Add(LiSi1);    LiSi-&gt;Children.Add(LiSi2);    LiSi-&gt;Children.Add(LiSi3);    // 将item添加到数组    TreeItemDatas.Add(ZhangSan);    TreeItemDatas.Add(LiSi);    // 通过三个必须具备的委托来生成树状图    Arguments.TreeItemsSource(&amp;TreeItemDatas); //指认树状图的item    Arguments.OnGenerateRow_Raw(this, &amp;SMyTreeView::GenerateRowItem); // 指认生成的树状图每一行的内容    Arguments.OnGetChildren_Raw(this, &amp;SMyTreeView::GetChildrenForItem); // 指认如何获取item的子项    STreeView::Construct(Arguments);&#125;TSharedRef&lt;ITableRow&gt; SMyTreeView::GenerateRowItem(TSharedPtr&lt;UTreeItemData&gt; InTreeItemData, const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable)&#123;    return SNew(STableRow&lt;TSharedPtr&lt;UTreeItemData&gt;&gt;, OwnerTable)        [            SNew(SHorizontalBox)            + SHorizontalBox::Slot()        [            SNew(STextBlock)            .Text(FText::FromString(InTreeItemData-&gt;MyName))        ]    + SHorizontalBox::Slot()        [            SNew(STextBlock)            .Text(FText::FromString(FString::SanitizeFloat(InTreeItemData-&gt;MyHeight)))        ]        ];&#125;void SMyTreeView::GetChildrenForItem(TSharedPtr&lt;UTreeItemData&gt; InTreeItem, TArray&lt;TSharedPtr&lt;UTreeItemData&gt;&gt;&amp; OutChildren)&#123;    OutChildren = InTreeItem-&gt;Children;&#125;</code></pre><hr><h1 id="SlistView"><a href="#SlistView" class="headerlink" title="SlistView"></a>SlistView</h1><blockquote><p>跟STreeView差不多 就不加注释了</p><h2 id="SMylistView-h"><a href="#SMylistView-h" class="headerlink" title="SMylistView.h"></a>SMylistView.h</h2></blockquote><pre><code class="lang-cpp">#pragma onceclass UListViewItemData&#123;public:    FString MyName = &quot;ZhangSan&quot;;&#125;;class SMyListView :public SListView&lt;TSharedPtr&lt;UListViewItemData&gt;&gt;&#123;public:    void Construct(const FArguments&amp; InArgs);    TArray&lt;TSharedPtr&lt;UListViewItemData&gt;&gt; ListItemDatas;    TSharedRef&lt;ITableRow&gt; GenerateRowItem(TSharedPtr&lt;UListViewItemData&gt; InListViewItemData, const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable);&#125;;</code></pre><h2 id="SMyListView-cpp"><a href="#SMyListView-cpp" class="headerlink" title="SMyListView.cpp"></a>SMyListView.cpp</h2><pre><code class="lang-cpp">#include &quot;SMyListView.h&quot;void SMyListView::Construct(const FArguments&amp; InArgs)&#123;    FArguments Arguments = InArgs;    ListItemDatas.Add(MakeShareable(new UListViewItemData));    ListItemDatas.Add(MakeShareable(new UListViewItemData));    ListItemDatas.Add(MakeShareable(new UListViewItemData));    Arguments.ListItemsSource(&amp;ListItemDatas);    Arguments.OnGenerateRow_Raw(this, &amp;SMyListView::GenerateRowItem);    SListView::Construct(Arguments);&#125;TSharedRef&lt;ITableRow&gt; SMyListView::GenerateRowItem(TSharedPtr&lt;UListViewItemData&gt; InListViewItemData, const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable)&#123;    return SNew(STableRow&lt;TSharedPtr&lt;UListViewItemData&gt;&gt;, OwnerTable)        [            SNew(STextBlock)            .Text(FText::FromString(InListViewItemData-&gt;MyName))        ];&#125;</code></pre><hr><h1 id="SImage"><a href="#SImage" class="headerlink" title="SImage"></a>SImage</h1><blockquote><p>在之前的SMyCanvas.cpp里面添加新的槽并加入SImage控件<br>其中Icons.Warning使用的是UE自带的图片</p><pre><code class="lang-cpp">// 添加图像AddSlot()    .Position(FVector2D(400, 200))    .Size(FVector2D(200, 200))    [        SNew(SImage)        .Image(FCoreStyle::Get().GetBrush(&quot;Icons.Warning&quot;))    ];</code></pre></blockquote><hr><h1 id="SGridPanel"><a href="#SGridPanel" class="headerlink" title="SGridPanel"></a>SGridPanel</h1><blockquote><p>在之前的SMyCanvas.cpp里面添加新的槽并加入SGridPanel布局<br>```cpp<br>// 添加网格布局<br>AddSlot()<br>    .Position(FVector2D(400, 500))<br>    .Size(FVector2D(200, 200))</p></blockquote><pre><code>[    SNew(SGridPanel)    // 设置每个网格的行和列上的控件都占一份    .FillColumn(0, 1)    .FillColumn(1, 1)    .FillRow(0, 1)    .FillRow(1, 1)    + SGridPanel::Slot(0, 0)    [        SNew(SImage)        .Image(FCoreStyle::Get().GetBrush(&quot;Icons.Warning&quot;))    ]    + SGridPanel::Slot(0, 1)    [        SNew(SImage)        .Image(FCoreStyle::Get().GetBrush(&quot;Icons.Warning&quot;))    ]    + SGridPanel::Slot(1, 0)    [        SNew(SImage)        .Image(FCoreStyle::Get().GetBrush(&quot;Icons.Warning&quot;))    ]    + SGridPanel::Slot(1, 1)    [        SNew(SImage)        .Image(FCoreStyle::Get().GetBrush(&quot;Icons.Warning&quot;))    ]];</code></pre><pre><code>---# FTabManage&gt; 在FirstProgram.cpp里面直接添加FTabManage来体现FTabManage的使用方法,首先先把之前生成SWindow的代码注释掉.生成的结果如下图所示![Alt text](image-2.png)```cpp// Copyright Epic Games, Inc. All Rights Reserved.#include &quot;FirstProgram.h&quot;#include &quot;RequiredProgramMainCPPInclude.h&quot;#include &quot;StandaloneRenderer.h&quot;#include &quot;Framework/Application/SlateApplication.h&quot;#include &quot;SMyCanvas.h&quot;DEFINE_LOG_CATEGORY_STATIC(LogFirstProgram, Log, All);IMPLEMENT_APPLICATION(FirstProgram, &quot;FirstProgram&quot;);/** * WinMain, called when the application is started */int WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR, _In_ int nCmdShow)&#123;    // start up the main loop    GEngineLoop.PreInit(GetCommandLineW());    // crank up a normal Slate application using the platform&#39;s standalone renderer    FSlateApplication::InitializeAsStandaloneApplication(GetStandardStandaloneRenderer());    // FTabManager    TArray&lt;FName&gt; TabName = &#123; &quot;LeftTab1&quot;,&quot;LeftTab2&quot;,&quot;RightTopTab&quot;,&quot;RightBottomTab&quot; &#125;;    const TSharedRef&lt;FTabManager::FLayout&gt; Layout = FTabManager::NewLayout(TEXT(&quot;Layout&quot;)) // 新建Layout        -&gt;AddArea( // 为Layout添加Area            FTabManager::NewArea(800, 600) // 新建Area            -&gt;SetOrientation(EOrientation::Orient_Horizontal) // 设置方向为左右分割            -&gt;Split( // 设置左边的区域                FTabManager::NewStack() // 新增可堆叠在一起的栈                -&gt;AddTab(TabName[0],ETabState::OpenedTab) // 在这个栈里面添加一个Tab                -&gt;AddTab(TabName[1], ETabState::OpenedTab) // 在这个栈里面再添加一个Tab            )            -&gt;Split( // 设置右边的区域                FTabManager::NewSplitter() // 在右边的区域新增一个分割块                -&gt;SetOrientation(EOrientation::Orient_Vertical) // 设置分割块为上下分割                -&gt;Split( // 设置右边上方的分割区域                    FTabManager::NewStack() // 新增可堆叠在一起的栈                    -&gt;AddTab(TabName[2],ETabState::OpenedTab) // 添加Tab                )                -&gt;Split( // 设置右边下方的分割区域                    FTabManager::NewStack()// 新增可堆叠在一起的栈                    -&gt;AddTab(TabName[3],ETabState::OpenedTab)// 添加Tab                )            )        );    FGlobalTabmanager::Get()-&gt;RestoreFrom(Layout, TSharedPtr&lt;SWindow&gt;()); // 将Layout放到SWindow里面    // loop while the server does the rest    while (!IsEngineExitRequested())    &#123;        FSlateApplication::Get().PumpMessages();        FSlateApplication::Get().Tick();    &#125;    FSlateApplication::Shutdown();    return 0;&#125;</code></pre><hr><h1 id="SDockTab-给Tab添加内容并令Tab能够进行拖拽与停靠"><a href="#SDockTab-给Tab添加内容并令Tab能够进行拖拽与停靠" class="headerlink" title="SDockTab(给Tab添加内容并令Tab能够进行拖拽与停靠)"></a>SDockTab(给Tab添加内容并令Tab能够进行拖拽与停靠)</h1><blockquote><p>要实现这样的Tab,需要通过FGlobalTabmanager::Get()-&gt;RegisterTabSpawner来注册SDockTab</p></blockquote><ul><li>这里解释一下工厂函数FOnSpawnTab::CreateLambda配合C++的lambda语法是怎么样的:</li><li>FOnSpawnTab::CreateLambda([&amp;](const FSpawnTabArgs&amp; Args)-&gt;TSharedRef<SDockTab> {})</SDockTab></li><li>首先工厂函数FOnSpawnTab::CreateLambda的作用是接收一个lambda表达式来生成一个tab</li><li>[&amp;](const FSpawnTabArgs&amp; Args)-&gt;TSharedRef<SDockTab> {}就是一个lambda语法,语法为:[捕获列表](参数列表)-&gt;返回类型{函数体}</SDockTab></li><li>捕获列表意思是函数体可以使用的外部的参数,&amp;表示所有外部的参数都能使用,参数列表为传入函数体的参数,-&gt;后是返回的类型<br><img src="/.com//image-3.png" alt="Alt text"><br>通过以下代码将名字叫LeftTab1的Tab定义成DockTab并且定义Tab的内容<pre><code class="lang-cpp">TArray&lt;FName&gt; TabName = &#123; &quot;LeftTab1&quot;,&quot;LeftTab2&quot;,&quot;RightTopTab&quot;,&quot;RightBottomTab&quot;&#125;;// 注册一个Tab,并使Tab可以被拖拽和停靠边缘,tab下存在一个按钮.FGlobalTabmanager::Get()-&gt;RegisterTabSpawner(TabName[0], FOnSpawnTab::CreateLambda(  [&amp;](const FSpawnTabArgs&amp; Args)-&gt;TSharedRef&lt;SDockTab&gt; &#123;      return SNew(SDockTab)          [              SNew(SButton)              .Text(FText::FromName(TabName[0]))          ];  &#125;));</code></pre></li></ul><hr><h1 id="制作菜单栏"><a href="#制作菜单栏" class="headerlink" title="制作菜单栏"></a>制作菜单栏</h1><blockquote><p>制作如图所示菜单栏<br>其中MyMenu为菜单栏,OpenFile和CloseFile,SaveFile这些都是菜单栏下对应的命令.<br>MyEditor是负责控制总UI的,想要显示这个UI就需要在FirstProgram.cpp(自己创建的程序)里面创建一个MyEditor对象就可以了.</p></blockquote><p><img src="/.com//image-4.png" alt="Alt text"></p><hr><h2 id="FMenuBarBuilder-生成菜单栏"><a href="#FMenuBarBuilder-生成菜单栏" class="headerlink" title="FMenuBarBuilder 生成菜单栏"></a>FMenuBarBuilder 生成菜单栏</h2><p>生成菜单栏也就是创建FMenuBarBuilder这个类,创建这个类有一个必须要的参数是FUICommandList类型的智能指针<br>菜单栏的类型为SWidget,因此有了FMenuBarBuilder的对象以后就可以通过MakeWidget函数来得到菜单栏.</p><hr><h2 id="TCommands-设置菜单栏下对应的命令"><a href="#TCommands-设置菜单栏下对应的命令" class="headerlink" title="TCommands 设置菜单栏下对应的命令"></a>TCommands 设置菜单栏下对应的命令</h2><p>通过继承TCommands创建一个属于自己的命令,然后通过UI_COMMAND定义命令的信息</p><hr><h2 id="FUICommandList"><a href="#FUICommandList" class="headerlink" title="FUICommandList"></a>FUICommandList</h2><p>通过FNewMenuDelegate::CreateLambda来将命令添加到菜单栏上,通过FUICommandList的对象的MapAction方法可以将菜单栏上的命令对应的执行功能.</p><hr><h2 id="总的代码"><a href="#总的代码" class="headerlink" title="总的代码"></a>总的代码</h2><h3 id="MyCommands-h"><a href="#MyCommands-h" class="headerlink" title="MyCommands.h"></a>MyCommands.h</h3><pre><code class="lang-cpp">#pragma once#include &quot;Framework/Commands/Commands.h&quot;class MyCommands : public TCommands&lt;MyCommands&gt;&#123;public:    MyCommands();    virtual void RegisterCommands() override; // 声明重载父类的注册命令函数    // 声明三个命令    TSharedPtr&lt; FUICommandInfo &gt; OpenFileCommand;     TSharedPtr&lt; FUICommandInfo &gt; CloseFileCommand;    TSharedPtr&lt; FUICommandInfo &gt; SaveFileCommand;&#125;;</code></pre><h3 id="MyCommands-cpp"><a href="#MyCommands-cpp" class="headerlink" title="MyCommands.cpp"></a>MyCommands.cpp</h3><pre><code class="lang-cpp">#include &quot;MyCommands.h&quot;#define LOCTEXT_NAMESPACE &quot;MyCommands&quot;MyCommands::MyCommands()    :TCommands&lt;MyCommands&gt;(        TEXT(&quot;MyCommands&quot;), // Context name for fast lookup        NSLOCTEXT(&quot;Contexts&quot;, &quot;MyEditor&quot;, &quot;My Editor&quot;), // Localized context name for displaying        NAME_None,        FCoreStyle::Get().GetStyleSetName() // Icon Style Set        )&#123;&#125;void MyCommands::RegisterCommands()&#123;    // 定义三个命令的信息    UI_COMMAND(OpenFileCommand, &quot;OpenFile&quot;, &quot;This is OpenFile command.&quot;, EUserInterfaceActionType::Button, FInputChord(EModifierKey::Control,EKeys::O));    UI_COMMAND(CloseFileCommand, &quot;CloseFile&quot;, &quot;This is CloseFile command.&quot;, EUserInterfaceActionType::Button, FInputChord(EModifierKey::Control, EKeys::C));    UI_COMMAND(SaveFileCommand, &quot;SaveFile&quot;, &quot;This is SaveFile command.&quot;, EUserInterfaceActionType::Button, FInputChord(EModifierKey::Control, EKeys::S));&#125;#undef LOCTEXT_NAMESPACE</code></pre><h3 id="MyEditor-h"><a href="#MyEditor-h" class="headerlink" title="MyEditor.h"></a>MyEditor.h</h3><pre><code class="lang-cpp">#pragma onceclass MyEditor&#123;public:     MyEditor();    TSharedRef&lt;SWidget&gt; MakeMenuBar(); // 声明生成菜单栏的函数.    TSharedPtr&lt;FUICommandList&gt; CommandList;&#125;;</code></pre><h3 id="MyEditor-cpp"><a href="#MyEditor-cpp" class="headerlink" title="MyEditor.cpp"></a>MyEditor.cpp</h3><pre><code class="lang-cpp">#include &quot;MyEditor.h&quot;#include &quot;MyCommands.h&quot;#define LOCTEXT_NAMESPACE &quot;MyEditor&quot;MyEditor::MyEditor()&#123;    CommandList = MakeShareable(new FUICommandList);    // 进行注册命令    MyCommands::Register();    // 添加命令执行时对应的功能    CommandList-&gt;MapAction(MyCommands::Get().OpenFileCommand,        FExecuteAction::CreateLambda([]() &#123;            FMessageDialog::Open(EAppMsgType::Ok, FText::FromString(&quot;OpenFileCommand!&quot;));            &#125;)    );    CommandList-&gt;MapAction(MyCommands::Get().CloseFileCommand,        FExecuteAction::CreateLambda([]() &#123;            FMessageDialog::Open(EAppMsgType::Ok, FText::FromString(&quot;CloseFileCommand!&quot;));            &#125;)    );    CommandList-&gt;MapAction(MyCommands::Get().SaveFileCommand,        FExecuteAction::CreateLambda([]() &#123;            FMessageDialog::Open(EAppMsgType::Ok, FText::FromString(&quot;SaveFileCommand!&quot;));            &#125;)    );    // FTabManager    TArray&lt;FName&gt; TabName = &#123; &quot;LeftTab&quot;,&quot;RightTopTab&quot;,&quot;RightBottomTab&quot; &#125;;    // 注册一个Tab,并使Tab可以被拖拽和停靠边缘,tab下存在一个按钮.    FGlobalTabmanager::Get()-&gt;RegisterTabSpawner(TabName[0], FOnSpawnTab::CreateLambda(        [&amp;](const FSpawnTabArgs&amp; Args)-&gt;TSharedRef&lt;SDockTab&gt; &#123;            return SNew(SDockTab)                [                    SNew(SVerticalBox)                    + SVerticalBox::Slot()                    .AutoHeight() // 设置菜单栏为合适的高度                [                    MakeMenuBar()                ]                    +SVerticalBox::Slot()                    .FillHeight(1.f)                [                    SNew(SButton)                    .Text(FText::FromName(TabName[0]))                ]                ];        &#125;    ));    FGlobalTabmanager::Get()-&gt;RegisterTabSpawner(TabName[1], FOnSpawnTab::CreateLambda(        [&amp;](const FSpawnTabArgs&amp; Args)-&gt;TSharedRef&lt;SDockTab&gt; &#123;            return SNew(SDockTab)                [                    SNew(SButton)                    .Text(FText::FromName(TabName[1]))                ];        &#125;    ));    FGlobalTabmanager::Get()-&gt;RegisterTabSpawner(TabName[2], FOnSpawnTab::CreateLambda(        [&amp;](const FSpawnTabArgs&amp; Args)-&gt;TSharedRef&lt;SDockTab&gt; &#123;            return SNew(SDockTab)                [                    SNew(SButton)                    .Text(FText::FromName(TabName[2]))                ];        &#125;    ));    const TSharedRef&lt;FTabManager::FLayout&gt; Layout = FTabManager::NewLayout(TEXT(&quot;Layout&quot;)) // 新建Layout        -&gt;AddArea( // 为Layout添加Area            FTabManager::NewArea(800, 600) // 新建Area            -&gt;SetOrientation(EOrientation::Orient_Horizontal) // 设置方向为左右分割            -&gt;Split( // 设置左边的区域                FTabManager::NewStack() // 新增可堆叠在一起的栈                -&gt;AddTab(TabName[0], ETabState::OpenedTab) // 在这个栈里面添加一个Tab            )            -&gt;Split( // 设置右边的区域                FTabManager::NewSplitter() // 在右边的区域新增一个分割块                -&gt;SetOrientation(EOrientation::Orient_Vertical) // 设置分割块为上下分割                -&gt;Split( // 设置右边上方的分割区域                    FTabManager::NewStack() // 新增可堆叠在一起的栈                    -&gt;AddTab(TabName[1], ETabState::OpenedTab) // 添加Tab                )                -&gt;Split( // 设置右边下方的分割区域                    FTabManager::NewStack()// 新增可堆叠在一起的栈                    -&gt;AddTab(TabName[2], ETabState::OpenedTab)// 添加Tab                )            )        );    FGlobalTabmanager::Get()-&gt;RestoreFrom(Layout, TSharedPtr&lt;SWindow&gt;()); // 将Layout放到SWindow里面&#125;// 负责生成菜单栏的函数TSharedRef&lt;SWidget&gt; MyEditor::MakeMenuBar()&#123;    FMenuBarBuilder MenuBuilder(CommandList); // 生成一个FMenuBarBuilder对象,传入FUICommandList类型的智能指针    MenuBuilder.AddPullDownMenu(        LOCTEXT(&quot;MyMenu&quot;, &quot;MyMenu&quot;), // 菜单名        LOCTEXT(&quot;MyMenu&quot;, &quot;This is my menu&quot;), // 菜单提示词        // 将命令添加到菜单栏上        FNewMenuDelegate::CreateLambda(            [](FMenuBuilder&amp; MenuBuilder)&#123;                MenuBuilder.AddMenuEntry(MyCommands::Get().OpenFileCommand);                MenuBuilder.AddMenuEntry(MyCommands::Get().CloseFileCommand);                MenuBuilder.AddMenuEntry(MyCommands::Get().SaveFileCommand);            &#125;        )    );    return MenuBuilder.MakeWidget(); &#125;#undef LOCTEXT_NAMESPACE</code></pre><hr><h1 id="FToolBarBuilder-创建工具架"><a href="#FToolBarBuilder-创建工具架" class="headerlink" title="FToolBarBuilder 创建工具架"></a>FToolBarBuilder 创建工具架</h1><p>这次通过上一节创建菜单栏需要的TCommand添加到工具架上.<br><img src="/.com//image-5.png" alt="Alt text"><br>思路就是仿照上一节的MakeMenuBar函数来创建一个MakeToolBar函数.然后通过这个函数返回一个SWidget,然后将这个函数放到布局里面就可以了.<br>函数代码如下:</p><pre><code class="lang-cpp">TSharedRef&lt;SWidget&gt; MyEditor::MakeToolBar()&#123;    FToolBarBuilder ToolBarBuilder(CommandList,FMultiBoxCustomization::None);    ToolBarBuilder.BeginSection(&quot;MySection&quot;);        ToolBarBuilder.AddToolBarButton(MyCommands::Get().OpenFileCommand);        ToolBarBuilder.AddToolBarButton(MyCommands::Get().CloseFileCommand);        ToolBarBuilder.AddToolBarButton(MyCommands::Get().SaveFileCommand);    ToolBarBuilder.EndSection();    return ToolBarBuilder.MakeWidget();&#125;</code></pre><hr><h1 id="SEditableText-文本编辑框"><a href="#SEditableText-文本编辑框" class="headerlink" title="SEditableText 文本编辑框"></a>SEditableText 文本编辑框</h1><h2 id="添加文本编辑框"><a href="#添加文本编辑框" class="headerlink" title="添加文本编辑框"></a>添加文本编辑框</h2><p>其中<strong>EditableText</strong>是在头文件中声明的SEditableText类型的智能指针:TSharedPtr<SEditableText> EditableText;</SEditableText></p><pre><code class="lang-cpp">SNew(SVerticalBox)+SVerticalBox::Slot()[SAssignNew(EditableText,SEditableText)]</code></pre><h2 id="获取文本编辑框中的文字"><a href="#获取文本编辑框中的文字" class="headerlink" title="获取文本编辑框中的文字"></a>获取文本编辑框中的文字</h2><p>这里展示通过按钮点击弹出消息框,消息框内容是文本编辑框中的文字的演示:<br>主要代码为:<strong>EditableText-&gt;GetText()</strong>,其中EditableText为添加文本编辑框时创建的SEditableText类型的智能指针.</p><pre><code class="lang-cpp">SNew(SButton).Text(FText::FromName(TabName[1])).OnClicked_Lambda(    [this]() &#123;        FMessageDialog::Open(EAppMsgType::Ok, EditableText-&gt;GetText());        return FReply::Handled();    &#125;)</code></pre><hr><h1 id="SSplitter"><a href="#SSplitter" class="headerlink" title="SSplitter"></a>SSplitter</h1><blockquote><p>添加分割左右两边的分割条,左边为一个button,右边为一个button,左边的button大小是右边的button大小的二倍</p></blockquote><p><img src="/.com//image-6.png" alt="Alt text"></p><pre><code class="lang-cpp">SNew(SSplitter)+SSplitter::Slot().Value(2.0f) // 设置这个槽占两份[    SNew(SButton)    .Text(FText::FromName(TabName[2]))]+SSplitter::Slot()[    SNew(SButton)    .Text(FText::FromName(TabName[2]))]</code></pre><hr><h1 id="Sborder-填充"><a href="#Sborder-填充" class="headerlink" title="Sborder 填充"></a>Sborder 填充</h1><blockquote><p>填充类型分为颜色填充和图像填充和九宫格填充<br>其中颜色填充需要新建一个<strong>static</strong>成员变量</p></blockquote><p>效果如下:<br><img src="/.com//image-7.png" alt="Alt text"><br>添加方法如下:</p><pre><code class="lang-cpp">static FSlateColorBrush ColorBrush = FSlateColorBrush(FLinearColor(1.0f, 1.0f, 0.0f, 1.0f));SNew(SVerticalBox)+SVerticalBox::Slot().FillHeight(1.f)[    // 颜色填充    SNew(SBorder)    .BorderImage(&amp;ColorBrush)]+SVerticalBox::Slot()[    // 图像填充    SNew(SBorder)    .BorderImage(FCoreStyle::Get().GetBrush(&quot;Icons.Warning&quot;))]+SVerticalBox::Slot()[    // Box填充(九宫格)    SNew(SBorder)    .BorderImage(FCoreStyle::Get().GetBrush(&quot;Debug.Border&quot;))]</code></pre><hr><h1 id="SOverlay"><a href="#SOverlay" class="headerlink" title="SOverlay"></a>SOverlay</h1><blockquote><p>SOverlay属于布局,用法也跟布局一样,这个布局的显示效果为:布局下的后创建的槽会覆盖前面创建的槽,就跟PS的图层一样,后创建的图层会覆盖之前的图层.</p></blockquote><hr><h1 id="SLeafWidget"><a href="#SLeafWidget" class="headerlink" title="SLeafWidget"></a>SLeafWidget</h1><blockquote><p>可以通过继承SLeafWidget来创建自己的较简单的控件(这个控件不能够作为容器来包含其他控件).</p></blockquote><p>具体代码参考：</p><h2 id="SMyLeafWidget-h"><a href="#SMyLeafWidget-h" class="headerlink" title="SMyLeafWidget.h"></a>SMyLeafWidget.h</h2><pre><code class="lang-cpp">#pragma once#include &quot;Widgets/SLeafWidget.h&quot;class SMyLeafWidget : public SLeafWidget&#123;public:    // 定义在SNew(SMyLeafWidget)时可以设置的属性(步骤参考SLATE_BEGIN_ARGS这个宏)    SLATE_BEGIN_ARGS(SMyLeafWidget)         : _StartPoint(FVector2D(0,0))        , _EndPoint(FVector2D(0,0))    &#123;    &#125;    SLATE_ATTRIBUTE(FVector2D, StartPoint);    SLATE_ATTRIBUTE(FVector2D, EndPoint);    SLATE_END_ARGS()    // 构造函数    void Construct(const FArguments&amp; InArgs);private:    TArray&lt;FVector2D&gt; Points;    // 这两个函数是SLeafWidget声明的纯虚函数,因此必须定义    virtual FVector2D ComputeDesiredSize(float) const override;    virtual int32 OnPaint(        const FPaintArgs&amp; Args,        const FGeometry&amp; AllottedGeometry,        const FSlateRect&amp; MyCullingRect,        FSlateWindowElementList&amp; OutDrawElements,        int32 LayerId,        const FWidgetStyle&amp; InWidgetStyle,        bool bParentEnabled) const override;&#125;;</code></pre><h2 id="SMyLeafWidget-cpp"><a href="#SMyLeafWidget-cpp" class="headerlink" title="SMyLeafWidget.cpp"></a>SMyLeafWidget.cpp</h2><pre><code class="lang-cpp">#include &quot;SMyLeafWidget.h&quot;void SMyLeafWidget::Construct(const FArguments&amp; InArgs)&#123;    // 因为_StartPoint和_EndPoint都是属性，因此需要通过Get()来获取属性的值    Points.Add(InArgs._StartPoint.Get());    Points.Add(InArgs._EndPoint.Get());&#125;FVector2D SMyLeafWidget::ComputeDesiredSize(float) const&#123;    return FVector2D(50, 50);&#125;int32 SMyLeafWidget::OnPaint(    const FPaintArgs&amp; Args,    const FGeometry&amp; AllottedGeometry,    const FSlateRect&amp; MyCullingRect,    FSlateWindowElementList&amp; OutDrawElements,    int32 LayerId,    const FWidgetStyle&amp; InWidgetStyle,    bool bParentEnabled) const&#123;    // 绘制一条线    FSlateDrawElement::MakeLines(OutDrawElements, LayerId, AllottedGeometry.ToPaintGeometry(), Points);    return LayerId++;&#125;</code></pre><h2 id="FirstProgram-cpp-最终生成窗口使用控件的程序"><a href="#FirstProgram-cpp-最终生成窗口使用控件的程序" class="headerlink" title="FirstProgram.cpp(最终生成窗口使用控件的程序)"></a>FirstProgram.cpp(最终生成窗口使用控件的程序)</h2><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#include &quot;FirstProgram.h&quot;#include &quot;RequiredProgramMainCPPInclude.h&quot;#include &quot;StandaloneRenderer.h&quot;#include &quot;Framework/Application/SlateApplication.h&quot;#include &quot;SMyleafWidget.h&quot;DEFINE_LOG_CATEGORY_STATIC(LogFirstProgram, Log, All);IMPLEMENT_APPLICATION(FirstProgram, &quot;FirstProgram&quot;);/** * WinMain, called when the application is started */int WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR, _In_ int nCmdShow)&#123;    // start up the main loop    GEngineLoop.PreInit(GetCommandLineW());    // crank up a normal Slate application using the platform&#39;s standalone renderer    FSlateApplication::InitializeAsStandaloneApplication(GetStandardStandaloneRenderer());    // 创建SMyLeafWidget控件的共享指针    TSharedPtr&lt;SMyLeafWidget&gt; MyLeafWidget =         SNew(SMyLeafWidget)        .StartPoint(FVector2D(0.f,0.f))        .EndPoint(FVector2D(200.f,200.f));    // 创建一个窗口    TSharedPtr&lt;SWindow&gt; MainWindow = SNew(SWindow)        .ClientSize(FVector2D(800, 600))        [            MyLeafWidget.ToSharedRef() // 共享指针转共享引用        ];    FSlateApplication::Get().AddWindow(MainWindow.ToSharedRef());    /*MyEditor::MyEditor();*/    // loop while the server does the rest    while (!IsEngineExitRequested())    &#123;        FSlateApplication::Get().PumpMessages();        FSlateApplication::Get().Tick();    &#125;    FSlateApplication::Shutdown();    return 0;&#125;</code></pre><hr><h1 id="SCompoundWidget"><a href="#SCompoundWidget" class="headerlink" title="SCompoundWidget"></a>SCompoundWidget</h1><blockquote><p>可以通过继承SCompoundWidget来创建自己的较复杂的控件(这个控件能够作为容器来包含其他控件,这是它与SLeafWidget的不同).</p></blockquote><h2 id="SMyCompoundWidget-h"><a href="#SMyCompoundWidget-h" class="headerlink" title="SMyCompoundWidget.h"></a>SMyCompoundWidget.h</h2><pre><code class="lang-cpp">#pragma onceclass SMyCompoundWidget : public SCompoundWidget&#123;public:    SLATE_BEGIN_ARGS(SMyCompoundWidget)        : _Content()        , _HAlign(HAlign_Fill)        , _VAlign(VAlign_Fill)    &#123;&#125;    SLATE_DEFAULT_SLOT(FArguments, Content) // 这个CompoundWidget有一个槽    SLATE_ARGUMENT(EHorizontalAlignment, HAlign) // 可以通过HAlign调整左右对齐    SLATE_ARGUMENT(EVerticalAlignment, VAlign) // 可以通过VAlign调整上下对齐    SLATE_END_ARGS()    void Construct(const FArguments&amp; InArgs);&#125;;</code></pre><h2 id="SMyCompoundWidget-cpp"><a href="#SMyCompoundWidget-cpp" class="headerlink" title="SMyCompoundWidget.cpp"></a>SMyCompoundWidget.cpp</h2><pre><code class="lang-cpp">#include &quot;SMyCompoundWidget.h&quot;void SMyCompoundWidget::Construct(const FArguments&amp; InArgs)&#123;    ChildSlot    .HAlign(InArgs._HAlign)    .VAlign(InArgs._VAlign)    [        InArgs._Content.Widget    ];&#125;</code></pre><hr><h1 id="SCustomDialog"><a href="#SCustomDialog" class="headerlink" title="SCustomDialog"></a>SCustomDialog</h1><blockquote><p><strong>由于CustomDialog是编辑器使用的模块,因此不能够直接include来使用,所以找到其源文件复制到程序文件夹中进行使用.</strong><br>将其复制到自己程序的文件夹中后改一下自己想要定义的名字,然后将其内容修改一下使其能够自己使用.</p></blockquote><h2 id="SMyCustomDialog-h"><a href="#SMyCustomDialog-h" class="headerlink" title="SMyCustomDialog.h"></a>SMyCustomDialog.h</h2><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#pragma once#include &quot;Widgets/SWindow.h&quot;/** This is a custom dialog class, which allows any Slate widget to be used as the contents, * with any number of buttons that have any text.  * It also supports adding a custom icon to the dialog. * Usage: * TSharedRef&lt;SCustomDialog&gt; HelloWorldDialog = SNew(SCustomDialog)        .Title(FText(LOCTEXT(&quot;HelloWorldTitleExample&quot;, &quot;Hello, World!&quot;)))        .DialogContent( SNew(SImage).Image(FName(TEXT(&quot;Hello&quot;))))        .Buttons(&#123;            SCustomDialog::FButton(LOCTEXT(&quot;OK&quot;, &quot;OK&quot;)),            SCustomDialog::FButton(LOCTEXT(&quot;Cancel&quot;, &quot;Cancel&quot;))        &#125;);   // returns 0 when OK is pressed, 1 when Cancel is pressed, -1 if the window is closed   const int ButtonPressed = HelloWorldDialog-&gt;ShowModal(); */class SMyCustomDialog : public SWindow&#123;public:    struct FButton    &#123;        FButton(const FText&amp; InButtonText, const FSimpleDelegate&amp; InOnClicked = FSimpleDelegate())            : ButtonText(InButtonText),            OnClicked(InOnClicked)        &#123;        &#125;        FText ButtonText;        FSimpleDelegate OnClicked;    &#125;;    SLATE_BEGIN_ARGS(SMyCustomDialog)        : _UseScrollBox(true)        , _ScrollBoxMaxHeight(300)    &#123;        _AccessibleParams = FAccessibleWidgetData(EAccessibleBehavior::Auto);    &#125;        /** Title to display for the dialog. */        SLATE_ARGUMENT(FText, Title)        /** Optional icon to display in the dialog. (default: none) */        SLATE_ARGUMENT(FName, IconBrush)        /** Should this dialog use a scroll box for over-sized content? (default: true) */        SLATE_ARGUMENT(bool, UseScrollBox)        /** Max height for the scroll box (default: 300) */        SLATE_ARGUMENT(int32, ScrollBoxMaxHeight)        /** The buttons that this dialog should have. One or more buttons must be added.*/        SLATE_ARGUMENT(TArray&lt;FButton&gt;, Buttons)        /** Content for the dialog */        SLATE_ARGUMENT(TSharedPtr&lt;SWidget&gt;, DialogContent)        /** Event triggered when the dialog is closed, either because one of the buttons is pressed, or the windows is closed. */        SLATE_EVENT(FSimpleDelegate, OnClosed)    SLATE_END_ARGS()    void Construct(const FArguments&amp; InArgs);    /** Show the dialog.     * This method will return immediately.     */     void Show();    /** Show a modal dialog. Will block until an input is received.     * Returns the index of the button that was pressed.     */    int32 ShowModal();private:    FReply OnButtonClicked(FSimpleDelegate OnClicked, int32 ButtonIndex);    /** The index of the button that was pressed last. */    int32 LastPressedButton = -1;    FSimpleDelegate OnClosed;&#125;;</code></pre><h2 id="SMyCustomDialog-cpp"><a href="#SMyCustomDialog-cpp" class="headerlink" title="SMyCustomDialog.cpp"></a>SMyCustomDialog.cpp</h2><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#include &quot;SMyCustomDialog.h&quot;#include &quot;HAL/PlatformApplicationMisc.h&quot;#include &quot;Framework/Application/SlateApplication.h&quot;#include &quot;Framework/Docking/TabManager.h&quot;#include &quot;Logging/LogMacros.h&quot;#include &quot;Styling/SlateBrush.h&quot;#include &quot;Widgets/Images/SImage.h&quot;#include &quot;Widgets/Input/SButton.h&quot;#include &quot;Widgets/Text/STextBlock.h&quot;#include &quot;Widgets/Layout/SSpacer.h&quot;#include &quot;Widgets/Layout/SBox.h&quot;#include &quot;Widgets/Layout/SScrollBox.h&quot;#include &quot;Widgets/Layout/SUniformGridPanel.h&quot;#include &quot;Widgets/SBoxPanel.h&quot;DEFINE_LOG_CATEGORY_STATIC(LogCustomDialog, Log, All);void SMyCustomDialog::Construct(const FArguments&amp; InArgs)&#123;    UE_LOG(LogCustomDialog, Log, TEXT(&quot;Dialog displayed:&quot;), *InArgs._Title.ToString());    check(InArgs._Buttons.Num() &gt; 0);    OnClosed = InArgs._OnClosed;    TSharedPtr&lt;SHorizontalBox&gt; ContentBox;    TSharedPtr&lt;SHorizontalBox&gt; ButtonBox;    SWindow::Construct( SWindow::FArguments()        .Title(InArgs._Title)        .SizingRule(ESizingRule::Autosized)        .SupportsMaximize(false)        .SupportsMinimize(false)        [            SNew(SBorder)            .Padding(4.f)            .BorderImage(FCoreStyle::Get().GetBrush( &quot;ToolPanel.GroupBorder&quot; ))            [                SNew(SVerticalBox)                + SVerticalBox::Slot()                .FillHeight(1.0f)                [                    SAssignNew(ContentBox, SHorizontalBox)                ]                + SVerticalBox::Slot()                .VAlign(VAlign_Center)                .AutoHeight()                [                    SAssignNew(ButtonBox, SHorizontalBox)                ]            ]        ] );    if (InArgs._IconBrush.IsValid())    &#123;        const FSlateBrush* ImageBrush = FCoreStyle::Get().GetBrush(InArgs._IconBrush);        if (ImageBrush != nullptr)        &#123;            ContentBox-&gt;AddSlot()                .AutoWidth()                .VAlign(VAlign_Center)                .HAlign(HAlign_Left)                .Padding(0, 0, 8, 0)                [                    SNew(SImage)                    .Image(ImageBrush)                ];        &#125;    &#125;    if (InArgs._UseScrollBox)    &#123;        ContentBox-&gt;AddSlot()        [            SNew(SBox)            .MaxDesiredHeight(InArgs._ScrollBoxMaxHeight)            [                SNew(SScrollBox)                +SScrollBox::Slot()                [                    InArgs._DialogContent.ToSharedRef()                ]            ]        ];    &#125;    else    &#123;        ContentBox-&gt;AddSlot()            .FillWidth(1.0f)            .VAlign(VAlign_Center)            .HAlign(HAlign_Left)            [                InArgs._DialogContent.ToSharedRef()            ];    &#125;    ButtonBox-&gt;AddSlot()        .AutoWidth()        [            SNew(SSpacer)            .Size(FVector2D(20.0f, 1.0f))        ];    TSharedPtr&lt;SUniformGridPanel&gt; ButtonPanel;    ButtonBox-&gt;AddSlot()         .FillWidth(1.0f)        .VAlign(VAlign_Center)        .HAlign(HAlign_Right)        [            SAssignNew(ButtonPanel, SUniformGridPanel) // 控制按钮的大小            .SlotPadding(0)            .MinDesiredSlotWidth(100)            .MinDesiredSlotHeight(30)        ];    for (int32 i = 0; i &lt; InArgs._Buttons.Num(); ++i)    &#123;        const FButton&amp; Button = InArgs._Buttons[i];        ButtonPanel-&gt;AddSlot(ButtonPanel-&gt;GetChildren()-&gt;Num(), 0)        [            SNew(SButton)            .OnClicked(FOnClicked::CreateSP(this, &amp;SMyCustomDialog::OnButtonClicked, Button.OnClicked, i))            [                SNew(SHorizontalBox)                + SHorizontalBox::Slot()                .VAlign(VAlign_Center)                .HAlign(HAlign_Center)                [                    SNew(STextBlock)                    .Text(Button.ButtonText)                ]            ]        ];    &#125;&#125;int32 SMyCustomDialog::ShowModal()&#123;    FSlateApplication::Get().AddModalWindow(StaticCastSharedRef&lt;SWindow&gt;(this-&gt;AsShared()), FGlobalTabmanager::Get()-&gt;GetRootWindow());    return LastPressedButton;&#125;void SMyCustomDialog::Show()&#123;    TSharedRef&lt;SWindow&gt; Window = FSlateApplication::Get().AddWindow(StaticCastSharedRef&lt;SWindow&gt;(this-&gt;AsShared()), true);    if (OnClosed.IsBound())    &#123;        Window-&gt;GetOnWindowClosedEvent().AddLambda([this](const TSharedRef&lt;SWindow&gt;&amp; Window) &#123; OnClosed.Execute(); &#125;);    &#125;&#125;/** Handle the button being clicked */FReply SMyCustomDialog::OnButtonClicked(FSimpleDelegate OnClicked, int32 ButtonIndex)&#123;    LastPressedButton = ButtonIndex;    FSlateApplication::Get().RequestDestroyWindow(StaticCastSharedRef&lt;SWindow&gt;(this-&gt;AsShared()));    OnClicked.ExecuteIfBound();    return FReply::Handled();&#125;</code></pre><h2 id="FirstProgram-cpp-2"><a href="#FirstProgram-cpp-2" class="headerlink" title="FirstProgram.cpp"></a>FirstProgram.cpp</h2><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#include &quot;FirstProgram.h&quot;#include &quot;RequiredProgramMainCPPInclude.h&quot;#include &quot;StandaloneRenderer.h&quot;#include &quot;Framework/Application/SlateApplication.h&quot;#include &quot;SMyCanvas.h&quot;#include &quot;MyEditor.h&quot;#include &quot;SMyleafWidget.h&quot;#include &quot;SMyCompoundWidget.h&quot;#include &quot;SMyCustomDialog.h&quot;#include &quot;Widgets/Input/SButton.h&quot;DEFINE_LOG_CATEGORY_STATIC(LogFirstProgram, Log, All);IMPLEMENT_APPLICATION(FirstProgram, &quot;FirstProgram&quot;);/** * WinMain, called when the application is started */int WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR, _In_ int nCmdShow)&#123;    // start up the main loop    GEngineLoop.PreInit(GetCommandLineW());    // crank up a normal Slate application using the platform&#39;s standalone renderer    FSlateApplication::InitializeAsStandaloneApplication(GetStandardStandaloneRenderer());    // 创建SMyCompoundWidget的共享指针    TSharedPtr&lt;SMyCompoundWidget&gt; MyCompoundWidget =        SNew(SMyCompoundWidget)        .HAlign(EHorizontalAlignment::HAlign_Center)        .VAlign(EVerticalAlignment::VAlign_Bottom)        [            // SNew(STextBlock).Text(FText::FromString(FString(&quot;Hello&quot;)))            //              SNew(SButton)            .Text(FText::FromString(FString(&quot;ShowDialog&quot;))) // UE5里面测试不加Text的话无法显示              .OnClicked_Lambda([]() &#123;                  // 弹出自定义对话框                  TSharedRef&lt;SMyCustomDialog&gt; MyCustomDialog = SNew(SMyCustomDialog)                  .Title(FText::FromString(FString(&quot;DialogTitle&quot;))) // 定义标题                  .DialogContent( // 定义dialog的内容                      SNew(SVerticalBox)                      +SVerticalBox::Slot()                      [                          SNew(STextBlock).Text(FText::FromString(FString(&quot;FirstRowText&quot;)))                      ]                      +SVerticalBox::Slot()                      [                          SNew(STextBlock).Text(FText::FromString(FString(&quot;SecondRowText&quot;)))                      ]                                  )                      .Buttons                      (&#123;                          SMyCustomDialog::FButton(FText::FromString(FString(&quot;Ok&quot;)))                          &#125;);                  MyCustomDialog-&gt;ShowModal();              return FReply::Handled();                  &#125;)        ];    // 创建一个窗口    TSharedPtr&lt;SWindow&gt; MainWindow = SNew(SWindow)        .ClientSize(FVector2D(800, 600))        [            MyCompoundWidget.ToSharedRef() // 共享指针转共享引用        ];    FSlateApplication::Get().AddWindow(MainWindow.ToSharedRef());    /*MyEditor::MyEditor();*/    // loop while the server does the rest    while (!IsEngineExitRequested())    &#123;        FSlateApplication::Get().PumpMessages();        FSlateApplication::Get().Tick();    &#125;    FSlateApplication::Shutdown();    return 0;&#125;</code></pre><hr><h1 id="SMultiLineEditableText"><a href="#SMultiLineEditableText" class="headerlink" title="SMultiLineEditableText"></a>SMultiLineEditableText</h1><blockquote><p>SMultiLineEditableText是可以直接用的,它的作用是多行文本编辑器,这一节的教程中并没有介绍其所具有的其他方法(下一节会将为其添加滚动条).只介绍了通过继承前面所讲的SCompoundWidget,然后把它放里面,然后加了个SBorder,给SBorder设置颜色填充并添加SMultiLineEditableText的例子.这里展示一下.</p></blockquote><h2 id="SMyMultiLineEditableText-h"><a href="#SMyMultiLineEditableText-h" class="headerlink" title="SMyMultiLineEditableText.h"></a>SMyMultiLineEditableText.h</h2><pre><code class="lang-cpp">#pragma once#include &quot;Widgets/Text/SMultiLineEditableText.h&quot;class SMyMultiLineEditableText : public SCompoundWidget&#123;public:    SLATE_BEGIN_ARGS(SMyMultiLineEditableText)    &#123;&#125;    SLATE_END_ARGS()    void Construct(const FArguments&amp; InArgs);&#125;;</code></pre><h2 id="SMyMultiLineEditableText-cpp"><a href="#SMyMultiLineEditableText-cpp" class="headerlink" title="SMyMultiLineEditableText.cpp"></a>SMyMultiLineEditableText.cpp</h2><pre><code class="lang-cpp">#include &quot;SMyMultiLineEditableText.h&quot;void SMyMultiLineEditableText::Construct(const FArguments&amp; InArgs)&#123;    static FSlateColorBrush ColorBrush = FSlateColorBrush(FLinearColor(0.25f, 0.25f, 0.25f, 0.25f));    ChildSlot        [            SNew(SBorder)            .BorderImage(&amp;ColorBrush)            [            SNew(SMultiLineEditableText)            ]        ];&#125;</code></pre><h2 id="FirstProgram-cpp-3"><a href="#FirstProgram-cpp-3" class="headerlink" title="FirstProgram.cpp"></a>FirstProgram.cpp</h2><pre><code class="lang-cpp">// Copyright Epic Games, Inc. All Rights Reserved.#include &quot;FirstProgram.h&quot;#include &quot;RequiredProgramMainCPPInclude.h&quot;#include &quot;StandaloneRenderer.h&quot;#include &quot;Framework/Application/SlateApplication.h&quot;#include &quot;SMyMultiLineEditableText.h&quot;DEFINE_LOG_CATEGORY_STATIC(LogFirstProgram, Log, All);IMPLEMENT_APPLICATION(FirstProgram, &quot;FirstProgram&quot;);/** * WinMain, called when the application is started */int WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR, _In_ int nCmdShow)&#123;    // start up the main loop    GEngineLoop.PreInit(GetCommandLineW());    // crank up a normal Slate application using the platform&#39;s standalone renderer    FSlateApplication::InitializeAsStandaloneApplication(GetStandardStandaloneRenderer());    // 创建SMyMultiLineEditableText的共享指针    TSharedPtr&lt;SMyMultiLineEditableText&gt; MyMultiLineEditableText = SNew(SMyMultiLineEditableText);    // 创建一个窗口    TSharedPtr&lt;SWindow&gt; MainWindow = SNew(SWindow)        .ClientSize(FVector2D(800, 600))        [            MyMultiLineEditableText.ToSharedRef() // 共享指针转共享引用        ];    FSlateApplication::Get().AddWindow(MainWindow.ToSharedRef());    /*MyEditor::MyEditor();*/    // loop while the server does the rest    while (!IsEngineExitRequested())    &#123;        FSlateApplication::Get().PumpMessages();        FSlateApplication::Get().Tick();    &#125;    FSlateApplication::Shutdown();    return 0;&#125;</code></pre><hr><h1 id="SScrollBar-滚动条"><a href="#SScrollBar-滚动条" class="headerlink" title="SScrollBar 滚动条"></a>SScrollBar 滚动条</h1><p>在上一节SMyMultiLineEditableText.cpp的基础上为文本编辑器添加滚动条<br><strong><em>SMyMultiLineEditableText.cpp</em></strong></p><pre><code class="lang-cpp">#include &quot;SMyMultiLineEditableText.h&quot;void SMyMultiLineEditableText::Construct(const FArguments&amp; InArgs)&#123;    static FSlateColorBrush ColorBrush = FSlateColorBrush(FLinearColor(0.25f, 0.25f, 0.25f, 0.25f));    TSharedPtr&lt;SScrollBar&gt; HorizontalScrollBar = SNew(SScrollBar).Orientation(EOrientation::Orient_Horizontal);    TSharedPtr&lt;SScrollBar&gt; VerticalScrollBar = SNew(SScrollBar).Orientation(EOrientation::Orient_Vertical);    ChildSlot        [            SNew(SBorder)            .BorderImage(&amp;ColorBrush)            [                SNew(SHorizontalBox)                + SHorizontalBox::Slot()                .FillWidth(1.0f)                [                    SNew(SVerticalBox)                    + SVerticalBox::Slot()                    .FillHeight(1.0f)                    [                        SNew(SMultiLineEditableText)                        .HScrollBar(HorizontalScrollBar)                        .VScrollBar(VerticalScrollBar)                    ]                    + SVerticalBox::Slot()                    .AutoHeight()                    [                        HorizontalScrollBar.ToSharedRef() // 教程中是在这里使用SAssignNew来传递给智能指针的,但是在UE5里面没有成功,改成在定义的时候SNew就好了.                    ]                ]                + SHorizontalBox::Slot()                .AutoWidth()                [                    VerticalScrollBar.ToSharedRef() // 同上注释                ]                ]        ];&#125;</code></pre><hr><h1 id="FNotificationInfo-通知框"><a href="#FNotificationInfo-通知框" class="headerlink" title="FNotificationInfo 通知框"></a>FNotificationInfo 通知框</h1><p>这里实现一个功能,当点击按钮时屏幕右下角会弹出通知框然后消失<br><img src="/.com//image-8.png" alt="Alt text"><br>由于不需要额外创建类,这里只贴出关键代码</p><pre><code class="lang-cpp">#include &quot;Widgets/Notifications/SNotificationList.h&quot;#include &quot;Framework/Notifications/NotificationManager.h&quot;SNew(SButton).Text(FText::FromName(TabName[1])).OnClicked_Lambda(    [&amp;]() &#123;        FNotificationInfo Info(NSLOCTEXT(&quot;MainFrame&quot;, &quot;RecompileInProgress&quot;, &quot;Compiling C++ Code&quot;));        Info.ExpireDuration = 5.0f;        Info.bFireAndForget = false;        FSlateNotificationManager::Get().AddNotification(Info).Get()-&gt;Fadeout();        return FReply::Handled();    &#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习的视频&quot;&gt;&lt;a href=&quot;#学习的视频&quot; class=&quot;headerlink&quot; title=&quot;学习的视频&quot;&gt;&lt;/a&gt;学习的视频&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV19L411L7XA/?p=2&amp;</summary>
      
    
    
    
    <category term="UE开发" scheme="http://example.com/categories/UE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UE_Slate" scheme="http://example.com/tags/UE-Slate/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象</title>
    <link href="http://example.com/2023/08/31/Geek-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2023/08/31/Geek-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2023-08-31T13:11:00.000Z</published>
    <updated>2024-07-27T18:58:06.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VisualStudio的最佳设置"><a href="#VisualStudio的最佳设置" class="headerlink" title="VisualStudio的最佳设置"></a>VisualStudio的最佳设置</h1><ol><li>新建项目<br><img src="/.com//image-7.png" alt="alt text"></li><li>点击显示所有文件,右键新建src文件夹用来放源码<br><img src="/.com//image-8.png" alt="alt text"></li><li>修改解决方案的属性<br>输出目录改为: $(SolutionDir)bin$(Platform)$(Configuration)\<br>中间目录改为: $(SolutionDir)intermediates\bin$(Platform)$(Configuration)\<br><img src="/.com//image-9.png" alt="alt text"></li></ol><h1 id="通过两个类的定义来快速学习与回顾C-的知识点"><a href="#通过两个类的定义来快速学习与回顾C-的知识点" class="headerlink" title="通过两个类的定义来快速学习与回顾C++的知识点"></a>通过两个类的定义来快速学习与回顾C++的知识点</h1><blockquote><p>包含的知识点有:<br><strong>防卫式声明</strong><br><strong>成员初始化列表</strong><br><strong>this关键字</strong><br><strong>符号重载</strong><br><strong>友元函数</strong><br><strong>内联函数</strong><br><strong>拷贝赋值与拷贝构造</strong></p></blockquote><hr><h2 id="complex-h-没有传指针的类"><a href="#complex-h-没有传指针的类" class="headerlink" title="complex.h(没有传指针的类)"></a>complex.h(没有传指针的类)</h2><pre><code class="lang-cpp">// 防卫式声明#ifndef __MYCOMPLEX__#define __MYCOMPLEX__class complex;  // 声明类//声明三个函数,返回类型为complex的引用complex&amp;  __doapl (complex* ths, const complex&amp; r);complex&amp;  __doami (complex* ths, const complex&amp; r);complex&amp;  __doaml (complex* ths, const complex&amp; r);class complex&#123;public:  complex (double r = 0, double i = 0): re (r), im (i) &#123; &#125; // 以初值列的形式定义构造函数,接收r和i两个参数,将r参数给变量re,i给变量im,函数体为空  // 重载各种运算符号  complex&amp; operator += (const complex&amp;);   complex&amp; operator -= (const complex&amp;);  complex&amp; operator *= (const complex&amp;);  complex&amp; operator /= (const complex&amp;);  // 定义real和imag函数,因为这两个函数里没有改动data,所以要加const  double real () const &#123; return re; &#125;  double imag () const &#123; return im; &#125;private:  double re, im;  // 将这三个函数作为complex这个类的友元函数,这样的话这三个函数就可以取得complex这个类的私有的成员  friend complex&amp; __doapl (complex *, const complex&amp;);  friend complex&amp; __doami (complex *, const complex&amp;);  friend complex&amp; __doaml (complex *, const complex&amp;);&#125;;// 定义__doapl函数,因为这个函数比较简单,所以定义为inline(内联函数),内联函数更快. 如果一个函数在类中定义的话,那么编辑器会自动尝试将其作为内联函数.// 定义为内敛函数并不代表它就一定会成为内联函数,编辑器会根据inline的添加而尝试将其作为内联函数,因为编辑器需要判断函数是否复杂.inline complex&amp;__doapl (complex* ths, const complex&amp; r)&#123;  ths-&gt;re += r.re;  ths-&gt;im += r.im;  return *ths;&#125;// complex&amp;是返回值的类型// complex::意思是这个是complex这个类的成员函数// 重载+=运算符,a+=b的话a会作为this来传递进来,this是一个指向a的指针.// 因为返回的东西不是local变量,不会执行完函数以后就消失,因此可以返回引用类型.// 因为参数r是不会改变的,所以前面加const// 传进来的参数设定为引用类型和值类型的区别: 传值的话就是传这个值的全部,这个值的空间大小有多大就传多大,但是传引用的话是传地址,占用的空间大小是通常是比较小的,所以通常建议传引用.// 将重载+=这个函数设定为complex的成员函数是因为这个+=是只针对complex这个类的,如果是想要非complex类能够使用这个运算符就需要将其定义为全局函数inline complex&amp;complex::operator += (const complex&amp; r)&#123;   return __doapl (this, r);&#125;inline complex&amp;__doami (complex* ths, const complex&amp; r)&#123;  ths-&gt;re -= r.re;  ths-&gt;im -= r.im;  return *ths;&#125;inline complex&amp;complex::operator -= (const complex&amp; r)&#123;  return __doami (this, r);&#125;inline complex&amp;__doaml (complex* ths, const complex&amp; r)&#123;  double f = ths-&gt;re * r.re - ths-&gt;im * r.im;  ths-&gt;im = ths-&gt;re * r.im + ths-&gt;im * r.re;  ths-&gt;re = f;  return *ths;&#125;inline complex&amp;complex::operator *= (const complex&amp; r)&#123;  return __doaml (this, r);&#125;inline doubleimag (const complex&amp; x)&#123;  return x.imag ();&#125;inline doublereal (const complex&amp; x)&#123;  return x.real ();&#125;inline complexoperator + (const complex&amp; x, const complex&amp; y)&#123;  return complex (real (x) + real (y), imag (x) + imag (y)); // 通过此语法来返回complex的临时对象,不需要给对象起名字.&#125;inline complexoperator + (const complex&amp; x, double y)&#123;  return complex (real (x) + y, imag (x));&#125;inline complexoperator + (double x, const complex&amp; y)&#123;  return complex (x + real (y), imag (y));&#125;#include &lt;cmath&gt;inline complexpolar (double r, double t)&#123;  return complex (r * cos (t), r * sin (t));&#125;inline complexconj (const complex&amp; x) &#123;  return complex (real (x), -imag (x));&#125;inline doublenorm (const complex&amp; x)&#123;  return real (x) * real (x) + imag (x) * imag (x);&#125;//防卫式声明#endif   //__MYCOMPLEX__</code></pre><hr><h2 id="string-h-传指针的类"><a href="#string-h-传指针的类" class="headerlink" title="string.h(传指针的类)"></a>string.h(传指针的类)</h2><pre><code class="lang-cpp">#ifndef __MYSTRING__#define __MYSTRING__class String&#123;public:                                    String(const char* cstr=0);  // 类接收的是指针                      String(const String&amp; str);   // 因为有指针,因此需要声明拷贝构造函数,接收的是自己   String&amp; operator=(const String&amp; str); // 因为有指针,因此需要声明拷贝赋值函数,接收的是自己   ~String(); // 析构函数,对象的生命结束时使用                                    char* get_c_str() const &#123; return m_data; &#125;private:   char* m_data; // 因为字符串的大小是不固定的,因此将去设为指针,就可以通过动态分配内存的方式来存了.&#125;;#include &lt;cstring&gt;// 构造函数的定义inlineString::String(const char* cstr)&#123;   if (cstr) &#123;      m_data = new char[strlen(cstr)+1]; // 分配空间传给指针,结尾有/0来表示结束,因此需要加1      strcpy(m_data, cstr); // strcpy是&lt;cstring&gt;头文件中带有的函数,通过strcpy将源字符串复制到m_data 中   &#125;   else &#123;         m_data = new char[1];      *m_data = &#39;\0&#39;;   &#125;&#125;// 析构函数的定义inlineString::~String()&#123;   delete[] m_data;&#125;// 拷贝赋值函数的定义// 之所以需要有拷贝赋值函数,是因为如果使用默认的赋值操作会造成内存泄漏,为什么会内存泄漏:一开始有指针ptra指向a内容,指针ptrb指向b内容,如果是默认的赋值操作,那么最终结果就是ptra和ptrb同时指向其中一个内容,那么另一个内容就没有被指向了,指针丢失,就没办法释放内存,就造成了内存泄漏.inlineString&amp; String::operator=(const String&amp; str)&#123;   if (this == &amp;str) // 如果是自我赋值就不能delete了.      return *this;   delete[] m_data; // 因为赋值本身指针已经指向了一个数据,因此需要先delete,避免内存泄漏   m_data = new char[ strlen(str.m_data) + 1 ];   strcpy(m_data, str.m_data); // 将来源端拷贝到目的端   return *this; // 为了能够连续的使用重载的赋值,因此返回*this,不然不能够连续使用重载的赋值,因为这个重载的赋值是string类型使用的.&#125;// 拷贝构造函数的定义// 跟拷贝赋值函数的作用是一样的,避免两个指针指向同一个东西而造成内存泄露.// 默认编辑器的拷贝是浅拷贝,这是深拷贝inlineString::String(const String&amp; str)&#123;   m_data = new char[ strlen(str.m_data) + 1 ]; // 分配空间   strcpy(m_data, str.m_data);&#125;#include &lt;iostream&gt;using namespace std;// 由于这个对于&lt;&lt;的重载是全局的,不是在类中的,所以它的参数是没有this指针的.// ostream&amp; os对应的是输出流对象,比如std::cout// 所以这个重载&lt;&lt;相当于支持cout&lt;&lt; String类型.ostream&amp; operator&lt;&lt;(ostream&amp; os, const String&amp; str)&#123;   os &lt;&lt; str.get_c_str();   return os;&#125;#endif</code></pre><hr><h1 id="防卫式声明"><a href="#防卫式声明" class="headerlink" title="防卫式声明"></a>防卫式声明</h1><blockquote><p>在头文件中添加防卫式声明后可以防止程序多次包含这个头文件。<br>这个防卫式声明的作用跟#program once作用差不多,目前个人喜欢用#program once。</p></blockquote><p><img src="/.com//image.png" alt="Alt text"></p><hr><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>假如我们现在定义一个名字叫做complex的类，然后它是有实部和虚部的，因此它就需要定义两个变量来充当它的实部和虚部。但是这个实部和虚部的类型可能是int也可能是float等等，这是不一定的。<br>像这种需要定义变量意义是一样的，但是类型不一定的时候，就可以借助模板了。</p><blockquote><p>向下方这些代码一样，我们可以以T来代替类型然后当使用时就可以通过”&lt;&gt;”来指定类型了。</p></blockquote><p>举例一： complex\<double> c1(2.5,1.5);与 complex\<int> c2(2,6)</int></double></p><pre><code class="lang-cpp">template&lt;typename T&gt; // 告诉编辑器这个T是一个模板class complex&#123;public:    complex (T r=0, T i=0)      : re (r), im (i)    &#123; &#125;private:    T re, im;&#125;;</code></pre><p>举例二:</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;string&gt;template&lt;typename T,int N&gt;class Array&#123;private:    T m_array[N];public:    int GetSize() &#123; return N; &#125;&#125;;int main()&#123;    Array&lt;std::string, 5&gt; array1;    Array&lt;int, 50&gt; array2;    std::cout &lt;&lt; array1.GetSize() &lt;&lt; std::endl;    std::cout &lt;&lt; array2.GetSize() &lt;&lt; std::endl;&#125;</code></pre><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板跟类模板的区别是函数模板在使用时<strong>不强制</strong>需要通过\&lt;&gt;来指定类型是什么,编译器会自动的根据调用函数时传进来的参数类型来进行使用.<br>只有当调用这个函数时,这个函数才会被实际创建.</p><blockquote><p>例如这里定义一个函数min,调用时直接 c = min(a,b)即可,编译器会根据a和b的类型自动替代模板T</p><pre><code class="lang-cpp">template &lt;typename T&gt;inlineconst T&amp; min(const T&amp; a, const T&amp; b)&#123;  return b &lt; a ? b : a;&#125;</code></pre></blockquote><hr><h1 id="inline-内联-函数"><a href="#inline-内联-函数" class="headerlink" title="inline(内联)函数"></a>inline(内联)函数</h1><blockquote><p>在class的本体里面进行定义的函数会自动成为inline函数的<strong>候选人</strong>,之所以是候选人是因为编译器会根据函数的内容的复杂程度来将函数变成inline函数，如果太复杂就无法变成inline函数。<br>在类外面进行定义的函数可以通过添加inline关键字来让编辑器<strong>尽量</strong>将函数变成inline函数</p></blockquote><p>inline函数的好处是比较快。</p><hr><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><blockquote><p>构造函数的作用是当类的对象被创建出来时会自动的进行调用</p></blockquote><p>构造函数的名字需要跟类的名字一样。</p><hr><h2 id="构造函数的特殊语法：initialization-list-初值列，初始列"><a href="#构造函数的特殊语法：initialization-list-初值列，初始列" class="headerlink" title="构造函数的特殊语法：initialization list(初值列，初始列)"></a>构造函数的特殊语法：initialization list(初值列，初始列)</h2><blockquote><p>构造函数可以后面可以加:来写赋值的操作，例如下图中将形参r和形参i赋予类的自定义变量re和im<br><img src="/.com//image-1.png" alt="Alt text"></p></blockquote><hr><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><blockquote><p>重载的意思是： 允许创建多个名称相同的函数，但是函数所需要的参数需要不同，这样就可以在调用的时候根据传入的参数的个数与类型的不同来调用不同的对应函数</p></blockquote><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>操作符是+,-,*,+=,-=,==,!=这些符号.<br>操作符也可以被重载,只需要在定义与声明的操作符前面加上operator即可</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;struct Vector2&#123;    float x;    float y;    Vector2(float X, float Y) :x(X), y(Y) &#123;&#125;;    Vector2 Add(const Vector2 other) const &#123;        return Vector2(x + other.x, y + other.y);    &#125;    Vector2 operator +(const Vector2&amp; other) const&#123;        return Add(other);    &#125;    Vector2 multiply(const Vector2 other) const &#123;        return Vector2(x * other.x, y * other.y);    &#125;    Vector2 operator *(const Vector2 other) const &#123;        return multiply(other);    &#125;    bool operator ==(const Vector2 other) const &#123;        return x == other.x &amp;&amp; y == other.y;    &#125;&#125;;ostream&amp; operator &lt;&lt;(ostream&amp; stream, const Vector2&amp; vector)  &#123;    stream &lt;&lt; &quot;(&quot; &lt;&lt; vector.x &lt;&lt; &quot;,&quot; &lt;&lt; vector.y &lt;&lt; &quot;)&quot;;     return stream;&#125;int main()&#123;    Vector2 a(1.0f, 2.0f);    Vector2 b(3.0f, 4.0f);    cout &lt;&lt; &quot;a==&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b==&quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;a+b==&quot; &lt;&lt; a + b &lt;&lt; endl;    cout &lt;&lt; &quot;a*b==&quot; &lt;&lt; a * b &lt;&lt; endl;    cout &lt;&lt; &quot;a==b:&quot; &lt;&lt; (a == b) &lt;&lt; endl;    cin.get();&#125;</code></pre><hr><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><blockquote><p>const可以用来针对函数也可以用来针对变量.<br>const用在类的成员函数上表示这个函数不会修改对象(*this)内部的数据成员.<br>const用在对象上表示这个对象不会被进行修改.</p></blockquote><p><strong>基础类型不需要添加const,因为他们是等效的</strong><br>例如const int 与 int是等效的.<br>基础类型有int,char,bool,float,void这些.</p><p><strong>const针对指针的不同写法的区别:</strong><br>const放到<em>号前面代表,指针指向的内容是不能改变的<br>const放到</em>号后面代表,指针的指向是不能改变的(不能够给ptr一个其他的地址),但是指针指向的内容(<em>ptr)是可以改变的<br>const int</em> ptr = int const<em> ptr != int</em> const ptr</p><p><strong>如果一个函数不针对参数进行修改一定要记得加上const</strong>.<br>原因是因为如果一个对象被定义为const,那么这个对象就不能够使用没有被const定义的函数.</p><ul><li>const用在函数上:  函数类型 函数名() const {}</li><li>const用在变量上: const 类名 对象名();</li></ul><h1 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h1><blockquote><p>mutable有两种不同的用途,其中之一是与const一起使用,另一种是用在lambda表达式中,或同时覆盖这两种情况.<br>mutable绝大部分情况下是用在类中使用的,不会使用在lambda上面<br>```cpp</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></iostream></h1><p>class Enitity<br>{<br>private:<br>    std::string m_Name = “TestName”;<br>    mutable int m_Debug_num = 0; // 添加mutable可以让const函数中改变<br>public:<br>    const std::string&amp; Get_Name() const<br>    {<br>        m_Debug_num++;<br>        std::cout &lt;&lt; m_Debug_num &lt;&lt; std::endl;<br>        return m_Name;<br>    }<br>};</p></blockquote><p>int main()<br>{<br>    const Enitity e;<br>    for(int i = 0; i &lt; 5 ; i++)<br>    {<br>        std::cout &lt;&lt; e.Get_Name() &lt;&lt; std::endl;<br>    }</p><pre><code>std::cin.get();</code></pre><p>}</p><pre><code>---# friend友元函数&gt;类中被定义为private的成员只能被类的函数所访问,但是通过友元函数打开封装的大门.友元函数可以在类中进行声明,声明以后这个被声明为友元函数的函数就可以访问类的private里的参数了.**友元函数只需要在类中声明即可,友元函数的定义不需要在类中定义.** **相同class的各个object互为友元**,也就是说相同类的obj1和obj2可以互相访问对方的私有成员.---# static 静态&gt; 可以把函数和变量设定为静态的,静态的函数和变量是属于类的,无论创建多少个对象,这个设定为静态的函数和变量都只有一份.## 静态变量静态变量只有一份,属于类,不同的对象都是使用的这一份.如果不是静态变量,那么创建多少个对象就会有多少个对应的变量## 静态函数静态函数不像其他的类的函数一样有this指针,静态函数是没有this指针的,因此静态函数的定义中是不能够访问类中的其他变量的,静态函数只能够访问静态变量.静态函数可以通过类名来调用---# 继承与多态与虚函数表## 继承&gt; 继承代表了 is a 关系&gt; 子类的范围大小是要比父类要大的&gt; 构造是由内而外的,先执行父类的构造函数,再执行子类的构造函数.&gt; 析构是由外而内的,先执行子类的析构函数,再执行父类的析构函数.&gt; **父类的析构函数必须是virtual**,否则会出现undefined behavior用下图来表示, Base这个类是父类,Derived这个类是子类.![Alt text](image-5.png)## 多态与虚函数表&gt; 多态是面向对象编程中的一种特性，它允许同一个接口调用的不同实现。这种特性使得一个基类指针或引用可以指向派生类的对象，并且可以调用派生类的重载方法，而不需要知道具体的派生类。这种机制主要有两种类型：1.编译时多态（静态多态性）：通过函数重载和模板实现。2.运行时多态（动态多态性）：通过虚函数（virtual functions）和继承实现。在C++中，运行时多态通过虚函数来实现。当基类的一个方法被声明为虚函数，派生类可以重写（override）这个方法。当通过基类指针或引用调用这个方法时，会执行指向对象的实际类型的版本。&gt; 函数表是由编译器实现的一种机制，用来支持C++的运行时多态性。它是一个指针表，其中包含类的虚函数的地址。每个拥有虚函数的类都有一个虚函数表。具体来说：虚函数表（vtable）：每个包含虚函数的类都有一个虚函数表，表中包含该类的所有虚函数的地址。虚指针（vptr）：每个对象包含一个指向该类的虚函数表的指针。当对象创建时，这个指针被初始化指向相应的虚函数表。当通过基类指针或引用调用虚函数时，程序会通过对象的虚指针找到对应的虚函数表，然后从表中找到实际要调用的函数地址，并进行调用。## 代码举例</code></pre><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <iostream></iostream></h1><p>class Parent<br>{<br>public:<br>    Parent() { std::cout &lt;&lt; “进行父类构造函数” &lt;&lt; std::endl; }<br>    virtual ~Parent() { std::cout &lt;&lt; “进行父类析构函数” &lt;&lt; std::endl; }<br>    virtual void Print() { std::cout &lt;&lt; “执行父类的Print函数”&lt;&lt; std::endl; }<br>};</p><p>class Child : public Parent<br>{<br>private:<br>    int* m_Array;<br>public:<br>    void Print() override {<br>        std::cout &lt;&lt; “执行子类的Print函数” &lt;&lt; std::endl; }<br>    Child() { m_Array = new int[5]; std::cout &lt;&lt; “创建内存并进行子类构造函数” &lt;&lt; std::endl; }<br>    ~Child() { delete[] m_Array; std::cout &lt;&lt; “删除创建的内存并进行子类析构函数” &lt;&lt; std::endl; }<br>};</p><p>int main()<br>{<br>    Parent<em> parent = new Parent();<br>    parent-&gt;Print();<br>    delete parent;<br>    std::cout &lt;&lt; “——————————“ &lt;&lt; std::endl;<br>    Child</em> child = new Child();<br>    child-&gt;Print();<br>    delete child;<br>    std::cout &lt;&lt; “——————————“ &lt;&lt; std::endl;<br>    Parent* poly = new Child(); // 基于多态的特性,申请子类的内存去创建指向Parent类型的指针<br>    poly-&gt;Print(); // 因为虚函数表的存在,实际调用的将会是子类的Print函数<br>    delete poly; // 如果父类的析构函数没有设置成virtual,那么将不会调用子类的析构函数.将会造成内存泄漏</p><pre><code>std::cin.get();</code></pre><p>}</p><pre><code>---# 复合&gt; 复合代表了 has a 关系&gt; 一个类中可以包含其他类,然后可以使用包含的其他类的东西,这种情况叫做复合&gt; 包含其他类的这个大类可以称之为container(容器),其所包含的类称之为component(组件)&gt; 构造是由内而外的,先执行component的**默认**构造函数,再执行container的构造函数&gt; 析构是由外而内的,先执行container的析构函数,再执行component的析构函数用下图来表示,**菱形是实心的黑色**意思是Container这个类包含了Component这个类![Alt text](image-3.png)---# 委托(又称代理) delegation&gt; 委托跟复合的区别是,它包含的是其他类的指针,用下图来表示,**菱形是空心的**,空心可以这样解释:一个拥有其他类,但是因为是指针,不是实实在在的,所以是空心.![Alt text](image-4.png)---# virtual&amp;pure virtual 虚函数和纯虚函数&gt; 虚函数的概念:父类的函数声明前加上virtual,即可将父类的这个函数设定为虚函数,设定为虚函数以后,这个函数就能够被父类的子类重新定义,并且父类本身要有对于这个函数的定义.&gt; 纯虚函数的概念: 父类的函数声明前加上virtual,然后后面加上&quot;=0&quot;,即可将父类的这个函数设定为纯虚函数,纯虚函数必须被父类的子类重新定义,并且父类本身一般没有进行这个函数的定义.# 转换函数如图中所示红框黄底的代码就是转换函数,有了这个转换函数后,就可以在进行运算时编译器能够自动地寻找合适的类型来进行运算.**转换函数是没有返回类型的**![Alt text](image-6.png)---# 三元操作符三元操作符可以实现一行代码就能实现if else功能```cpp#include &lt;iostream&gt;int main()&#123;    int a = 5;    int b = 4;    std::string c = a &gt; b ? &quot;a大于b&quot; : &quot;a小于b&quot;;  /*等同于    std::string c;    if (a &gt; b)         c = &quot;a大于b&quot;;    else         c = &quot;a小于b&quot;;  */  std::cout &lt;&lt; c &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><hr><h1 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h1><p><strong>new与delete</strong><br>new是用于在堆上动态分配内存的关键字,它会返回一个指向分配的内存的指针<br>delete用于释放由new分配的动态内存<br>当使用new时要配合使用delete,当使用new[]时要配合使用delete[]<br>语法1:<br>type<em> ptr = new type<br>delete ptr<br>语法2 分配指定大小:<br>type</em> arrayPtr = new type[size]<br>delete[] arrayPtr</p><h1 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h1><p>栈与堆,它们是我们可以存储数据的地方,它们的工作原理非常不同,但本质上它们做的事情是一样的.<br><strong>栈:</strong><br>在函数调用时,函数的局部变量和参数会被存储在栈中.当函数执行完成后,这些数据会被自动释放.<br>栈的内容分配速度更快,但是大小有限.<br>栈是由编译器自动管理的,在栈上分配内存就是一条cpu指令<br>栈分配的内存地址是连续的.<br><strong>堆:</strong><br>堆是一种动态分配的内存池,是由程序员负责管理的.<br>堆分配的内存地址不是连续的.<br>在堆上分配的内存需要手动释放,否则会导致内存泄漏.</p><hr><h1 id="隐式转换和explicit"><a href="#隐式转换和explicit" class="headerlink" title="隐式转换和explicit"></a>隐式转换和explicit</h1><p>隐式转换是在没有显式指示的情况下，由编译器自动进行的类型转换。<br>explicit关键字用于防止构造函数或转换运算符进行隐式转换，仅允许显式转换。这在防止意外的类型转换错误方面非常有用。</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Entity&#123;private:    string m_name;    int m_age;public:    explicit Entity(const string&amp; name)        : m_name(name), m_age(-1) &#123;&#125;;    explicit Entity(int age)        : m_name(&quot;Unknown&quot;), m_age(age) &#123;&#125;;    const void PrintEntity() const    &#123;        cout &lt;&lt; m_name &lt;&lt; endl;        cout &lt;&lt; m_age &lt;&lt; endl;    &#125;&#125;;void printEntity(const Entity&amp; e)&#123;    e.PrintEntity();&#125;int main()&#123;    Entity e1 = Entity(&quot;TestName&quot;);    Entity e2 = Entity(23);    printEntity(e1);    printEntity(e2);    /*如果构造函数没有explicit的话这些是可以执行的,因为允许隐式转换    Entity e3 = &quot;TestName2&quot;;    Entity e4 = 23;    printEntity(22);    printEntity(string(&quot;Name&quot;));    */    cin.get();&#125;</code></pre><hr><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="智能指针的概念"><a href="#智能指针的概念" class="headerlink" title="智能指针的概念"></a>智能指针的概念</h2><p>已知,在堆上分配内存需要手动使用delete来删除内存.而智能指针的作用是为了实现分配内存和释放内存这一过程自动化的一种方式.<br>智能指针本质上是一个原始指针的包装.<br>当创建一个智能指针,它会调用new来分配内存,然后基于智能指针的使用方式,这些内存会在某一时刻被自动释放.</p><h2 id="智能指针的类型"><a href="#智能指针的类型" class="headerlink" title="智能指针的类型"></a>智能指针的类型</h2><p>智能指针有很多种类型.分别是unique_ptr,shared_ptr,weak_ptr.<br>智能指针中最简单的是unique_ptr,unique_ptr是作用域指针,当代码执行超过作用域时,它会被销毁并调用delete来释放内存.<br>unique_ptr这种类型的智能指针不能够进行拷贝,因为如果两个智能指针同时指向一个内存,当释放内存后,其中一个智能指针会指向一个已经被删除的内存.<br>shared_ptr多了一个控制块来存储引用计数,因此shared_ptr能够进行拷贝,可以多个shared_ptr指向同一个对象,当引用计数为0时,内存将进行释放(调用析构函数).<br>weak_ptr负责与shared_ptr一起使用,</p><h2 id="为了便于理解unique-ptr-所做的举例"><a href="#为了便于理解unique-ptr-所做的举例" class="headerlink" title="为了便于理解unique_ptr,所做的举例:"></a>为了便于理解unique_ptr,所做的举例:</h2><pre><code class="lang-cpp">#include &lt;iostream&gt;class Entity &#123;public:    Entity() &#123;        std::cout &lt;&lt; &quot;创建了一个Entity对象&quot; &lt;&lt; std::endl;    &#125;    ~Entity() &#123;        std::cout &lt;&lt; &quot;释放了Entity对象的空间&quot; &lt;&lt; std::endl;    &#125;&#125;;// 定义一个unique_ptr智能指针,负责管理Entity这个类的对象class ScopedPtr &#123;private:    Entity* m_ptr;public:    ScopedPtr(Entity* ptr) : m_ptr(ptr) &#123;&#125;;    ~ScopedPtr() &#123;        delete m_ptr;    &#125;&#125;;int main()&#123;    &#123;        ScopedPtr e1(new Entity());        ScopedPtr e2 = new Entity(); //因为使用了隐式转换,因此这一行相当于:ScopedPtr e2(new Entity());    &#125;    std::cin.get();&#125;</code></pre><h2 id="实际上使用智能指针时的举例以及不同智能指针种类的对比"><a href="#实际上使用智能指针时的举例以及不同智能指针种类的对比" class="headerlink" title="实际上使用智能指针时的举例以及不同智能指针种类的对比:"></a>实际上使用智能指针时的举例以及不同智能指针种类的对比:</h2><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;memory&gt;class Entity &#123;public:    Entity() &#123;        std::cout &lt;&lt; &quot;创建了一个Entity对象&quot; &lt;&lt; std::endl;    &#125;    ~Entity() &#123;        std::cout &lt;&lt; &quot;释放了Entity对象的空间&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    &#123;        std::weak_ptr&lt;Entity&gt; weakPtr; // 创建一个std::weak_ptr类型的智能指针但它尚未指向任何对象        &#123;            std::unique_ptr&lt;Entity&gt; uniquePtr = std::make_unique&lt;Entity&gt;(); // 创建一个std::unique_ptr类型的智能指针指向Entity的对象.这里&lt;&gt;符号涉及到了模板.            // std::unique_ptr&lt;Entity&gt; uniquePtr2 = uniquePtr; 这一句会失败,因为unique_ptr类型的智能指针不能够进行拷贝.            std::shared_ptr&lt;Entity&gt; sharedPtr = std::make_shared&lt;Entity&gt;(); // 创建一个std::shared_ptr类型的智能指针指向Entity的对象,它可以进行拷贝.            weakPtr = sharedPtr; // 现在weakPtr和sharedPtr指向同一个内容,但是weakPtr不会增加sharedPtr的引用计数        &#125; // 当执行到这里时,sharedPtr的引用计数已经为0了,uniquePtr和sharedPtr都已经销毁，,释放了内存,现在weakPtr指向的对象已经被销毁,并且可以通过weakPtr.expired()来判断weakPtr指向的对象是否已经被销毁        if (weakPtr.expired()) &#123;            std::cout &lt;&lt; &quot;weakPtr 指向的对象已被销毁&quot; &lt;&lt; std::endl;        &#125;    &#125;    std::cin.get();&#125;</code></pre><hr><h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>动态数组std::vector是标准库的一部分,要想使用它,需要#include \<vector><br>std::vector可以根据需要自动调整其大小。这意味着你可以在运行时添加或删除元素，而不需要手动管理内存。</vector></p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;struct Vertex &#123;    float x, y, z;    Vertex(float x, float y, float z) :x(x), y(y), z(z) &#123;&#125;;&#125;;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Vertex&amp; vertex) &#123;    return stream &lt;&lt; vertex.x &lt;&lt; &quot;,&quot; &lt;&lt; vertex.y &lt;&lt; &quot;,&quot; &lt;&lt; vertex.z &lt;&lt; std::endl;&#125;// 动态数组相关的函数的写法:void Function(const std::vector&lt;Vertex&gt;&amp; vertices)&#123;&#125;int main()&#123;    std::vector&lt;Vertex&gt; vertices;    // 定义vertices的初始大小为3.(定义一个初始大小对于优化有好处,因为动态数组的动态扩展是依靠复制实现的)    vertices.reserve(3);    // 向动态数组添加内容的第一种方式    vertices.push_back(Vertex( 1,2,3 ));    vertices.push_back(Vertex( 2,3,4 ));    vertices.push_back(Vertex( 3,4,5 ));    // 向动态数组添加内容的第二种方式(更高效,推荐,减少了动态数组在动态扩展时不必要的复制)    // emplace_back允许将参数直接传递给Vertex的构造函数中,而不需要创建一个临时对象    vertices.emplace_back(1, 2, 3);    vertices.emplace_back(2, 3, 4);    vertices.emplace_back(3, 4, 5);    // 第一种遍历vector动态数组的方式    for (int i = 0; i &lt; vertices.size(); i++)    &#123;        std::cout &lt;&lt; vertices[i];    &#125;    // 删除动态数组的第二个元素,vertices.begin()返回第一个元素的迭代器    vertices.erase(vertices.begin() + 1);    // 第二种遍历vector动态数组的方式(使用引用的话更节省内存空间,因为不会涉及到复制)    for (Vertex&amp; i : vertices) &#123;        std::cout &lt;&lt; i;    &#125;    std::cin.get();&#125;</code></pre><hr><h1 id="C-中使用库"><a href="#C-中使用库" class="headerlink" title="C++中使用库"></a>C++中使用库</h1><blockquote><p>预编译二进制文件（pre-compiled binaries）是已经编译好的可执行文件或库，它们可以直接在目标系统上运行或使用，而无需进行源码编译。使用预编译二进制文件的主要优点是节省了用户自己编译源码所需的时间和资源。</p><h1 id="include-lt-gt-：用于标准库和第三方库头文件"><a href="#include-lt-gt-：用于标准库和第三方库头文件" class="headerlink" title="include &lt;&gt;：用于标准库和第三方库头文件"></a>include &lt;&gt;：用于标准库和第三方库头文件</h1><h1 id="include-“”：用于项目内部头文件"><a href="#include-“”：用于项目内部头文件" class="headerlink" title="include “”：用于项目内部头文件"></a>include “”：用于项目内部头文件</h1><p>静态链接是在编译时将库的代码复制到生成的可执行文件中，从而生成一个独立的、包含所有代码的可执行文件。<br>动态链接是在程序运行时将库加载到内存中。可执行文件只包含对库的引用，而不包含库的实际代码。</p></blockquote><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>以glfw静态链接举例:</p><ol><li>前往glfw网站下载预编译二进制文件<a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a></li><li>将其中的include文件夹和lib文件夹放到项目中.<br>类似这种,在HelloWorld项目文件夹中新建一个Dependencies文件夹,里面再创建一个glfw文件夹,然后将glfw的include文件夹和lib文件夹放到这里面.<br><img src="/.com//image-10.png" alt="alt text"></li><li>修改项目配置中附加包含目录<br><img src="/.com//image-11.png" alt="alt text"></li><li>修改链接器对应的附加库目录<br><img src="/.com//image-12.png" alt="alt text"></li><li>添加glfw3.lib;到附加依赖项<br><img src="/.com//image-13.png" alt="alt text"></li><li>使用以下代码编译测试<br>```cpp<h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <GLFW glfw3.h></GLFW></h1></li></ol><p>int main()<br>{<br>    int a = glfwInit();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;</p><pre><code>std::cin.get();</code></pre><p>}</p><pre><code>## 动态链接在glfw静态链接的基础上举例:1. 将链接器对应的附加库目录的glfw3.lib修改为flfw3dll.lib![alt text](image-14.png)2. 将glfw3.dll文件放到可执行文件exe的旁边,不然会因为动态链接找不到对应的dll文件.![alt text](image-15.png)## 创建与使用库1. 在解决方案处右键新建项目![alt text](image-16.png)2. 在库项目处右键属性,修改配置类型为静态库![alt text](image-17.png)3. 在主项目处右键属性,修改附加包含目录,使其可以include库中的头文件![alt text](image-18.png)4. **通过引用的方式实现自动的静态链接**![alt text](image-19.png)---# 宏,macro&gt; C++中的宏（Macros）是一种预处理指令，使用#define关键字来定义。在编译之前，预处理器会扫描代码中的宏定义，并用宏的具体内容替换掉代码中的宏调用。这一过程在编译器实际编译代码之前进行。宏可以用于定义常量、简化复杂的表达式、创建内联函数等。## 编译器中定义宏![alt text](image-20.png)## 无参数宏与有参数宏与多行宏```cpp#include &lt;iostream&gt;#include &lt;string&gt;// 在项目属性设置中的预处理器定义中设置的Debug模式下MY_DEBUG=1,MY_RELEASE=0,Release模式下MY_DEBUG=0,MY_RELEASE=1// 判断宏的值是否为1#if MY_DEBUG == 1// 定义带参数的宏和多行的宏#define LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl#define ADD int add(int x,int y)\&#123;\return x+y;\&#125;// 在MY_RELEASE被定义不为0的情况下才会执行下面这些#elif defined(MY_RELEASE)#define LOG(x)// 结束宏定义#endifADDint main()&#123;    LOG(&quot;Hello&quot;);    LOG(add(1, 2));    std::cin.get();&#125;</code></pre><hr><h1 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h1><blockquote><p>auto 关键字是C++11引入的一种类型推导机制，用于让编译器根据初始化表达式自动推导变量的类型。<br>auto适合用在迭代器上,用于避免繁琐的类型声明.</p></blockquote><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;unordered_map&gt;int main() &#123;    std::unordered_map&lt;std::string, int&gt; myUnorderedMap1 = &#123; &#123;&quot;apple&quot;, 1&#125;, &#123;&quot;banana&quot;, 2&#125;, &#123;&quot;cherry&quot;, 3&#125; &#125;;    // 显式声明迭代器类型    for (std::unordered_map&lt;std::string, int&gt;::iterator it = myUnorderedMap1.begin(); it != myUnorderedMap1.end(); ++it) &#123;        std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;    &#125;    std::unordered_map&lt;std::string, int&gt; myUnorderedMap2 = &#123; &#123;&quot;auto_apple&quot;, 1&#125;, &#123;&quot;auto_banana&quot;, 2&#125;, &#123;&quot;auto_cherry&quot;, 3&#125; &#125;;    // 使用 auto 声明迭代器    for (auto it = myUnorderedMap2.begin(); it != myUnorderedMap2.end(); ++it) &#123;        std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;    &#125;    std::cin.get();    return 0;&#125;</code></pre><hr><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><blockquote><p>std::array 是 C++ 标准库中的一个容器类，定义在 \<array> 头文件中。它提供了与内置数组类似的功能，但具有更多的标准库容器的特性和接口。</array></p></blockquote><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;array&gt;int main() &#123;    std::array&lt;int, 5&gt; arr = &#123; 1, 2, 3, 4, 5 &#125;;    // 使用范围 for 循环遍历    for (const auto&amp; elem : arr) &#123;        std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;    // 使用传统 for 循环遍历    for (size_t i = 0; i &lt; arr.size(); ++i) &#123;        std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;    return 0;&#125;</code></pre><hr><h1 id="函数指针与lambda表达式"><a href="#函数指针与lambda表达式" class="headerlink" title="函数指针与lambda表达式"></a>函数指针与lambda表达式</h1><blockquote><p>函数指针是一个指向函数的指针，它允许你通过指针调用函数，而不仅仅是通过函数名直接调用。函数指针在C和C++中非常有用，因为它们使得编写更灵活和模块化的代码成为可能。例如，可以将函数指针作为参数传递给另一个函数，或者在运行时决定调用哪个函数。<br>```cpp</p><h1 id="include-4"><a href="#include-4" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-5"><a href="#include-5" class="headerlink" title="include "></a>include <vector></vector></h1></blockquote><p>void PrintValue(int value)<br>{<br>    std::cout &lt;&lt; “Value: “ &lt;&lt; value &lt;&lt; std::endl;<br>}</p><p>void ForEach(const std::vector<int>&amp; values, void(*func)(int))<br>{<br>    for (int value : values)<br>        func(value);<br>}</int></p><p>int main() {</p><pre><code>std::vector&lt;int&gt; values = &#123; 1, 5, 3, 4, 2 &#125;;/*显式定义函数指针。void(*funcPtr)(int);funcPtr = PrintValue;ForEach(values, funcPtr);*//*使用 typedef 定义函数指针类型别名。typedef void(*PrintValueFunction)(int);PrintValueFunction func = PrintValue;ForEach(values, func);*//*直接使用函数名作为参数。ForEach(values, PrintValue);*/// 使用lambda表达式创建匿名函数来代替函数指针// []中的内容是匿名函数可以访问的外部的参数,当[]中的值是&quot;=&quot;号时,代表外部的参数都传递值进来,当[]中的值时&quot;&amp;&quot;时,代表外部的参数都传递引用进来,// ()中的内容是匿名函数接收的参数// &#123;&#125;中的内容是匿名函数的代码块ForEach(values, [](int value) &#123;    std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl;     &#125;);std::cin.get();return 0;</code></pre><p>}</p><pre><code>---# 线程```cpp#include &lt;iostream&gt;#include &lt;thread&gt;static bool is_thread_working = true;void ThreadFunc(const std::string name)&#123;    using namespace std::literals::chrono_literals; // 使能够直接输入1s    std::cout &lt;&lt; &quot;这个子线程的id是:&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;    while(is_thread_working)    &#123;        std::cout &lt;&lt; &quot;Thread name : &quot; &lt;&lt; name &lt;&lt; &quot;Working... &quot; &lt;&lt; std::endl;        std::this_thread::sleep_for(1s); // 线程睡眠1s    &#125;    std::cout &lt;&lt; &quot;不再循环输出Working...&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::cout &lt;&lt; &quot;这个主线程的id是:&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;    void(*ThreadFuncPtr)(std::string);    ThreadFuncPtr = ThreadFunc;    std::cout &lt;&lt; &quot;开始执行子线程id&quot; &lt;&lt; std::endl;    std::thread worker(ThreadFunc,&quot;Test&quot;);    std::cin.get();    is_thread_working = false;    worker.join(); // woker.join()的意思是只有当worker这个线程结束后才会执行后面的语句    std::cout &lt;&lt; &quot;线程结束了&quot; &lt;&lt; std::endl;    std::cin.get();    return 0;&#125;</code></pre><hr><h1 id="定义计时器"><a href="#定义计时器" class="headerlink" title="定义计时器"></a>定义计时器</h1><p>如下代码所示,通过chrono来定义Timer结构体,放到自定义函数中配合构造函数和析构函数来计算函数的执行时间.</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;struct Timer &#123;    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;    std::chrono::duration&lt;float&gt; duration;    Timer()     &#123;        start = std::chrono::high_resolution_clock::now();        duration = std::chrono::duration&lt;float&gt;::zero();    &#125;    ~Timer()     &#123;        end = std::chrono::high_resolution_clock::now();        duration = end - start;        float ms = duration.count() * 1000.0f;        std::cout &lt;&lt; &quot;执行时间为:&quot; &lt;&lt; ms &lt;&lt; &quot;毫秒&quot; &lt;&lt; std::endl;    &#125;&#125;;void TestFunc() &#123;    Timer timer;    for (int i = 1; i &lt; 100; i++)    &#123;        std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    TestFunc();    std::cin.get();&#125;</code></pre><hr><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>下面介绍了三种使用std::sort对std::vector进行排序的过程</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // 使用std::sort排序需要包含算法库#include &lt;functional&gt; // 使用std::greater需要包含函数库int main() &#123;    std::vector&lt;int&gt; values = &#123;3,5,1,4,2&#125;;    // std::sort(values.begin(), values.end()); // 默认是按照升序进行排序    // std::sort(values.begin(), values.end(), std::greater&lt;int&gt;()); // 按照降序进行排序    // 使用lambda表达式进行排序    std::sort(values.begin(), values.end(), [](int a, int b)         &#123;            if (a == 1)                return false;            if (b == 1)                return true;            return a &lt; b;        &#125;);    for (int value : values)    &#123;        std::cout &lt;&lt; value &lt;&lt; std::endl;    &#125;    std::cin.get();&#125;</code></pre><hr><h1 id="类型双关"><a href="#类型双关" class="headerlink" title="类型双关"></a>类型双关</h1><blockquote><p>类型双关（type punning）是指在编程中通过不同的类型来访问同一块内存。换句话说，就是使用一种类型的变量或指针来访问另一种类型的数据。这通常通过类型转换和指针运算来实现。</p></blockquote><p>在这个例子中，我们将一个 float 类型的变量 x 的内存解释为 int 类型。这就是类型双关，因为我们用 int 类型的指针来访问原本是 float 类型的数据。</p><pre><code class="lang-cpp">#include &lt;iostream&gt;int main() &#123;    float x = 3.14;    int y = *(int*)&amp;x; // 将 float 的内存解释为 int    std::cout &lt;&lt; &quot;Float value: &quot; &lt;&lt; x &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Interpreted as int: &quot; &lt;&lt; y &lt;&lt; std::endl;    return 0;&#125;</code></pre><hr><h1 id="union-联合体"><a href="#union-联合体" class="headerlink" title="union(联合体)"></a>union(联合体)</h1><blockquote><p>在C++中，union（联合体）是一种特殊的数据结构，它允许你在同一个内存位置存储不同类型的变量。也就是说，union中的所有成员共享同一块内存，因此一个union实例在任何时候只能存储其中一个成员的数据。<br>如果想要给同一个类型取两个不同的名字时,它非常有用.<br>举例: 这里是把Vector4可以看成由两个Vector2组成的类型.</p></blockquote><pre><code class="lang-cpp">#include &lt;iostream&gt;struct Vector2&#123;    float x, y;&#125;;struct Vector4&#123;    union     &#123;        struct          &#123;            float x, y, z, w;        &#125;;        struct          &#123;            Vector2 a, b;        &#125;;    &#125;;&#125;;void PrintVector2(const Vector2&amp; vector)&#123;    std::cout &lt;&lt; vector.x &lt;&lt; &quot;,&quot; &lt;&lt; vector.y &lt;&lt; std::endl;&#125;int main() &#123;    Vector4 vector = &#123; 1.0f,2.0f,3.0f,4.0f &#125;;    PrintVector2(vector.a); // 输出1,2    PrintVector2(vector.b); // 输出3,4    std::cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; std::endl;    vector.z = 500.0f;    PrintVector2(vector.a); // 输出1,2    PrintVector2(vector.b); // 输出500,4    std::cin.get();&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VisualStudio的最佳设置&quot;&gt;&lt;a href=&quot;#VisualStudio的最佳设置&quot; class=&quot;headerlink&quot; title=&quot;VisualStudio的最佳设置&quot;&gt;&lt;/a&gt;VisualStudio的最佳设置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;新建项目</summary>
      
    
    
    
    <category term="Geek" scheme="http://example.com/categories/Geek/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
</feed>
